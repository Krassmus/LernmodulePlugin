{"ast":null,"code":"import _defineProperty from \"/home/ann/dev/studip/54/public/plugins_packages/RasmusFuhse/LernmodulePlugin/vue/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.error.cause.js\";\nconst SCOPE = Symbol(\"SCOPE\");\nlet scheduledEffects = false,\n    runningEffects = false,\n    currentScope = null,\n    currentObserver = null,\n    currentObservers = null,\n    currentObserversIndex = 0,\n    effects = [],\n    defaultContext = {};\n\nconst NOOP = () => {},\n      STATE_CLEAN = 0,\n      STATE_CHECK = 1,\n      STATE_DIRTY = 2,\n      STATE_DISPOSED = 3;\n\nfunction flushEffects() {\n  scheduledEffects = true;\n  queueMicrotask(runEffects);\n}\n\nfunction runEffects() {\n  if (!effects.length) {\n    scheduledEffects = false;\n    return;\n  }\n\n  runningEffects = true;\n\n  for (let i = 0; i < effects.length; i++) {\n    if (effects[i]._state !== STATE_CLEAN) runTop(effects[i]);\n  }\n\n  effects = [];\n  scheduledEffects = false;\n  runningEffects = false;\n}\n\nfunction runTop(node) {\n  let ancestors = [node];\n\n  while (node = node[SCOPE]) {\n    if (node._effect && node._state !== STATE_CLEAN) ancestors.push(node);\n  }\n\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    updateCheck(ancestors[i]);\n  }\n}\n\nfunction root(init) {\n  const scope = createScope();\n  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);\n}\n\nfunction peek(fn) {\n  return compute(currentScope, fn, null);\n}\n\nfunction untrack(fn) {\n  return compute(null, fn, null);\n}\n\nfunction tick() {\n  if (!runningEffects) runEffects();\n}\n\nfunction getScope() {\n  return currentScope;\n}\n\nfunction scoped(run, scope) {\n  try {\n    return compute(scope, run, null);\n  } catch (error) {\n    handleError(scope, error);\n    return;\n  }\n}\n\nfunction getContext(key, scope = currentScope) {\n  return scope?._context[key];\n}\n\nfunction setContext(key, value, scope = currentScope) {\n  if (scope) scope._context = { ...scope._context,\n    [key]: value\n  };\n}\n\nfunction onDispose(disposable) {\n  if (!disposable || !currentScope) return disposable || NOOP;\n  const node = currentScope;\n\n  if (!node._disposal) {\n    node._disposal = disposable;\n  } else if (Array.isArray(node._disposal)) {\n    node._disposal.push(disposable);\n  } else {\n    node._disposal = [node._disposal, disposable];\n  }\n\n  return function removeDispose() {\n    if (node._state === STATE_DISPOSED) return;\n    disposable.call(null);\n\n    if (isFunction$1(node._disposal)) {\n      node._disposal = null;\n    } else if (Array.isArray(node._disposal)) {\n      node._disposal.splice(node._disposal.indexOf(disposable), 1);\n    }\n  };\n}\n\nfunction dispose(self = true) {\n  if (this._state === STATE_DISPOSED) return;\n  let head = self ? this._prevSibling || this[SCOPE] : this,\n      current = this._nextSibling,\n      next = null;\n\n  while (current && current[SCOPE] === this) {\n    dispose.call(current, true);\n    disposeNode(current);\n    next = current._nextSibling;\n    current._nextSibling = null;\n    current = next;\n  }\n\n  if (self) disposeNode(this);\n  if (current) current._prevSibling = !self ? this : this._prevSibling;\n  if (head) head._nextSibling = current;\n}\n\nfunction disposeNode(node) {\n  node._state = STATE_DISPOSED;\n  if (node._disposal) emptyDisposal(node);\n  if (node._sources) removeSourceObservers(node, 0);\n  if (node._prevSibling) node._prevSibling._nextSibling = null;\n  node[SCOPE] = null;\n  node._sources = null;\n  node._observers = null;\n  node._prevSibling = null;\n  node._context = defaultContext;\n  node._handlers = null;\n}\n\nfunction emptyDisposal(scope) {\n  try {\n    if (Array.isArray(scope._disposal)) {\n      for (let i = scope._disposal.length - 1; i >= 0; i--) {\n        const callable = scope._disposal[i];\n        callable.call(callable);\n      }\n    } else {\n      scope._disposal.call(scope._disposal);\n    }\n\n    scope._disposal = null;\n  } catch (error) {\n    handleError(scope, error);\n  }\n}\n\nfunction compute(scope, compute2, observer) {\n  const prevScope = currentScope,\n        prevObserver = currentObserver;\n  currentScope = scope;\n  currentObserver = observer;\n\n  try {\n    return compute2.call(scope);\n  } finally {\n    currentScope = prevScope;\n    currentObserver = prevObserver;\n  }\n}\n\nfunction handleError(scope, error) {\n  if (!scope || !scope._handlers) throw error;\n  let i = 0,\n      len = scope._handlers.length,\n      coercedError = coerceError(error);\n\n  for (i = 0; i < len; i++) {\n    try {\n      scope._handlers[i](coercedError);\n\n      break;\n    } catch (error2) {\n      coercedError = coerceError(error2);\n    }\n  }\n\n  if (i === len) throw coercedError;\n}\n\nfunction coerceError(error) {\n  return error instanceof Error ? error : Error(JSON.stringify(error));\n}\n\nfunction read() {\n  if (this._state === STATE_DISPOSED) return this._value;\n\n  if (currentObserver && !this._effect) {\n    if (!currentObservers && currentObserver._sources && currentObserver._sources[currentObserversIndex] == this) {\n      currentObserversIndex++;\n    } else if (!currentObservers) currentObservers = [this];else currentObservers.push(this);\n  }\n\n  if (this._compute) updateCheck(this);\n  return this._value;\n}\n\nfunction write(newValue) {\n  const value = isFunction$1(newValue) ? newValue(this._value) : newValue;\n\n  if (this._changed(this._value, value)) {\n    this._value = value;\n\n    if (this._observers) {\n      for (let i = 0; i < this._observers.length; i++) {\n        notify(this._observers[i], STATE_DIRTY);\n      }\n    }\n  }\n\n  return this._value;\n}\n\nconst ScopeNode = function Scope() {\n  this[SCOPE] = null;\n  this._nextSibling = null;\n  this._prevSibling = null;\n  if (currentScope) currentScope.append(this);\n};\n\nconst ScopeProto = ScopeNode.prototype;\nScopeProto._context = defaultContext;\nScopeProto._handlers = null;\nScopeProto._compute = null;\nScopeProto._disposal = null;\n\nScopeProto.append = function (child) {\n  child[SCOPE] = this;\n  child._prevSibling = this;\n\n  if (this._nextSibling) {\n    if (child._nextSibling) {\n      let tail = child._nextSibling;\n\n      while (tail._nextSibling) tail = tail._nextSibling;\n\n      tail._nextSibling = this._nextSibling;\n      this._nextSibling._prevSibling = tail;\n    } else {\n      child._nextSibling = this._nextSibling;\n      this._nextSibling._prevSibling = child;\n    }\n  }\n\n  this._nextSibling = child;\n  child._context = child._context === defaultContext ? this._context : { ...this._context,\n    ...child._context\n  };\n\n  if (this._handlers) {\n    child._handlers = !child._handlers ? this._handlers : [...child._handlers, ...this._handlers];\n  }\n};\n\nScopeProto.dispose = function () {\n  dispose.call(this);\n};\n\nfunction createScope() {\n  return new ScopeNode();\n}\n\nconst ComputeNode = function Computation(initialValue, compute2, options) {\n  ScopeNode.call(this);\n  this._state = compute2 ? STATE_DIRTY : STATE_CLEAN;\n  this._init = false;\n  this._effect = false;\n  this._sources = null;\n  this._observers = null;\n  this._value = initialValue;\n  this.id = options?.id ?? (this._compute ? \"computed\" : \"signal\");\n  if (compute2) this._compute = compute2;\n  if (options && options.dirty) this._changed = options.dirty;\n};\n\nconst ComputeProto = ComputeNode.prototype;\nObject.setPrototypeOf(ComputeProto, ScopeProto);\nComputeProto._changed = isNotEqual;\nComputeProto.call = read;\n\nfunction createComputation(initialValue, compute2, options) {\n  return new ComputeNode(initialValue, compute2, options);\n}\n\nfunction isNotEqual(a, b) {\n  return a !== b;\n}\n\nfunction isFunction$1(value) {\n  return typeof value === \"function\";\n}\n\nfunction updateCheck(node) {\n  if (node._state === STATE_CHECK) {\n    for (let i = 0; i < node._sources.length; i++) {\n      updateCheck(node._sources[i]);\n\n      if (node._state === STATE_DIRTY) {\n        break;\n      }\n    }\n  }\n\n  if (node._state === STATE_DIRTY) update(node);else node._state = STATE_CLEAN;\n}\n\nfunction cleanup(node) {\n  if (node._nextSibling && node._nextSibling[SCOPE] === node) dispose.call(node, false);\n  if (node._disposal) emptyDisposal(node);\n  node._handlers = node[SCOPE] ? node[SCOPE]._handlers : null;\n}\n\nfunction update(node) {\n  let prevObservers = currentObservers,\n      prevObserversIndex = currentObserversIndex;\n  currentObservers = null;\n  currentObserversIndex = 0;\n\n  try {\n    cleanup(node);\n    const result = compute(node, node._compute, node);\n\n    if (currentObservers) {\n      if (node._sources) removeSourceObservers(node, currentObserversIndex);\n\n      if (node._sources && currentObserversIndex > 0) {\n        node._sources.length = currentObserversIndex + currentObservers.length;\n\n        for (let i = 0; i < currentObservers.length; i++) {\n          node._sources[currentObserversIndex + i] = currentObservers[i];\n        }\n      } else {\n        node._sources = currentObservers;\n      }\n\n      let source;\n\n      for (let i = currentObserversIndex; i < node._sources.length; i++) {\n        source = node._sources[i];\n        if (!source._observers) source._observers = [node];else source._observers.push(node);\n      }\n    } else if (node._sources && currentObserversIndex < node._sources.length) {\n      removeSourceObservers(node, currentObserversIndex);\n      node._sources.length = currentObserversIndex;\n    }\n\n    if (!node._effect && node._init) {\n      write.call(node, result);\n    } else {\n      node._value = result;\n      node._init = true;\n    }\n  } catch (error) {\n    if (!node._init && typeof node._value === \"undefined\") {\n      console.error(`computed \\`${node.id}\\` threw error during first run, this can be fatal.\n\nSolutions:\n\n1. Set the \\`initial\\` option to silence this error`, \"\\n2. Or, use an `effect` if the return value is not being used\", \"\\n\\n\", error);\n    }\n\n    handleError(node, error);\n\n    if (node._state === STATE_DIRTY) {\n      cleanup(node);\n      if (node._sources) removeSourceObservers(node, 0);\n    }\n\n    return;\n  }\n\n  currentObservers = prevObservers;\n  currentObserversIndex = prevObserversIndex;\n  node._state = STATE_CLEAN;\n}\n\nfunction notify(node, state) {\n  if (node._state >= state) return;\n\n  if (node._effect && node._state === STATE_CLEAN) {\n    effects.push(node);\n    if (!scheduledEffects) flushEffects();\n  }\n\n  node._state = state;\n\n  if (node._observers) {\n    for (let i = 0; i < node._observers.length; i++) {\n      notify(node._observers[i], STATE_CHECK);\n    }\n  }\n}\n\nfunction removeSourceObservers(node, index) {\n  let source, swap;\n\n  for (let i = index; i < node._sources.length; i++) {\n    source = node._sources[i];\n\n    if (source._observers) {\n      swap = source._observers.indexOf(node);\n      source._observers[swap] = source._observers[source._observers.length - 1];\n\n      source._observers.pop();\n    }\n  }\n}\n\nfunction noop(...args) {}\n\nfunction isNull(value) {\n  return value === null;\n}\n\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n\nfunction isNil(value) {\n  return isNull(value) || isUndefined(value);\n}\n\nfunction isNumber(value) {\n  return typeof value === \"number\" && !Number.isNaN(value);\n}\n\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\nconst EVENT = Event,\n      DOM_EVENT = Symbol(\"DOM_EVENT\");\n\nclass DOMEvent extends EVENT {\n  /**\n   * The event detail.\n   */\n\n  /**\n   * The preceding event that was responsible for this event being fired.\n   */\n\n  /**\n   * Walks up the event chain (following each `trigger`) and returns the origin event\n   * that started the chain.\n   */\n  get originEvent() {\n    return getOriginEvent(this) ?? this;\n  }\n  /**\n   * Walks up the event chain (following each `trigger`) and determines whether the initial\n   * event was triggered by the end user (ie: check whether `isTrusted` on the `originEvent` `true`).\n   */\n\n\n  get isOriginTrusted() {\n    return getOriginEvent(this)?.isTrusted ?? false;\n  }\n\n  constructor(type, ...init) {\n    super(type, init[0]);\n\n    _defineProperty(this, DOM_EVENT, true);\n\n    _defineProperty(this, \"detail\", void 0);\n\n    _defineProperty(this, \"trigger\", void 0);\n\n    this.detail = init[0]?.detail;\n    this.trigger = init[0]?.trigger;\n  }\n\n}\n\nfunction isDOMEvent(event) {\n  return !!event?.[DOM_EVENT];\n}\n\nfunction getOriginEvent(event) {\n  let trigger = event.trigger;\n\n  while (trigger && trigger.trigger) {\n    trigger = trigger.trigger;\n  }\n\n  return trigger;\n}\n\nfunction walkTriggerEventChain(event, callback) {\n  if (!isDOMEvent(event)) return;\n  let trigger = event.trigger;\n\n  while (trigger) {\n    const returnValue = callback(trigger);\n    if (returnValue) return [trigger, returnValue];\n    trigger = trigger.trigger;\n  }\n\n  return;\n}\n\nfunction findTriggerEvent(event, type) {\n  return walkTriggerEventChain(event, e => e.type === type)?.[0];\n}\n\nfunction hasTriggerEvent(event, type) {\n  return !!findTriggerEvent(event, type);\n}\n\nfunction appendTriggerEvent(event, trigger) {\n  const origin = getOriginEvent(event) ?? event;\n\n  if (origin === trigger) {\n    throw Error(\"[maverick] attemping to append event as a trigger on itself (cyclic)\");\n  }\n\n  if (typeof origin.trigger !== \"undefined\") {\n    console.warn(`[maverick] overwriting existing trigger event: \\`${origin.trigger.type}\\` -> \\`${trigger?.type}\\`\n\n`, \"Event:\\n\", event, \"Origin Event:\\n\", origin, \"Trigger Event:\\n\", trigger);\n  }\n\n  Object.defineProperty(origin, \"trigger\", {\n    configurable: true,\n    enumerable: true,\n    get: () => trigger\n  });\n}\n\nclass EventsTarget extends EventTarget {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"$ts__events\", void 0);\n  }\n\n  addEventListener(type, callback, options) {\n    return super.addEventListener(type, callback, options);\n  }\n\n  removeEventListener(type, callback, options) {\n    return super.removeEventListener(type, callback, options);\n  }\n\n}\n\nfunction listenEvent(target, type, handler, options) {\n  target.addEventListener(type, handler, options);\n  return onDispose(() => target.removeEventListener(type, handler, options));\n}\n\nfunction isPointerEvent(event) {\n  return !!event?.type.startsWith(\"pointer\");\n}\n\nfunction isTouchEvent(event) {\n  return !!event?.type.startsWith(\"touch\");\n}\n\nfunction isMouseEvent(event) {\n  return /^(click|mouse)/.test(event?.type ?? \"\");\n}\n\nfunction isKeyboardEvent(event) {\n  return !!event?.type.startsWith(\"key\");\n}\n\nfunction isKeyboardClick(event) {\n  return isKeyboardEvent(event) && (event.key === \"Enter\" || event.key === \" \");\n}\n\nfunction setAttribute(host, name, value) {\n  if (!host) return;else if (!value && value !== \"\" && value !== 0) {\n    host.removeAttribute(name);\n  } else {\n    const attrValue = value === true ? \"\" : value + \"\";\n\n    if (host.getAttribute(name) !== attrValue) {\n      host.setAttribute(name, attrValue);\n    }\n  }\n}\n\nfunction setStyle(host, property, value) {\n  if (!host) return;else if (!value && value !== 0) {\n    host.style.removeProperty(property);\n  } else {\n    host.style.setProperty(property, value + \"\");\n  }\n}\n\nfunction signal(initialValue, options) {\n  const node = createComputation(initialValue, null, options),\n        signal2 = read.bind(node);\n  signal2.node = node;\n  signal2[SCOPE] = true;\n  signal2.set = write.bind(node);\n  return signal2;\n}\n\nfunction isReadSignal(fn) {\n  return isFunction$1(fn) && SCOPE in fn;\n}\n\nfunction computed(compute, options) {\n  const node = createComputation(options?.initial, compute, options),\n        signal2 = read.bind(node);\n  signal2[SCOPE] = true;\n  signal2.node = node;\n  return signal2;\n}\n\nfunction effect$1(effect2, options) {\n  const signal2 = createComputation(null, function runEffect() {\n    let effectResult = effect2();\n    isFunction$1(effectResult) && onDispose(effectResult);\n    return null;\n  }, {\n    id: options?.id ?? \"effect\"\n  });\n  signal2._effect = true;\n  update(signal2);\n  {\n    return function stopEffect() {\n      dispose.call(signal2, true);\n    };\n  }\n}\n\nfunction isWriteSignal(fn) {\n  return isReadSignal(fn) && \"set\" in fn;\n}\n\nconst effect = effect$1;\n\nfunction createContext(provide) {\n  return {\n    id: Symbol(),\n    provide\n  };\n}\n\nfunction provideContext(context, value, scope = getScope()) {\n  if (!scope) {\n    throw Error(\"[maverick] attempting to provide context outside root\");\n  }\n\n  const hasProvidedValue = !isUndefined(value);\n\n  if (!hasProvidedValue && !context.provide) {\n    throw Error(\"[maverick] context can not be provided without a value or `provide` function\");\n  }\n\n  setContext(context.id, hasProvidedValue ? value : context.provide?.(), scope);\n}\n\nfunction useContext(context) {\n  const value = getContext(context.id);\n\n  if (isUndefined(value)) {\n    throw Error(\"[maverick] attempting to use context without providing first\");\n  }\n\n  return value;\n}\n\nfunction hasProvidedContext(context) {\n  return !isUndefined(getContext(context.id));\n}\n\nconst PROPS = /* @__PURE__ */Symbol(\"PROPS\");\nconst METHODS = /* @__PURE__ */Symbol(\"METHODS\");\nconst ON_DISPATCH = /* @__PURE__ */Symbol(\"ON_DISPATCH\");\nconst EMPTY_PROPS = {};\n\nclass Instance {\n  /** @internal type only */\n\n  /** @internal type only */\n\n  /* @internal */\n  constructor(Component, scope, init) {\n    _defineProperty(this, \"$ts__events\", void 0);\n\n    _defineProperty(this, \"$ts__vars\", void 0);\n\n    _defineProperty(this, ON_DISPATCH, null);\n\n    _defineProperty(this, \"$el\", signal(null));\n\n    _defineProperty(this, \"_el\", null);\n\n    _defineProperty(this, \"_scope\", null);\n\n    _defineProperty(this, \"_attachScope\", null);\n\n    _defineProperty(this, \"_connectScope\", null);\n\n    _defineProperty(this, \"_component\", null);\n\n    _defineProperty(this, \"_destroyed\", false);\n\n    _defineProperty(this, \"_props\", EMPTY_PROPS);\n\n    _defineProperty(this, \"_attrs\", null);\n\n    _defineProperty(this, \"_styles\", null);\n\n    _defineProperty(this, \"_state\", void 0);\n\n    _defineProperty(this, \"_$state\", void 0);\n\n    _defineProperty(this, \"_setupCallbacks\", []);\n\n    _defineProperty(this, \"_attachCallbacks\", []);\n\n    _defineProperty(this, \"_connectCallbacks\", []);\n\n    _defineProperty(this, \"_destroyCallbacks\", []);\n\n    this._scope = scope;\n    if (init?.scope) init.scope.append(scope);\n    let stateFactory = Component.state,\n        props = Component.props;\n\n    if (stateFactory) {\n      this._$state = stateFactory.create();\n      this._state = new Proxy(this._$state, {\n        get: (_, prop) => this._$state[prop]()\n      });\n      provideContext(stateFactory, this._$state);\n    }\n\n    if (props) {\n      this._props = createInstanceProps(props);\n\n      if (init?.props) {\n        for (const prop of Object.keys(init.props)) {\n          this._props[prop]?.set(init.props[prop]);\n        }\n      }\n    }\n\n    onDispose(this._destroy.bind(this));\n  }\n\n  _setup() {\n    scoped(() => {\n      for (const callback of this._setupCallbacks) callback();\n    }, this._scope);\n  }\n\n  _attach(el) {\n    if (this._el) return;\n    this._el = el;\n    this.$el.set(el);\n    {\n      el.$$COMPONENT_NAME = this._component?.constructor.name;\n    }\n    scoped(() => {\n      this._attachScope = createScope();\n      scoped(() => {\n        for (const callback of this._attachCallbacks) callback(this._el);\n\n        this._attachAttrs();\n\n        this._attachStyles();\n      }, this._attachScope);\n    }, this._scope);\n    el.dispatchEvent(new Event(\"attached\"));\n  }\n\n  _detach() {\n    this._attachScope?.dispose();\n    this._attachScope = null;\n    this._connectScope = null;\n\n    if (this._el) {\n      this._el.$$COMPONENT_NAME = null;\n    }\n\n    this._el = null;\n    this.$el.set(null);\n  }\n\n  _connect() {\n    if (!this._el || !this._attachScope || !this._connectCallbacks.length) return;\n    scoped(() => {\n      this._connectScope = createScope();\n      scoped(() => {\n        for (const callback of this._connectCallbacks) callback(this._el);\n      }, this._connectScope);\n    }, this._attachScope);\n  }\n\n  _disconnect() {\n    this._connectScope?.dispose();\n    this._connectScope = null;\n  }\n\n  _destroy() {\n    if (this._destroyed) return;\n    this._destroyed = true;\n    scoped(() => {\n      for (const callback of this._destroyCallbacks) callback(this._el);\n    }, this._scope);\n    const el = this._el;\n\n    this._detach();\n\n    this._scope.dispose();\n\n    this._setupCallbacks.length = 0;\n    this._attachCallbacks.length = 0;\n    this._connectCallbacks.length = 0;\n    this._destroyCallbacks.length = 0;\n    this._component = null;\n    this._attrs = null;\n    this._styles = null;\n    this._props = EMPTY_PROPS;\n    this._scope = null;\n    this._state = EMPTY_PROPS;\n    this._$state = null;\n    if (el) delete el.$;\n  }\n\n  _addHooks(target) {\n    if (target.onSetup) this._setupCallbacks.push(target.onSetup.bind(target));\n    if (target.onAttach) this._attachCallbacks.push(target.onAttach.bind(target));\n    if (target.onConnect) this._connectCallbacks.push(target.onConnect.bind(target));\n    if (target.onDestroy) this._destroyCallbacks.push(target.onDestroy.bind(target));\n  }\n\n  _attachAttrs() {\n    if (!this._attrs) return;\n\n    for (const name of Object.keys(this._attrs)) {\n      if (isFunction(this._attrs[name])) {\n        effect(this._setAttr.bind(this, name));\n      } else {\n        setAttribute(this._el, name, this._attrs[name]);\n      }\n    }\n  }\n\n  _attachStyles() {\n    if (!this._styles) return;\n\n    for (const name of Object.keys(this._styles)) {\n      if (isFunction(this._styles[name])) {\n        effect(this._setStyle.bind(this, name));\n      } else {\n        setStyle(this._el, name, this._styles[name]);\n      }\n    }\n  }\n\n  _setAttr(name) {\n    setAttribute(this._el, name, this._attrs[name].call(this._component));\n  }\n\n  _setStyle(name) {\n    setStyle(this._el, name, this._styles[name].call(this._component));\n  }\n\n}\n\nfunction createInstanceProps(props) {\n  const $props = {};\n\n  for (const name of Object.keys(props)) {\n    const def = props[name];\n    $props[name] = signal(def, def);\n  }\n\n  return $props;\n}\n\nlet currentInstance = {\n  $$: null\n};\n\nfunction createComponent(Component, init) {\n  return root(() => {\n    currentInstance.$$ = new Instance(Component, getScope(), init);\n    const component = new Component();\n    currentInstance.$$._component = component;\n    currentInstance.$$ = null;\n    return component;\n  });\n}\n\nclass ViewController extends EventTarget {\n  /** @internal */\n  get el() {\n    return this.$$._el;\n  }\n\n  get $el() {\n    return this.$$.$el();\n  }\n\n  get scope() {\n    return this.$$._scope;\n  }\n\n  get attachScope() {\n    return this.$$._attachScope;\n  }\n\n  get connectScope() {\n    return this.$$._connectScope;\n  }\n  /** @internal */\n\n\n  get $props() {\n    return this.$$._props;\n  }\n  /** @internal */\n\n\n  get $state() {\n    return this.$$._$state;\n  }\n\n  get state() {\n    return this.$$._state;\n  }\n\n  constructor() {\n    super();\n\n    _defineProperty(this, \"$$\", void 0);\n\n    if (currentInstance.$$) this.attach(currentInstance);\n  }\n\n  attach({\n    $$\n  }) {\n    this.$$ = $$;\n\n    $$._addHooks(this);\n\n    return this;\n  }\n\n  addEventListener(type, callback, options) {\n    if (!this.el) {\n      const name = this.constructor.name;\n      console.warn(`[maverick] adding event listener to \\`${name}\\` before element is attached`);\n    }\n\n    this.listen(type, callback, options);\n  }\n\n  removeEventListener(type, callback, options) {\n    this.el?.removeEventListener(type, callback, options);\n  }\n  /**\n   * This method can be used to specify attributes that should be set on the host element. Any\n   * attributes that are assigned to a function will be considered a signal and updated accordingly.\n   */\n\n\n  setAttributes(attributes) {\n    if (!this.$$._attrs) this.$$._attrs = {};\n    Object.assign(this.$$._attrs, attributes);\n  }\n  /**\n   * This method can be used to specify styles that should set be set on the host element. Any\n   * styles that are assigned to a function will be considered a signal and updated accordingly.\n   */\n\n\n  setStyles(styles) {\n    if (!this.$$._styles) this.$$._styles = {};\n    Object.assign(this.$$._styles, styles);\n  }\n  /**\n   * This method is used to satisfy the CSS variables contract specified on the current\n   * component. Other CSS variables can be set via the `setStyles` method.\n   */\n\n\n  setCSSVars(vars) {\n    this.setStyles(vars);\n  }\n  /**\n   * Type-safe utility for creating component DOM events.\n   */\n\n\n  createEvent(type, ...init) {\n    return new DOMEvent(type, init[0]);\n  }\n  /**\n   * Creates a `DOMEvent` and dispatches it from the host element. This method is typed to\n   * match all component events.\n   */\n\n\n  dispatch(type, ...init) {\n    if (!this.el) return false;\n    const event = type instanceof Event ? type : new DOMEvent(type, init[0]);\n    Object.defineProperty(event, \"target\", {\n      get: () => this.$$._component\n    });\n    return untrack(() => {\n      this.$$[ON_DISPATCH]?.(event);\n      return this.el.dispatchEvent(event);\n    });\n  }\n\n  dispatchEvent(event) {\n    return this.dispatch(event);\n  }\n  /**\n   * Adds an event listener for the given `type` and returns a function which can be invoked to\n   * remove the event listener.\n   *\n   * - The listener is removed if the current scope is disposed.\n   * - This method is safe to use on the server (noop).\n   */\n\n\n  listen(type, handler, options) {\n    if (!this.el) return noop;\n    return listenEvent(this.el, type, handler, options);\n  }\n\n}\n\nclass Component extends ViewController {\n  subscribe(callback) {\n    if (!this.state) {\n      const name = this.constructor.name;\n      throw Error(`[maverick] component \\`${name}\\` can not be subscribed to because it has no internal state`);\n    }\n\n    return scoped(() => effect(() => callback(this.state)), this.$$._scope);\n  }\n\n  destroy() {\n    this.$$._destroy();\n  }\n\n}\n\nfunction prop(target, propertyKey, descriptor) {\n  if (!target[PROPS]) target[PROPS] = /* @__PURE__ */new Set();\n  target[PROPS].add(propertyKey);\n}\n\nfunction method(target, propertyKey, descriptor) {\n  if (!target[METHODS]) target[METHODS] = /* @__PURE__ */new Set();\n  target[METHODS].add(propertyKey);\n}\n\nclass State {\n  constructor(record) {\n    _defineProperty(this, \"id\", Symbol(\"STATE\"));\n\n    _defineProperty(this, \"record\", void 0);\n\n    _defineProperty(this, \"_descriptors\", void 0);\n\n    this.record = record;\n    this._descriptors = Object.getOwnPropertyDescriptors(record);\n  }\n\n  create() {\n    const store = {},\n          state = new Proxy(store, {\n      get: (_, prop) => store[prop]()\n    });\n\n    for (const name of Object.keys(this.record)) {\n      const getter = this._descriptors[name].get;\n      store[name] = getter ? computed(getter.bind(state)) : signal(this.record[name]);\n    }\n\n    return store;\n  }\n\n  reset(record, filter) {\n    for (const name of Object.keys(record)) {\n      if (!this._descriptors[name].get && (!filter || filter(name))) {\n        record[name].set(this.record[name]);\n      }\n    }\n  }\n\n}\n\nfunction useState(state) {\n  return useContext(state);\n}\n\nfunction runAll(fns, arg) {\n  for (const fn of fns) fn(arg);\n}\n\nfunction camelToKebabCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\nfunction kebabToCamelCase(str) {\n  return str.replace(/-./g, x => x[1].toUpperCase());\n}\n\nfunction uppercaseFirstChar(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction unwrap(fn) {\n  return isFunction(fn) ? fn() : fn;\n}\n\nfunction ariaBool(value) {\n  return value ? \"true\" : \"false\";\n}\n\nfunction createDisposalBin() {\n  const disposal = /* @__PURE__ */new Set();\n  return {\n    add(...callbacks) {\n      for (const callback of callbacks) disposal.add(callback);\n    },\n\n    empty() {\n      for (const callback of disposal) callback();\n\n      disposal.clear();\n    }\n\n  };\n}\n\nfunction useDisposalBin() {\n  const disposal = createDisposalBin();\n  onDispose(disposal.empty);\n  return disposal;\n}\n\nfunction deferredPromise() {\n  let resolve, reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n\nfunction waitTimeout(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay));\n}\n\nfunction animationFrameThrottle(func) {\n  let id = -1,\n      lastArgs;\n\n  function throttle(...args) {\n    lastArgs = args;\n    if (id >= 0) return;\n    id = window.requestAnimationFrame(() => {\n      func.apply(this, lastArgs);\n      id = -1;\n      lastArgs = void 0;\n    });\n  }\n\n  return throttle;\n}\n\nconst requestIdleCallback = typeof window !== \"undefined\" ? \"requestIdleCallback\" in window ? window.requestIdleCallback : cb => window.setTimeout(cb, 1) : noop;\n\nfunction waitIdlePeriod(callback, options) {\n  return new Promise(resolve => {\n    requestIdleCallback(deadline => {\n      callback?.(deadline);\n      resolve();\n    }, options);\n  });\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\n\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\n\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\n\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  } // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n\n\n  return '#document';\n}\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getDocumentElement(node) {\n  var _ref;\n\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\n\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\n\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\n\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\n\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\n\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element); // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n\n  return null;\n}\n\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\n\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  const result = // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot || // DOM Element detected.\n  node.parentNode || // ShadowRoot detected.\n  isShadowRoot(node) && node.host || // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element); // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height; // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\n\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\n\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n} // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\n\n\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n} // Returns the inner client rect, subtracting scrollbars if present.\n\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = { ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n\n  return rectToClientRect(rect);\n}\n\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n} // A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\n\n\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element; // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n\n    currentNode = getParentNode(currentNode);\n  }\n\n  cache.set(element, result);\n  return result;\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  if (polyfill) {\n    return polyfill(element);\n  }\n\n  return element.offsetParent;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n}; // https://samthor.au/2021/observing-dom/\n\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n\n    if (!skip) {\n      onMove();\n    }\n\n    if (!width || !height) {\n      return;\n    }\n\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n\n      isFirstUpdate = false;\n    } // Older browsers don't support a `document` as the root and will throw an\n    // error.\n\n\n    try {\n      io = new IntersectionObserver(handleObserve, { ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n\n    io.observe(element);\n  }\n\n  refresh(true);\n  return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\n\n\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n\n      update();\n    });\n\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n\n    resizeObserver.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\n\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = { ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, { ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nconst STRING = v => v === null ? \"\" : v + \"\";\n\nconst NULLABLE_STRING = v => v === null ? null : v + \"\";\n\nconst NUMBER = v => v === null ? 0 : Number(v);\n\nconst BOOLEAN = v => v !== null;\n\nconst FUNCTION = () => null;\n\nconst ARRAY = v => v === null ? [] : JSON.parse(v);\n\nconst OBJECT = v => v === null ? {} : JSON.parse(v);\n\nfunction inferAttributeConverter(value) {\n  if (value === null) return NULLABLE_STRING;\n\n  switch (typeof value) {\n    case \"undefined\":\n      return STRING;\n\n    case \"string\":\n      return STRING;\n\n    case \"boolean\":\n      return BOOLEAN;\n\n    case \"number\":\n      return NUMBER;\n\n    case \"function\":\n      return FUNCTION;\n\n    case \"object\":\n      return isArray(value) ? ARRAY : OBJECT;\n\n    default:\n      return STRING;\n  }\n}\n\nconst ATTRS = /* @__PURE__ */Symbol(\"ATTRS\");\nconst SETUP = /* @__PURE__ */Symbol(\"SETUP\");\nconst SETUP_STATE = /* @__PURE__ */Symbol(\"SETUP_STATE\");\nconst SETUP_CALLBACKS = /* @__PURE__ */Symbol(\"SETUP_CALLBACKS\");\n\nfunction Host(Super, Component) {\n  class MaverickElement extends Super {\n    static get observedAttributes() {\n      if (!this[ATTRS] && Component.props) {\n        const map = /* @__PURE__ */new Map();\n\n        for (const propName of Object.keys(Component.props)) {\n          let attr = this.attrs?.[propName],\n              attrName = isString(attr) ? attr : !attr ? attr : attr?.attr;\n          if (attrName === false) continue;\n          if (!attrName) attrName = camelToKebabCase(propName);\n          map.set(attrName, {\n            _prop: propName,\n            _converter: attr && !isString(attr) && attr?.converter || inferAttributeConverter(Component.props[propName])\n          });\n        }\n\n        this[ATTRS] = map;\n      }\n\n      return this[ATTRS] ? Array.from(this[ATTRS].keys()) : [];\n    }\n\n    get scope() {\n      return this.$.$$._scope;\n    }\n\n    get attachScope() {\n      return this.$.$$._attachScope;\n    }\n\n    get connectScope() {\n      return this.$.$$._connectScope;\n    }\n\n    get $props() {\n      return this.$.$$._props;\n    }\n\n    get $state() {\n      return this.$.$$._$state;\n    }\n\n    get state() {\n      return this.$.state;\n    }\n\n    constructor(...args) {\n      super(...args);\n\n      _defineProperty(this, \"$\", void 0);\n\n      _defineProperty(this, SETUP_STATE, 0\n      /* Idle */\n      );\n\n      _defineProperty(this, SETUP_CALLBACKS, null);\n\n      _defineProperty(this, \"keepAlive\", false);\n\n      _defineProperty(this, \"forwardKeepAlive\", true);\n\n      this.$ = scoped(() => createComponent(Component), null);\n\n      this.$.$$._addHooks(this);\n\n      if (Component.props) {\n        const props = this.$props,\n              descriptors = Object.getOwnPropertyDescriptors(this);\n\n        for (const prop of Object.keys(descriptors)) {\n          if (prop in Component.props) {\n            props[prop].set(this[prop]);\n            delete this[prop];\n          }\n        }\n      }\n    }\n\n    attributeChangedCallback(name, _, newValue) {\n      const Ctor = this.constructor;\n\n      if (!Ctor[ATTRS]) {\n        super.attributeChangedCallback?.(name, _, newValue);\n        return;\n      }\n\n      const def = Ctor[ATTRS].get(name);\n      if (def) this[def._prop] = def._converter(newValue);\n    }\n\n    connectedCallback() {\n      const instance = this.$?.$$;\n      if (!instance || instance._destroyed) return;\n\n      if (this[SETUP_STATE] !== 2\n      /* Ready */\n      ) {\n        setup.call(this);\n        return;\n      }\n\n      if (!this.isConnected) return;\n\n      if (this.hasAttribute(\"keep-alive\")) {\n        this.keepAlive = true;\n      }\n\n      instance._connect();\n\n      if (isArray(this[SETUP_CALLBACKS])) runAll(this[SETUP_CALLBACKS], this);\n      this[SETUP_CALLBACKS] = null;\n      const callback = super.connectedCallback;\n      if (callback) scoped(() => callback.call(this), this.connectScope);\n      return;\n    }\n\n    disconnectedCallback() {\n      const instance = this.$?.$$;\n      if (!instance || instance._destroyed) return;\n\n      instance._disconnect();\n\n      const callback = super.disconnectedCallback;\n      if (callback) callback.call(this);\n\n      if (!this.keepAlive && !this.hasAttribute(\"keep-alive\")) {\n        requestAnimationFrame(() => {\n          if (!this.isConnected) instance._destroy();\n        });\n      }\n    }\n\n    [SETUP]() {\n      const instance = this.$.$$,\n            Ctor = this.constructor;\n\n      if (instance._destroyed) {\n        console.warn(`[maverick] attempted attaching to destroyed element \\`${this.tagName}\\``);\n      }\n\n      if (instance._destroyed) return;\n      const attrs = Ctor[ATTRS];\n\n      if (attrs) {\n        for (const attr of this.attributes) {\n          let def = attrs.get(attr.name);\n\n          if (def && def._converter) {\n            instance._props[def._prop].set(def._converter(this.getAttribute(attr.name)));\n          }\n        }\n      }\n\n      instance._setup();\n\n      instance._attach(this);\n\n      this[SETUP_STATE] = 2\n      /* Ready */\n      ;\n      this.connectedCallback();\n    } // @ts-expect-error\n\n\n    subscribe(callback) {\n      return this.$.subscribe(callback);\n    }\n\n    destroy() {\n      this.disconnectedCallback();\n      this.$.destroy();\n    }\n\n  }\n\n  _defineProperty(MaverickElement, \"attrs\", void 0);\n\n  _defineProperty(MaverickElement, ATTRS, null);\n\n  extendProto(MaverickElement, Component);\n  return MaverickElement;\n}\n\nfunction extendProto(Element, Component) {\n  const ElementProto = Element.prototype,\n        ComponentProto = Component.prototype;\n\n  if (Component.props) {\n    for (const prop of Object.keys(Component.props)) {\n      Object.defineProperty(ElementProto, prop, {\n        enumerable: true,\n        configurable: true,\n\n        get() {\n          return this.$props[prop]();\n        },\n\n        set(value) {\n          this.$props[prop].set(value);\n        }\n\n      });\n    }\n  }\n\n  if (ComponentProto[PROPS]) {\n    for (const name of ComponentProto[PROPS]) {\n      Object.defineProperty(ElementProto, name, {\n        enumerable: true,\n        configurable: true,\n\n        get() {\n          return this.$[name];\n        },\n\n        set(value) {\n          this.$[name] = value;\n        }\n\n      });\n    }\n  }\n\n  if (ComponentProto[METHODS]) {\n    for (const name of ComponentProto[METHODS]) {\n      ElementProto[name] = function (...args) {\n        return this.$[name](...args);\n      };\n    }\n  }\n}\n\nfunction setup() {\n  if (this[SETUP_STATE] !== 0\n  /* Idle */\n  ) return;\n  this[SETUP_STATE] = 1\n  /* Pending */\n  ;\n  const parent = findParent(this),\n        isParentRegistered = parent && window.customElements.get(parent.localName),\n        isParentSetup = parent && parent[SETUP_STATE] === 2\n  /* Ready */\n  ;\n\n  if (parent && (!isParentRegistered || !isParentSetup)) {\n    waitForParent.call(this, parent);\n    return;\n  }\n\n  attach.call(this, parent);\n}\n\nasync function waitForParent(parent) {\n  await window.customElements.whenDefined(parent.localName);\n\n  if (parent[SETUP_STATE] !== 2\n  /* Ready */\n  ) {\n    await new Promise(res => (parent[SETUP_CALLBACKS] ??= []).push(res));\n  }\n\n  attach.call(this, parent);\n}\n\nfunction attach(parent) {\n  if (!this.isConnected) return;\n\n  if (parent) {\n    if (parent.keepAlive && parent.forwardKeepAlive) {\n      this.keepAlive = true;\n      this.setAttribute(\"keep-alive\", \"\");\n    }\n\n    const scope = this.$.$$._scope;\n    if (scope) parent.$.$$._attachScope.append(scope);\n  }\n\n  this[SETUP]();\n}\n\nfunction findParent(host) {\n  let node = host.parentNode,\n      prefix = host.localName.split(\"-\", 1)[0] + \"-\";\n\n  while (node) {\n    if (node.nodeType === 1 && node.localName.startsWith(prefix)) {\n      return node;\n    }\n\n    node = node.parentNode;\n  }\n\n  return null;\n}\n\nfunction defineCustomElement(element, throws = false) {\n  if (throws || !window.customElements.get(element.tagName)) {\n    window.customElements.define(element.tagName, element);\n  }\n}\n\nexport { ariaBool as $, isNumber as A, useDisposalBin as B, Component as C, DOMEvent as D, isNil as E, createScope as F, isNull as G, Host as H, deferredPromise as I, EventsTarget as J, waitTimeout as K, animationFrameThrottle as L, unwrap as M, BOOLEAN as N, isArray as O, tick as P, createContext as Q, root as R, State as S, kebabToCamelCase as T, waitIdlePeriod as U, ViewController as V, provideContext as W, uppercaseFirstChar as X, prop as Y, method as Z, noop as _, setStyle as a, isWriteSignal as a0, hasProvidedContext as a1, isMouseEvent as a2, isTouchEvent as a3, createDisposalBin as a4, autoUpdate as b, computePosition as c, defineCustomElement as d, effect as e, setAttribute as f, getScope as g, signal as h, isKeyboardClick as i, computed as j, isString as k, listenEvent as l, hasTriggerEvent as m, findTriggerEvent as n, onDispose as o, peek as p, appendTriggerEvent as q, isPointerEvent as r, scoped as s, isKeyboardEvent as t, useState as u, useContext as v, walkTriggerEventChain as w, camelToKebabCase as x, isUndefined as y, isFunction as z };","map":{"version":3,"sources":["/home/ann/dev/studip/54/public/plugins_packages/RasmusFuhse/LernmodulePlugin/vue/node_modules/vidstack/dist/dev/chunks/vidstack-b8ba7e3c.js"],"names":["SCOPE","Symbol","scheduledEffects","runningEffects","currentScope","currentObserver","currentObservers","currentObserversIndex","effects","defaultContext","NOOP","STATE_CLEAN","STATE_CHECK","STATE_DIRTY","STATE_DISPOSED","flushEffects","queueMicrotask","runEffects","length","i","_state","runTop","node","ancestors","_effect","push","updateCheck","root","init","scope","createScope","compute","bind","dispose","peek","fn","untrack","tick","getScope","scoped","run","error","handleError","getContext","key","_context","setContext","value","onDispose","disposable","_disposal","Array","isArray","removeDispose","call","isFunction$1","splice","indexOf","self","head","_prevSibling","current","_nextSibling","next","disposeNode","emptyDisposal","_sources","removeSourceObservers","_observers","_handlers","callable","compute2","observer","prevScope","prevObserver","len","coercedError","coerceError","error2","Error","JSON","stringify","read","_value","_compute","write","newValue","_changed","notify","ScopeNode","Scope","append","ScopeProto","prototype","child","tail","ComputeNode","Computation","initialValue","options","_init","id","dirty","ComputeProto","Object","setPrototypeOf","isNotEqual","createComputation","a","b","update","cleanup","prevObservers","prevObserversIndex","result","source","console","state","index","swap","pop","noop","args","isNull","isUndefined","isNil","isNumber","Number","isNaN","isString","isFunction","EVENT","Event","DOM_EVENT","DOMEvent","originEvent","getOriginEvent","isOriginTrusted","isTrusted","constructor","type","detail","trigger","isDOMEvent","event","walkTriggerEventChain","callback","returnValue","findTriggerEvent","e","hasTriggerEvent","appendTriggerEvent","origin","warn","defineProperty","configurable","enumerable","get","EventsTarget","EventTarget","addEventListener","removeEventListener","listenEvent","target","handler","isPointerEvent","startsWith","isTouchEvent","isMouseEvent","test","isKeyboardEvent","isKeyboardClick","setAttribute","host","name","removeAttribute","attrValue","getAttribute","setStyle","property","style","removeProperty","setProperty","signal","signal2","set","isReadSignal","computed","initial","effect$1","effect2","runEffect","effectResult","stopEffect","isWriteSignal","effect","createContext","provide","provideContext","context","hasProvidedValue","useContext","hasProvidedContext","PROPS","METHODS","ON_DISPATCH","EMPTY_PROPS","Instance","Component","_scope","stateFactory","props","_$state","create","Proxy","_","prop","_props","createInstanceProps","keys","_destroy","_setup","_setupCallbacks","_attach","el","_el","$el","$$COMPONENT_NAME","_component","_attachScope","_attachCallbacks","_attachAttrs","_attachStyles","dispatchEvent","_detach","_connectScope","_connect","_connectCallbacks","_disconnect","_destroyed","_destroyCallbacks","_attrs","_styles","$","_addHooks","onSetup","onAttach","onConnect","onDestroy","_setAttr","_setStyle","$props","def","currentInstance","$$","createComponent","component","ViewController","attachScope","connectScope","$state","attach","listen","setAttributes","attributes","assign","setStyles","styles","setCSSVars","vars","createEvent","dispatch","subscribe","destroy","propertyKey","descriptor","Set","add","method","State","record","_descriptors","getOwnPropertyDescriptors","store","getter","reset","filter","useState","runAll","fns","arg","camelToKebabCase","str","replace","toLowerCase","kebabToCamelCase","x","toUpperCase","uppercaseFirstChar","charAt","slice","unwrap","ariaBool","createDisposalBin","disposal","callbacks","empty","clear","useDisposalBin","deferredPromise","resolve","reject","promise","Promise","res","rej","waitTimeout","delay","setTimeout","animationFrameThrottle","func","lastArgs","throttle","window","requestAnimationFrame","apply","requestIdleCallback","cb","waitIdlePeriod","deadline","min","Math","max","round","floor","createCoords","v","y","getSide","placement","split","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","includes","getAlignmentAxis","rectToClientRect","rect","top","left","right","width","bottom","height","computeCoordsFromPlacement","_ref","rtl","reference","floating","sideAxis","alignmentAxis","alignLength","side","isVertical","commonX","commonY","commonAlign","coords","computePosition$1","config","strategy","middleware","platform","validMiddleware","Boolean","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","nextX","nextY","data","initialPlacement","elements","getNodeName","isNode","nodeName","getWindow","_node$ownerDocument","ownerDocument","defaultView","getDocumentElement","document","documentElement","Node","isElement","Element","isHTMLElement","HTMLElement","isShadowRoot","ShadowRoot","isOverflowElement","element","overflow","overflowX","overflowY","display","getComputedStyle","isTableElement","isContainingBlock","webkit","isWebKit","css","transform","perspective","containerType","backdropFilter","some","willChange","contain","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","CSS","supports","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","assignedSlot","parentNode","getNearestOverflowAncestor","body","getOverflowAncestors","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","concat","visualViewport","frameElement","getCssDimensions","parseFloat","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","contextElement","getScale","domElement","getBoundingClientRect","isFinite","noOffsets","getVisualOffsets","offsetLeft","offsetTop","shouldAddVisualOffsets","isFixed","floatingOffsetParent","includeScale","isFixedStrategy","offsetParent","clientRect","scale","visualOffsets","offsetWin","currentIFrame","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","convertOffsetParentRelativeRectToViewportRelativeRect","isOffsetParentAnElement","scroll","offsets","offsetRect","getClientRects","from","getWindowScrollBarX","getDocumentRect","html","scrollWidth","clientWidth","scrollHeight","clientHeight","direction","getViewportRect","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","position","getClippingElementAncestors","cache","cachedResult","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","shouldDropCurrentNode","ancestor","getClippingRect","boundary","rootBoundary","elementClippingAncestors","_c","clippingAncestors","firstClippingAncestor","clippingRect","reduce","accRect","getDimensions","getRectRelativeToOffsetParent","getTrueOffsetParent","polyfill","getOffsetParent","getOffsetParentFn","getDimensionsFn","observeMove","onMove","io","timeoutId","clearTimeout","disconnect","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","rootMargin","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","IntersectionObserver","observe","autoUpdate","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","animationFrame","referenceEl","forEach","passive","cleanupIo","reobserveFrame","resizeObserver","firstEntry","unobserve","cancelAnimationFrame","frameId","prevRefRect","frameLoop","nextRefRect","computePosition","Map","mergedOptions","platformWithCache","STRING","NULLABLE_STRING","NUMBER","BOOLEAN","FUNCTION","ARRAY","parse","OBJECT","inferAttributeConverter","ATTRS","SETUP","SETUP_STATE","SETUP_CALLBACKS","Host","Super","MaverickElement","observedAttributes","map","propName","attr","attrs","attrName","_prop","_converter","converter","descriptors","attributeChangedCallback","Ctor","connectedCallback","instance","setup","isConnected","hasAttribute","keepAlive","disconnectedCallback","tagName","extendProto","ElementProto","ComponentProto","parent","findParent","isParentRegistered","customElements","localName","isParentSetup","waitForParent","whenDefined","forwardKeepAlive","prefix","nodeType","defineCustomElement","throws","define","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a0","a1","a2","a3","a4","c","d","f","g","h","j","k","l","m","n","o","p","q","r","s","t","u","w","z"],"mappings":"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","sourcesContent":["const SCOPE = Symbol(\"SCOPE\" );\n\nlet scheduledEffects = false, runningEffects = false, currentScope = null, currentObserver = null, currentObservers = null, currentObserversIndex = 0, effects = [], defaultContext = {};\nconst NOOP = () => {\n}, STATE_CLEAN = 0, STATE_CHECK = 1, STATE_DIRTY = 2, STATE_DISPOSED = 3;\nfunction flushEffects() {\n  scheduledEffects = true;\n  queueMicrotask(runEffects);\n}\nfunction runEffects() {\n  if (!effects.length) {\n    scheduledEffects = false;\n    return;\n  }\n  runningEffects = true;\n  for (let i = 0; i < effects.length; i++) {\n    if (effects[i]._state !== STATE_CLEAN)\n      runTop(effects[i]);\n  }\n  effects = [];\n  scheduledEffects = false;\n  runningEffects = false;\n}\nfunction runTop(node) {\n  let ancestors = [node];\n  while (node = node[SCOPE]) {\n    if (node._effect && node._state !== STATE_CLEAN)\n      ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    updateCheck(ancestors[i]);\n  }\n}\nfunction root(init) {\n  const scope = createScope();\n  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);\n}\nfunction peek(fn) {\n  return compute(currentScope, fn, null);\n}\nfunction untrack(fn) {\n  return compute(null, fn, null);\n}\nfunction tick() {\n  if (!runningEffects)\n    runEffects();\n}\nfunction getScope() {\n  return currentScope;\n}\nfunction scoped(run, scope) {\n  try {\n    return compute(scope, run, null);\n  } catch (error) {\n    handleError(scope, error);\n    return;\n  }\n}\nfunction getContext(key, scope = currentScope) {\n  return scope?._context[key];\n}\nfunction setContext(key, value, scope = currentScope) {\n  if (scope)\n    scope._context = { ...scope._context, [key]: value };\n}\nfunction onDispose(disposable) {\n  if (!disposable || !currentScope)\n    return disposable || NOOP;\n  const node = currentScope;\n  if (!node._disposal) {\n    node._disposal = disposable;\n  } else if (Array.isArray(node._disposal)) {\n    node._disposal.push(disposable);\n  } else {\n    node._disposal = [node._disposal, disposable];\n  }\n  return function removeDispose() {\n    if (node._state === STATE_DISPOSED)\n      return;\n    disposable.call(null);\n    if (isFunction$1(node._disposal)) {\n      node._disposal = null;\n    } else if (Array.isArray(node._disposal)) {\n      node._disposal.splice(node._disposal.indexOf(disposable), 1);\n    }\n  };\n}\nfunction dispose(self = true) {\n  if (this._state === STATE_DISPOSED)\n    return;\n  let head = self ? this._prevSibling || this[SCOPE] : this, current = this._nextSibling, next = null;\n  while (current && current[SCOPE] === this) {\n    dispose.call(current, true);\n    disposeNode(current);\n    next = current._nextSibling;\n    current._nextSibling = null;\n    current = next;\n  }\n  if (self)\n    disposeNode(this);\n  if (current)\n    current._prevSibling = !self ? this : this._prevSibling;\n  if (head)\n    head._nextSibling = current;\n}\nfunction disposeNode(node) {\n  node._state = STATE_DISPOSED;\n  if (node._disposal)\n    emptyDisposal(node);\n  if (node._sources)\n    removeSourceObservers(node, 0);\n  if (node._prevSibling)\n    node._prevSibling._nextSibling = null;\n  node[SCOPE] = null;\n  node._sources = null;\n  node._observers = null;\n  node._prevSibling = null;\n  node._context = defaultContext;\n  node._handlers = null;\n}\nfunction emptyDisposal(scope) {\n  try {\n    if (Array.isArray(scope._disposal)) {\n      for (let i = scope._disposal.length - 1; i >= 0; i--) {\n        const callable = scope._disposal[i];\n        callable.call(callable);\n      }\n    } else {\n      scope._disposal.call(scope._disposal);\n    }\n    scope._disposal = null;\n  } catch (error) {\n    handleError(scope, error);\n  }\n}\nfunction compute(scope, compute2, observer) {\n  const prevScope = currentScope, prevObserver = currentObserver;\n  currentScope = scope;\n  currentObserver = observer;\n  try {\n    return compute2.call(scope);\n  } finally {\n    currentScope = prevScope;\n    currentObserver = prevObserver;\n  }\n}\nfunction handleError(scope, error) {\n  if (!scope || !scope._handlers)\n    throw error;\n  let i = 0, len = scope._handlers.length, coercedError = coerceError(error);\n  for (i = 0; i < len; i++) {\n    try {\n      scope._handlers[i](coercedError);\n      break;\n    } catch (error2) {\n      coercedError = coerceError(error2);\n    }\n  }\n  if (i === len)\n    throw coercedError;\n}\nfunction coerceError(error) {\n  return error instanceof Error ? error : Error(JSON.stringify(error));\n}\nfunction read() {\n  if (this._state === STATE_DISPOSED)\n    return this._value;\n  if (currentObserver && !this._effect) {\n    if (!currentObservers && currentObserver._sources && currentObserver._sources[currentObserversIndex] == this) {\n      currentObserversIndex++;\n    } else if (!currentObservers)\n      currentObservers = [this];\n    else\n      currentObservers.push(this);\n  }\n  if (this._compute)\n    updateCheck(this);\n  return this._value;\n}\nfunction write(newValue) {\n  const value = isFunction$1(newValue) ? newValue(this._value) : newValue;\n  if (this._changed(this._value, value)) {\n    this._value = value;\n    if (this._observers) {\n      for (let i = 0; i < this._observers.length; i++) {\n        notify(this._observers[i], STATE_DIRTY);\n      }\n    }\n  }\n  return this._value;\n}\nconst ScopeNode = function Scope() {\n  this[SCOPE] = null;\n  this._nextSibling = null;\n  this._prevSibling = null;\n  if (currentScope)\n    currentScope.append(this);\n};\nconst ScopeProto = ScopeNode.prototype;\nScopeProto._context = defaultContext;\nScopeProto._handlers = null;\nScopeProto._compute = null;\nScopeProto._disposal = null;\nScopeProto.append = function(child) {\n  child[SCOPE] = this;\n  child._prevSibling = this;\n  if (this._nextSibling) {\n    if (child._nextSibling) {\n      let tail = child._nextSibling;\n      while (tail._nextSibling)\n        tail = tail._nextSibling;\n      tail._nextSibling = this._nextSibling;\n      this._nextSibling._prevSibling = tail;\n    } else {\n      child._nextSibling = this._nextSibling;\n      this._nextSibling._prevSibling = child;\n    }\n  }\n  this._nextSibling = child;\n  child._context = child._context === defaultContext ? this._context : { ...this._context, ...child._context };\n  if (this._handlers) {\n    child._handlers = !child._handlers ? this._handlers : [...child._handlers, ...this._handlers];\n  }\n};\nScopeProto.dispose = function() {\n  dispose.call(this);\n};\nfunction createScope() {\n  return new ScopeNode();\n}\nconst ComputeNode = function Computation(initialValue, compute2, options) {\n  ScopeNode.call(this);\n  this._state = compute2 ? STATE_DIRTY : STATE_CLEAN;\n  this._init = false;\n  this._effect = false;\n  this._sources = null;\n  this._observers = null;\n  this._value = initialValue;\n  this.id = options?.id ?? (this._compute ? \"computed\" : \"signal\");\n  if (compute2)\n    this._compute = compute2;\n  if (options && options.dirty)\n    this._changed = options.dirty;\n};\nconst ComputeProto = ComputeNode.prototype;\nObject.setPrototypeOf(ComputeProto, ScopeProto);\nComputeProto._changed = isNotEqual;\nComputeProto.call = read;\nfunction createComputation(initialValue, compute2, options) {\n  return new ComputeNode(initialValue, compute2, options);\n}\nfunction isNotEqual(a, b) {\n  return a !== b;\n}\nfunction isFunction$1(value) {\n  return typeof value === \"function\";\n}\nfunction updateCheck(node) {\n  if (node._state === STATE_CHECK) {\n    for (let i = 0; i < node._sources.length; i++) {\n      updateCheck(node._sources[i]);\n      if (node._state === STATE_DIRTY) {\n        break;\n      }\n    }\n  }\n  if (node._state === STATE_DIRTY)\n    update(node);\n  else\n    node._state = STATE_CLEAN;\n}\nfunction cleanup(node) {\n  if (node._nextSibling && node._nextSibling[SCOPE] === node)\n    dispose.call(node, false);\n  if (node._disposal)\n    emptyDisposal(node);\n  node._handlers = node[SCOPE] ? node[SCOPE]._handlers : null;\n}\nfunction update(node) {\n  let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;\n  currentObservers = null;\n  currentObserversIndex = 0;\n  try {\n    cleanup(node);\n    const result = compute(node, node._compute, node);\n    if (currentObservers) {\n      if (node._sources)\n        removeSourceObservers(node, currentObserversIndex);\n      if (node._sources && currentObserversIndex > 0) {\n        node._sources.length = currentObserversIndex + currentObservers.length;\n        for (let i = 0; i < currentObservers.length; i++) {\n          node._sources[currentObserversIndex + i] = currentObservers[i];\n        }\n      } else {\n        node._sources = currentObservers;\n      }\n      let source;\n      for (let i = currentObserversIndex; i < node._sources.length; i++) {\n        source = node._sources[i];\n        if (!source._observers)\n          source._observers = [node];\n        else\n          source._observers.push(node);\n      }\n    } else if (node._sources && currentObserversIndex < node._sources.length) {\n      removeSourceObservers(node, currentObserversIndex);\n      node._sources.length = currentObserversIndex;\n    }\n    if (!node._effect && node._init) {\n      write.call(node, result);\n    } else {\n      node._value = result;\n      node._init = true;\n    }\n  } catch (error) {\n    if (!node._init && typeof node._value === \"undefined\") {\n      console.error(\n        `computed \\`${node.id}\\` threw error during first run, this can be fatal.\n\nSolutions:\n\n1. Set the \\`initial\\` option to silence this error`,\n        \"\\n2. Or, use an `effect` if the return value is not being used\",\n        \"\\n\\n\",\n        error\n      );\n    }\n    handleError(node, error);\n    if (node._state === STATE_DIRTY) {\n      cleanup(node);\n      if (node._sources)\n        removeSourceObservers(node, 0);\n    }\n    return;\n  }\n  currentObservers = prevObservers;\n  currentObserversIndex = prevObserversIndex;\n  node._state = STATE_CLEAN;\n}\nfunction notify(node, state) {\n  if (node._state >= state)\n    return;\n  if (node._effect && node._state === STATE_CLEAN) {\n    effects.push(node);\n    if (!scheduledEffects)\n      flushEffects();\n  }\n  node._state = state;\n  if (node._observers) {\n    for (let i = 0; i < node._observers.length; i++) {\n      notify(node._observers[i], STATE_CHECK);\n    }\n  }\n}\nfunction removeSourceObservers(node, index) {\n  let source, swap;\n  for (let i = index; i < node._sources.length; i++) {\n    source = node._sources[i];\n    if (source._observers) {\n      swap = source._observers.indexOf(node);\n      source._observers[swap] = source._observers[source._observers.length - 1];\n      source._observers.pop();\n    }\n  }\n}\n\nfunction noop(...args) {\n}\nfunction isNull(value) {\n  return value === null;\n}\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\nfunction isNil(value) {\n  return isNull(value) || isUndefined(value);\n}\nfunction isNumber(value) {\n  return typeof value === \"number\" && !Number.isNaN(value);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\nconst EVENT = Event, DOM_EVENT = Symbol(\"DOM_EVENT\");\nclass DOMEvent extends EVENT {\n  [DOM_EVENT] = true;\n  /**\n   * The event detail.\n   */\n  detail;\n  /**\n   * The preceding event that was responsible for this event being fired.\n   */\n  trigger;\n  /**\n   * Walks up the event chain (following each `trigger`) and returns the origin event\n   * that started the chain.\n   */\n  get originEvent() {\n    return getOriginEvent(this) ?? this;\n  }\n  /**\n   * Walks up the event chain (following each `trigger`) and determines whether the initial\n   * event was triggered by the end user (ie: check whether `isTrusted` on the `originEvent` `true`).\n   */\n  get isOriginTrusted() {\n    return getOriginEvent(this)?.isTrusted ?? false;\n  }\n  constructor(type, ...init) {\n    super(type, init[0]);\n    this.detail = init[0]?.detail;\n    this.trigger = init[0]?.trigger;\n  }\n}\nfunction isDOMEvent(event) {\n  return !!event?.[DOM_EVENT];\n}\nfunction getOriginEvent(event) {\n  let trigger = event.trigger;\n  while (trigger && trigger.trigger) {\n    trigger = trigger.trigger;\n  }\n  return trigger;\n}\nfunction walkTriggerEventChain(event, callback) {\n  if (!isDOMEvent(event))\n    return;\n  let trigger = event.trigger;\n  while (trigger) {\n    const returnValue = callback(trigger);\n    if (returnValue)\n      return [trigger, returnValue];\n    trigger = trigger.trigger;\n  }\n  return;\n}\nfunction findTriggerEvent(event, type) {\n  return walkTriggerEventChain(event, (e) => e.type === type)?.[0];\n}\nfunction hasTriggerEvent(event, type) {\n  return !!findTriggerEvent(event, type);\n}\nfunction appendTriggerEvent(event, trigger) {\n  const origin = getOriginEvent(event) ?? event;\n  if (origin === trigger) {\n    throw Error(\n      \"[maverick] attemping to append event as a trigger on itself (cyclic)\" \n    );\n  }\n  if (typeof origin.trigger !== \"undefined\") {\n    console.warn(\n      `[maverick] overwriting existing trigger event: \\`${origin.trigger.type}\\` -> \\`${trigger?.type}\\`\n\n`,\n      \"Event:\\n\",\n      event,\n      \"Origin Event:\\n\",\n      origin,\n      \"Trigger Event:\\n\",\n      trigger\n    );\n  }\n  Object.defineProperty(origin, \"trigger\", {\n    configurable: true,\n    enumerable: true,\n    get: () => trigger\n  });\n}\nclass EventsTarget extends EventTarget {\n  /** @internal type only */\n  $ts__events;\n  addEventListener(type, callback, options) {\n    return super.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    return super.removeEventListener(type, callback, options);\n  }\n}\nfunction listenEvent(target, type, handler, options) {\n  target.addEventListener(type, handler, options);\n  return onDispose(() => target.removeEventListener(type, handler, options));\n}\nfunction isPointerEvent(event) {\n  return !!event?.type.startsWith(\"pointer\");\n}\nfunction isTouchEvent(event) {\n  return !!event?.type.startsWith(\"touch\");\n}\nfunction isMouseEvent(event) {\n  return /^(click|mouse)/.test(event?.type ?? \"\");\n}\nfunction isKeyboardEvent(event) {\n  return !!event?.type.startsWith(\"key\");\n}\nfunction isKeyboardClick(event) {\n  return isKeyboardEvent(event) && (event.key === \"Enter\" || event.key === \" \");\n}\nfunction setAttribute(host, name, value) {\n  if (!host)\n    return;\n  else if (!value && value !== \"\" && value !== 0) {\n    host.removeAttribute(name);\n  } else {\n    const attrValue = value === true ? \"\" : value + \"\";\n    if (host.getAttribute(name) !== attrValue) {\n      host.setAttribute(name, attrValue);\n    }\n  }\n}\nfunction setStyle(host, property, value) {\n  if (!host)\n    return;\n  else if (!value && value !== 0) {\n    host.style.removeProperty(property);\n  } else {\n    host.style.setProperty(property, value + \"\");\n  }\n}\n\nfunction signal(initialValue, options) {\n  const node = createComputation(initialValue, null, options), signal2 = read.bind(node);\n  signal2.node = node;\n  signal2[SCOPE] = true;\n  signal2.set = write.bind(node);\n  return signal2;\n}\nfunction isReadSignal(fn) {\n  return isFunction$1(fn) && SCOPE in fn;\n}\nfunction computed(compute, options) {\n  const node = createComputation(\n    options?.initial,\n    compute,\n    options\n  ), signal2 = read.bind(node);\n  signal2[SCOPE] = true;\n  signal2.node = node;\n  return signal2;\n}\nfunction effect$1(effect2, options) {\n  const signal2 = createComputation(\n    null,\n    function runEffect() {\n      let effectResult = effect2();\n      isFunction$1(effectResult) && onDispose(effectResult);\n      return null;\n    },\n    { id: options?.id ?? \"effect\" } \n  );\n  signal2._effect = true;\n  update(signal2);\n  {\n    return function stopEffect() {\n      dispose.call(signal2, true);\n    };\n  }\n}\nfunction isWriteSignal(fn) {\n  return isReadSignal(fn) && \"set\" in fn;\n}\n\nconst effect = effect$1;\n\nfunction createContext(provide) {\n  return { id: Symbol(), provide };\n}\nfunction provideContext(context, value, scope = getScope()) {\n  if (!scope) {\n    throw Error(\"[maverick] attempting to provide context outside root\");\n  }\n  const hasProvidedValue = !isUndefined(value);\n  if (!hasProvidedValue && !context.provide) {\n    throw Error(\"[maverick] context can not be provided without a value or `provide` function\");\n  }\n  setContext(context.id, hasProvidedValue ? value : context.provide?.(), scope);\n}\nfunction useContext(context) {\n  const value = getContext(context.id);\n  if (isUndefined(value)) {\n    throw Error(\"[maverick] attempting to use context without providing first\");\n  }\n  return value;\n}\nfunction hasProvidedContext(context) {\n  return !isUndefined(getContext(context.id));\n}\n\nconst PROPS = /* @__PURE__ */ Symbol(\"PROPS\" );\nconst METHODS = /* @__PURE__ */ Symbol(\"METHODS\" );\nconst ON_DISPATCH = /* @__PURE__ */ Symbol(\"ON_DISPATCH\" );\n\nconst EMPTY_PROPS = {};\nclass Instance {\n  /** @internal type only */\n  $ts__events;\n  /** @internal type only */\n  $ts__vars;\n  /* @internal */\n  [ON_DISPATCH] = null;\n  $el = signal(null);\n  _el = null;\n  _scope = null;\n  _attachScope = null;\n  _connectScope = null;\n  _component = null;\n  _destroyed = false;\n  _props = EMPTY_PROPS;\n  _attrs = null;\n  _styles = null;\n  _state;\n  _$state;\n  _setupCallbacks = [];\n  _attachCallbacks = [];\n  _connectCallbacks = [];\n  _destroyCallbacks = [];\n  constructor(Component, scope, init) {\n    this._scope = scope;\n    if (init?.scope)\n      init.scope.append(scope);\n    let stateFactory = Component.state, props = Component.props;\n    if (stateFactory) {\n      this._$state = stateFactory.create();\n      this._state = new Proxy(this._$state, {\n        get: (_, prop) => this._$state[prop]()\n      });\n      provideContext(stateFactory, this._$state);\n    }\n    if (props) {\n      this._props = createInstanceProps(props);\n      if (init?.props) {\n        for (const prop of Object.keys(init.props)) {\n          this._props[prop]?.set(init.props[prop]);\n        }\n      }\n    }\n    onDispose(this._destroy.bind(this));\n  }\n  _setup() {\n    scoped(() => {\n      for (const callback of this._setupCallbacks)\n        callback();\n    }, this._scope);\n  }\n  _attach(el) {\n    if (this._el)\n      return;\n    this._el = el;\n    this.$el.set(el);\n    {\n      el.$$COMPONENT_NAME = this._component?.constructor.name;\n    }\n    scoped(() => {\n      this._attachScope = createScope();\n      scoped(() => {\n        for (const callback of this._attachCallbacks)\n          callback(this._el);\n        this._attachAttrs();\n        this._attachStyles();\n      }, this._attachScope);\n    }, this._scope);\n    el.dispatchEvent(new Event(\"attached\"));\n  }\n  _detach() {\n    this._attachScope?.dispose();\n    this._attachScope = null;\n    this._connectScope = null;\n    if (this._el) {\n      this._el.$$COMPONENT_NAME = null;\n    }\n    this._el = null;\n    this.$el.set(null);\n  }\n  _connect() {\n    if (!this._el || !this._attachScope || !this._connectCallbacks.length)\n      return;\n    scoped(() => {\n      this._connectScope = createScope();\n      scoped(() => {\n        for (const callback of this._connectCallbacks)\n          callback(this._el);\n      }, this._connectScope);\n    }, this._attachScope);\n  }\n  _disconnect() {\n    this._connectScope?.dispose();\n    this._connectScope = null;\n  }\n  _destroy() {\n    if (this._destroyed)\n      return;\n    this._destroyed = true;\n    scoped(() => {\n      for (const callback of this._destroyCallbacks)\n        callback(this._el);\n    }, this._scope);\n    const el = this._el;\n    this._detach();\n    this._scope.dispose();\n    this._setupCallbacks.length = 0;\n    this._attachCallbacks.length = 0;\n    this._connectCallbacks.length = 0;\n    this._destroyCallbacks.length = 0;\n    this._component = null;\n    this._attrs = null;\n    this._styles = null;\n    this._props = EMPTY_PROPS;\n    this._scope = null;\n    this._state = EMPTY_PROPS;\n    this._$state = null;\n    if (el)\n      delete el.$;\n  }\n  _addHooks(target) {\n    if (target.onSetup)\n      this._setupCallbacks.push(target.onSetup.bind(target));\n    if (target.onAttach)\n      this._attachCallbacks.push(target.onAttach.bind(target));\n    if (target.onConnect)\n      this._connectCallbacks.push(target.onConnect.bind(target));\n    if (target.onDestroy)\n      this._destroyCallbacks.push(target.onDestroy.bind(target));\n  }\n  _attachAttrs() {\n    if (!this._attrs)\n      return;\n    for (const name of Object.keys(this._attrs)) {\n      if (isFunction(this._attrs[name])) {\n        effect(this._setAttr.bind(this, name));\n      } else {\n        setAttribute(this._el, name, this._attrs[name]);\n      }\n    }\n  }\n  _attachStyles() {\n    if (!this._styles)\n      return;\n    for (const name of Object.keys(this._styles)) {\n      if (isFunction(this._styles[name])) {\n        effect(this._setStyle.bind(this, name));\n      } else {\n        setStyle(this._el, name, this._styles[name]);\n      }\n    }\n  }\n  _setAttr(name) {\n    setAttribute(this._el, name, this._attrs[name].call(this._component));\n  }\n  _setStyle(name) {\n    setStyle(this._el, name, this._styles[name].call(this._component));\n  }\n}\nfunction createInstanceProps(props) {\n  const $props = {};\n  for (const name of Object.keys(props)) {\n    const def = props[name];\n    $props[name] = signal(def, def);\n  }\n  return $props;\n}\n\nlet currentInstance = { $$: null };\nfunction createComponent(Component, init) {\n  return root(() => {\n    currentInstance.$$ = new Instance(Component, getScope(), init);\n    const component = new Component();\n    currentInstance.$$._component = component;\n    currentInstance.$$ = null;\n    return component;\n  });\n}\nclass ViewController extends EventTarget {\n  /** @internal */\n  $$;\n  get el() {\n    return this.$$._el;\n  }\n  get $el() {\n    return this.$$.$el();\n  }\n  get scope() {\n    return this.$$._scope;\n  }\n  get attachScope() {\n    return this.$$._attachScope;\n  }\n  get connectScope() {\n    return this.$$._connectScope;\n  }\n  /** @internal */\n  get $props() {\n    return this.$$._props;\n  }\n  /** @internal */\n  get $state() {\n    return this.$$._$state;\n  }\n  get state() {\n    return this.$$._state;\n  }\n  constructor() {\n    super();\n    if (currentInstance.$$)\n      this.attach(currentInstance);\n  }\n  attach({ $$ }) {\n    this.$$ = $$;\n    $$._addHooks(this);\n    return this;\n  }\n  addEventListener(type, callback, options) {\n    if (!this.el) {\n      const name = this.constructor.name;\n      console.warn(`[maverick] adding event listener to \\`${name}\\` before element is attached`);\n    }\n    this.listen(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    this.el?.removeEventListener(type, callback, options);\n  }\n  /**\n   * This method can be used to specify attributes that should be set on the host element. Any\n   * attributes that are assigned to a function will be considered a signal and updated accordingly.\n   */\n  setAttributes(attributes) {\n    if (!this.$$._attrs)\n      this.$$._attrs = {};\n    Object.assign(this.$$._attrs, attributes);\n  }\n  /**\n   * This method can be used to specify styles that should set be set on the host element. Any\n   * styles that are assigned to a function will be considered a signal and updated accordingly.\n   */\n  setStyles(styles) {\n    if (!this.$$._styles)\n      this.$$._styles = {};\n    Object.assign(this.$$._styles, styles);\n  }\n  /**\n   * This method is used to satisfy the CSS variables contract specified on the current\n   * component. Other CSS variables can be set via the `setStyles` method.\n   */\n  setCSSVars(vars) {\n    this.setStyles(vars);\n  }\n  /**\n   * Type-safe utility for creating component DOM events.\n   */\n  createEvent(type, ...init) {\n    return new DOMEvent(type, init[0]);\n  }\n  /**\n   * Creates a `DOMEvent` and dispatches it from the host element. This method is typed to\n   * match all component events.\n   */\n  dispatch(type, ...init) {\n    if (!this.el)\n      return false;\n    const event = type instanceof Event ? type : new DOMEvent(type, init[0]);\n    Object.defineProperty(event, \"target\", {\n      get: () => this.$$._component\n    });\n    return untrack(() => {\n      this.$$[ON_DISPATCH]?.(event);\n      return this.el.dispatchEvent(event);\n    });\n  }\n  dispatchEvent(event) {\n    return this.dispatch(event);\n  }\n  /**\n   * Adds an event listener for the given `type` and returns a function which can be invoked to\n   * remove the event listener.\n   *\n   * - The listener is removed if the current scope is disposed.\n   * - This method is safe to use on the server (noop).\n   */\n  listen(type, handler, options) {\n    if (!this.el)\n      return noop;\n    return listenEvent(this.el, type, handler, options);\n  }\n}\n\nclass Component extends ViewController {\n  subscribe(callback) {\n    if (!this.state) {\n      const name = this.constructor.name;\n      throw Error(\n        `[maverick] component \\`${name}\\` can not be subscribed to because it has no internal state`\n      );\n    }\n    return scoped(() => effect(() => callback(this.state)), this.$$._scope);\n  }\n  destroy() {\n    this.$$._destroy();\n  }\n}\n\nfunction prop(target, propertyKey, descriptor) {\n  if (!target[PROPS])\n    target[PROPS] = /* @__PURE__ */ new Set();\n  target[PROPS].add(propertyKey);\n}\nfunction method(target, propertyKey, descriptor) {\n  if (!target[METHODS])\n    target[METHODS] = /* @__PURE__ */ new Set();\n  target[METHODS].add(propertyKey);\n}\n\nclass State {\n  id = Symbol(\"STATE\" );\n  record;\n  _descriptors;\n  constructor(record) {\n    this.record = record;\n    this._descriptors = Object.getOwnPropertyDescriptors(record);\n  }\n  create() {\n    const store = {}, state = new Proxy(store, { get: (_, prop) => store[prop]() });\n    for (const name of Object.keys(this.record)) {\n      const getter = this._descriptors[name].get;\n      store[name] = getter ? computed(getter.bind(state)) : signal(this.record[name]);\n    }\n    return store;\n  }\n  reset(record, filter) {\n    for (const name of Object.keys(record)) {\n      if (!this._descriptors[name].get && (!filter || filter(name))) {\n        record[name].set(this.record[name]);\n      }\n    }\n  }\n}\nfunction useState(state) {\n  return useContext(state);\n}\n\nfunction runAll(fns, arg) {\n  for (const fn of fns)\n    fn(arg);\n}\n\nfunction camelToKebabCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction kebabToCamelCase(str) {\n  return str.replace(/-./g, (x) => x[1].toUpperCase());\n}\nfunction uppercaseFirstChar(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction unwrap(fn) {\n  return isFunction(fn) ? fn() : fn;\n}\n\nfunction ariaBool(value) {\n  return value ? \"true\" : \"false\";\n}\n\nfunction createDisposalBin() {\n  const disposal = /* @__PURE__ */ new Set();\n  return {\n    add(...callbacks) {\n      for (const callback of callbacks)\n        disposal.add(callback);\n    },\n    empty() {\n      for (const callback of disposal)\n        callback();\n      disposal.clear();\n    }\n  };\n}\nfunction useDisposalBin() {\n  const disposal = createDisposalBin();\n  onDispose(disposal.empty);\n  return disposal;\n}\n\nfunction deferredPromise() {\n  let resolve, reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n}\n\nfunction waitTimeout(delay) {\n  return new Promise((resolve) => setTimeout(resolve, delay));\n}\nfunction animationFrameThrottle(func) {\n  let id = -1, lastArgs;\n  function throttle(...args) {\n    lastArgs = args;\n    if (id >= 0)\n      return;\n    id = window.requestAnimationFrame(() => {\n      func.apply(this, lastArgs);\n      id = -1;\n      lastArgs = void 0;\n    });\n  }\n  return throttle;\n}\nconst requestIdleCallback = typeof window !== \"undefined\" ? \"requestIdleCallback\" in window ? window.requestIdleCallback : (cb) => window.setTimeout(cb, 1) : noop;\nfunction waitIdlePeriod(callback, options) {\n  return new Promise((resolve) => {\n    requestIdleCallback((deadline) => {\n      callback?.(deadline);\n      resolve();\n    }, options);\n  });\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nconst STRING = (v) => v === null ? \"\" : v + \"\";\nconst NULLABLE_STRING = (v) => v === null ? null : v + \"\";\nconst NUMBER = (v) => v === null ? 0 : Number(v);\nconst BOOLEAN = (v) => v !== null;\nconst FUNCTION = () => null;\nconst ARRAY = (v) => v === null ? [] : JSON.parse(v);\nconst OBJECT = (v) => v === null ? {} : JSON.parse(v);\nfunction inferAttributeConverter(value) {\n  if (value === null)\n    return NULLABLE_STRING;\n  switch (typeof value) {\n    case \"undefined\":\n      return STRING;\n    case \"string\":\n      return STRING;\n    case \"boolean\":\n      return BOOLEAN;\n    case \"number\":\n      return NUMBER;\n    case \"function\":\n      return FUNCTION;\n    case \"object\":\n      return isArray(value) ? ARRAY : OBJECT;\n    default:\n      return STRING;\n  }\n}\n\nconst ATTRS = /* @__PURE__ */ Symbol(\"ATTRS\" );\nconst SETUP = /* @__PURE__ */ Symbol(\"SETUP\" );\nconst SETUP_STATE = /* @__PURE__ */ Symbol(\"SETUP_STATE\" );\nconst SETUP_CALLBACKS = /* @__PURE__ */ Symbol(\"SETUP_CALLBACKS\" );\n\nfunction Host(Super, Component) {\n  class MaverickElement extends Super {\n    static attrs;\n    static [ATTRS] = null;\n    static get observedAttributes() {\n      if (!this[ATTRS] && Component.props) {\n        const map = /* @__PURE__ */ new Map();\n        for (const propName of Object.keys(Component.props)) {\n          let attr = this.attrs?.[propName], attrName = isString(attr) ? attr : !attr ? attr : attr?.attr;\n          if (attrName === false)\n            continue;\n          if (!attrName)\n            attrName = camelToKebabCase(propName);\n          map.set(attrName, {\n            _prop: propName,\n            _converter: attr && !isString(attr) && attr?.converter || inferAttributeConverter(Component.props[propName])\n          });\n        }\n        this[ATTRS] = map;\n      }\n      return this[ATTRS] ? Array.from(this[ATTRS].keys()) : [];\n    }\n    $;\n    [SETUP_STATE] = 0 /* Idle */;\n    [SETUP_CALLBACKS] = null;\n    keepAlive = false;\n    forwardKeepAlive = true;\n    get scope() {\n      return this.$.$$._scope;\n    }\n    get attachScope() {\n      return this.$.$$._attachScope;\n    }\n    get connectScope() {\n      return this.$.$$._connectScope;\n    }\n    get $props() {\n      return this.$.$$._props;\n    }\n    get $state() {\n      return this.$.$$._$state;\n    }\n    get state() {\n      return this.$.state;\n    }\n    constructor(...args) {\n      super(...args);\n      this.$ = scoped(() => createComponent(Component), null);\n      this.$.$$._addHooks(this);\n      if (Component.props) {\n        const props = this.$props, descriptors = Object.getOwnPropertyDescriptors(this);\n        for (const prop of Object.keys(descriptors)) {\n          if (prop in Component.props) {\n            props[prop].set(this[prop]);\n            delete this[prop];\n          }\n        }\n      }\n    }\n    attributeChangedCallback(name, _, newValue) {\n      const Ctor = this.constructor;\n      if (!Ctor[ATTRS]) {\n        super.attributeChangedCallback?.(name, _, newValue);\n        return;\n      }\n      const def = Ctor[ATTRS].get(name);\n      if (def)\n        this[def._prop] = def._converter(newValue);\n    }\n    connectedCallback() {\n      const instance = this.$?.$$;\n      if (!instance || instance._destroyed)\n        return;\n      if (this[SETUP_STATE] !== 2 /* Ready */) {\n        setup.call(this);\n        return;\n      }\n      if (!this.isConnected)\n        return;\n      if (this.hasAttribute(\"keep-alive\")) {\n        this.keepAlive = true;\n      }\n      instance._connect();\n      if (isArray(this[SETUP_CALLBACKS]))\n        runAll(this[SETUP_CALLBACKS], this);\n      this[SETUP_CALLBACKS] = null;\n      const callback = super.connectedCallback;\n      if (callback)\n        scoped(() => callback.call(this), this.connectScope);\n      return;\n    }\n    disconnectedCallback() {\n      const instance = this.$?.$$;\n      if (!instance || instance._destroyed)\n        return;\n      instance._disconnect();\n      const callback = super.disconnectedCallback;\n      if (callback)\n        callback.call(this);\n      if (!this.keepAlive && !this.hasAttribute(\"keep-alive\")) {\n        requestAnimationFrame(() => {\n          if (!this.isConnected)\n            instance._destroy();\n        });\n      }\n    }\n    [SETUP]() {\n      const instance = this.$.$$, Ctor = this.constructor;\n      if (instance._destroyed) {\n        console.warn(`[maverick] attempted attaching to destroyed element \\`${this.tagName}\\``);\n      }\n      if (instance._destroyed)\n        return;\n      const attrs = Ctor[ATTRS];\n      if (attrs) {\n        for (const attr of this.attributes) {\n          let def = attrs.get(attr.name);\n          if (def && def._converter) {\n            instance._props[def._prop].set(def._converter(this.getAttribute(attr.name)));\n          }\n        }\n      }\n      instance._setup();\n      instance._attach(this);\n      this[SETUP_STATE] = 2 /* Ready */;\n      this.connectedCallback();\n    }\n    // @ts-expect-error\n    subscribe(callback) {\n      return this.$.subscribe(callback);\n    }\n    destroy() {\n      this.disconnectedCallback();\n      this.$.destroy();\n    }\n  }\n  extendProto(MaverickElement, Component);\n  return MaverickElement;\n}\nfunction extendProto(Element, Component) {\n  const ElementProto = Element.prototype, ComponentProto = Component.prototype;\n  if (Component.props) {\n    for (const prop of Object.keys(Component.props)) {\n      Object.defineProperty(ElementProto, prop, {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this.$props[prop]();\n        },\n        set(value) {\n          this.$props[prop].set(value);\n        }\n      });\n    }\n  }\n  if (ComponentProto[PROPS]) {\n    for (const name of ComponentProto[PROPS]) {\n      Object.defineProperty(ElementProto, name, {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this.$[name];\n        },\n        set(value) {\n          this.$[name] = value;\n        }\n      });\n    }\n  }\n  if (ComponentProto[METHODS]) {\n    for (const name of ComponentProto[METHODS]) {\n      ElementProto[name] = function(...args) {\n        return this.$[name](...args);\n      };\n    }\n  }\n}\nfunction setup() {\n  if (this[SETUP_STATE] !== 0 /* Idle */)\n    return;\n  this[SETUP_STATE] = 1 /* Pending */;\n  const parent = findParent(this), isParentRegistered = parent && window.customElements.get(parent.localName), isParentSetup = parent && parent[SETUP_STATE] === 2 /* Ready */;\n  if (parent && (!isParentRegistered || !isParentSetup)) {\n    waitForParent.call(this, parent);\n    return;\n  }\n  attach.call(this, parent);\n}\nasync function waitForParent(parent) {\n  await window.customElements.whenDefined(parent.localName);\n  if (parent[SETUP_STATE] !== 2 /* Ready */) {\n    await new Promise((res) => (parent[SETUP_CALLBACKS] ??= []).push(res));\n  }\n  attach.call(this, parent);\n}\nfunction attach(parent) {\n  if (!this.isConnected)\n    return;\n  if (parent) {\n    if (parent.keepAlive && parent.forwardKeepAlive) {\n      this.keepAlive = true;\n      this.setAttribute(\"keep-alive\", \"\");\n    }\n    const scope = this.$.$$._scope;\n    if (scope)\n      parent.$.$$._attachScope.append(scope);\n  }\n  this[SETUP]();\n}\nfunction findParent(host) {\n  let node = host.parentNode, prefix = host.localName.split(\"-\", 1)[0] + \"-\";\n  while (node) {\n    if (node.nodeType === 1 && node.localName.startsWith(prefix)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\n\nfunction defineCustomElement(element, throws = false) {\n  if (throws || !window.customElements.get(element.tagName)) {\n    window.customElements.define(element.tagName, element);\n  }\n}\n\nexport { ariaBool as $, isNumber as A, useDisposalBin as B, Component as C, DOMEvent as D, isNil as E, createScope as F, isNull as G, Host as H, deferredPromise as I, EventsTarget as J, waitTimeout as K, animationFrameThrottle as L, unwrap as M, BOOLEAN as N, isArray as O, tick as P, createContext as Q, root as R, State as S, kebabToCamelCase as T, waitIdlePeriod as U, ViewController as V, provideContext as W, uppercaseFirstChar as X, prop as Y, method as Z, noop as _, setStyle as a, isWriteSignal as a0, hasProvidedContext as a1, isMouseEvent as a2, isTouchEvent as a3, createDisposalBin as a4, autoUpdate as b, computePosition as c, defineCustomElement as d, effect as e, setAttribute as f, getScope as g, signal as h, isKeyboardClick as i, computed as j, isString as k, listenEvent as l, hasTriggerEvent as m, findTriggerEvent as n, onDispose as o, peek as p, appendTriggerEvent as q, isPointerEvent as r, scoped as s, isKeyboardEvent as t, useState as u, useContext as v, walkTriggerEventChain as w, camelToKebabCase as x, isUndefined as y, isFunction as z };\n"]},"metadata":{},"sourceType":"module"}