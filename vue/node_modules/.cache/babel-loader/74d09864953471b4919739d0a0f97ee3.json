{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/*! @name mpd-parser @version 1.2.2 @license Apache-2.0 */\nimport resolveUrl from '@videojs/vhs-utils/es/resolve-url';\nimport window from 'global/window';\nimport { forEachMediaGroup } from '@videojs/vhs-utils/es/media-groups';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array';\nimport { DOMParser } from '@xmldom/xmldom';\nvar version = \"1.2.2\";\n\nconst isObject = obj => {\n  return !!obj && typeof obj === 'object';\n};\n\nconst merge = (...objects) => {\n  return objects.reduce((result, source) => {\n    if (typeof source !== 'object') {\n      return result;\n    }\n\n    Object.keys(source).forEach(key => {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\n\nconst values = o => Object.keys(o).map(k => o[k]);\n\nconst range = (start, end) => {\n  const result = [];\n\n  for (let i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\n\nconst flatten = lists => lists.reduce((x, y) => x.concat(y), []);\n\nconst from = list => {\n  if (!list.length) {\n    return [];\n  }\n\n  const result = [];\n\n  for (let i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\n\nconst findIndexes = (l, key) => l.reduce((a, e, i) => {\n  if (e[key]) {\n    a.push(i);\n  }\n\n  return a;\n}, []);\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\n\nconst union = (lists, keyFunction) => {\n  return values(lists.reduce((acc, list) => {\n    list.forEach(el => {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  INVALID_NUMBER_OF_CONTENT_STEERING: 'INVALID_NUMBER_OF_CONTENT_STEERING',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nconst urlTypeToSegment = ({\n  baseUrl = '',\n  source = '',\n  range = '',\n  indexRange = ''\n}) => {\n  const segment = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    const rangeStr = range ? range : indexRange;\n    const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    let startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    let endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n\n    let length;\n\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n\n    segment.byterange = {\n      length,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\n\nconst byteRangeToString = byterange => {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  let endRange;\n\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n\n  return `${byterange.offset}-${endRange}`;\n};\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\n\nconst parseEndNumber = endNumber => {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n\n  if (isNaN(endNumber)) {\n    return null;\n  }\n\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nconst segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static(attributes) {\n    const {\n      duration,\n      timescale = 1,\n      sourceDuration,\n      periodDuration\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber);\n    const segmentDuration = duration / timescale;\n\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic(attributes) {\n    const {\n      NOW,\n      clientOffset,\n      availabilityStartTime,\n      timescale = 1,\n      duration,\n      periodStart = 0,\n      minimumUpdatePeriod = 0,\n      timeShiftBufferDepth = Infinity\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    const periodEndWC = now + minimumUpdatePeriod;\n    const periodDuration = periodEndWC - periodStartWC;\n    const segmentCount = Math.ceil(periodDuration * timescale / duration);\n    const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nconst toSegments = attributes => number => {\n  const {\n    duration,\n    timescale = 1,\n    periodStart,\n    startNumber = 1\n  } = attributes;\n  return {\n    number: startNumber + number,\n    duration: duration / timescale,\n    timeline: periodStart,\n    time: number * duration\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nconst parseByDuration = attributes => {\n  const {\n    type,\n    duration,\n    timescale = 1,\n    periodDuration,\n    sourceDuration\n  } = attributes;\n  const {\n    start,\n    end\n  } = segmentRange[type](attributes);\n  const segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    const index = segments.length - 1; // section is either a period or the full source\n\n    const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\n\nconst segmentsFromBase = attributes => {\n  const {\n    baseUrl,\n    initialization = {},\n    sourceDuration,\n    indexRange = '',\n    periodStart,\n    presentationTime,\n    number = 0,\n    duration\n  } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: baseUrl,\n    indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    const segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\n\nconst addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n  // Retain init segment information\n  const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  const timeline = playlist.timeline || 0;\n  const sidxByteRange = playlist.sidx.byterange;\n  const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n  const segments = [];\n  const type = playlist.endList ? 'static' : 'dynamic';\n  const periodStart = playlist.sidx.timeline;\n  let presentationTime = periodStart;\n  let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  let startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n\n  for (let i = 0; i < mediaReferences.length; i++) {\n    const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    const duration = reference.subsegmentDuration; // should be an inclusive range\n\n    let endIndex; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n\n    const indexRange = `${startIndex}-${endIndex}`;\n    const attributes = {\n      baseUrl,\n      timescale,\n      timeline,\n      periodStart,\n      presentationTime,\n      number,\n      duration,\n      sourceDuration,\n      indexRange,\n      type\n    };\n    const segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n\n    if (typeof startIndex === 'bigint') {\n      startIndex += window.BigInt(size);\n    } else {\n      startIndex += size;\n    }\n\n    presentationTime += duration / timescale;\n    number++;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nconst SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nconst TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nconst getUniqueTimelineStarts = timelineStarts => {\n  return union(timelineStarts, ({\n    timeline\n  }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\n\nconst findPlaylistWithName = (playlists, name) => {\n  for (let i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\n\nconst getMediaGroupPlaylists = manifest => {\n  let mediaGroupPlaylists = [];\n  forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\n\nconst updateMediaSequenceForPlaylist = ({\n  playlist,\n  mediaSequence\n}) => {\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach((segment, index) => {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\n\nconst updateSequenceNumbers = ({\n  oldPlaylists,\n  newPlaylists,\n  timelineStarts\n}) => {\n  newPlaylists.forEach(playlist => {\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n\n    const firstNewSegment = playlist.segments[0];\n    const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n\n    const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n\n    updateMediaSequenceForPlaylist({\n      playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\n\nconst positionManifestOnTimeline = ({\n  oldManifest,\n  newManifest\n}) => {\n  // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n  const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists,\n    newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\n\nconst generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n\nconst mergeDiscontiguousPlaylists = playlists => {\n  // Break out playlists into groups based on their baseUrl\n  const playlistsByBaseUrl = playlists.reduce(function (acc, cur) {\n    if (!acc[cur.attributes.baseUrl]) {\n      acc[cur.attributes.baseUrl] = [];\n    }\n\n    acc[cur.attributes.baseUrl].push(cur);\n    return acc;\n  }, {});\n  let allPlaylists = [];\n  Object.values(playlistsByBaseUrl).forEach(playlistGroup => {\n    const mergedPlaylists = values(playlistGroup.reduce((acc, playlist) => {\n      // assuming playlist IDs are the same across periods\n      // TODO: handle multiperiod where representation sets are not the same\n      // across periods\n      const name = playlist.attributes.id + (playlist.attributes.lang || '');\n\n      if (!acc[name]) {\n        // First Period\n        acc[name] = playlist;\n        acc[name].attributes.timelineStarts = [];\n      } else {\n        // Subsequent Periods\n        if (playlist.segments) {\n          // first segment of subsequent periods signal a discontinuity\n          if (playlist.segments[0]) {\n            playlist.segments[0].discontinuity = true;\n          }\n\n          acc[name].segments.push(...playlist.segments);\n        } // bubble up contentProtection, this assumes all DRM content\n        // has the same contentProtection\n\n\n        if (playlist.attributes.contentProtection) {\n          acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n        }\n      }\n\n      acc[name].attributes.timelineStarts.push({\n        // Although they represent the same number, it's important to have both to make it\n        // compatible with HLS potentially having a similar attribute.\n        start: playlist.attributes.periodStart,\n        timeline: playlist.attributes.periodStart\n      });\n      return acc;\n    }, {}));\n    allPlaylists = allPlaylists.concat(mergedPlaylists);\n  });\n  return allPlaylists.map(playlist => {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\n\nconst addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n  const sidxKey = generateSidxKey(playlist.sidx);\n  const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n\n  return playlist;\n};\n\nconst addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (const i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n\n  return playlists;\n};\n\nconst formatAudioPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  mediaSequence,\n  discontinuitySequence,\n  discontinuityStarts\n}, isAudioOnly) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuitySequence,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n\n  return playlist;\n};\n\nconst formatVttPlaylist = ({\n  attributes,\n  segments,\n  mediaSequence,\n  discontinuityStarts,\n  discontinuitySequence\n}) => {\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  const m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth,\n    ['PROGRAM-ID']: 1\n  };\n\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n\n  const vttPlaylist = {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts,\n    discontinuitySequence,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.serviceLocation) {\n    vttPlaylist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  return vttPlaylist;\n};\n\nconst organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {\n  let mainPlaylist;\n  const formattedPlaylists = playlists.reduce((a, playlist) => {\n    const role = playlist.attributes.role && playlist.attributes.role.value || '';\n    const language = playlist.attributes.lang || '';\n    let label = playlist.attributes.label || 'main';\n\n    if (language && !playlist.attributes.label) {\n      const roleLabel = role ? ` (${role})` : '';\n      label = `${playlist.attributes.lang}${roleLabel}`;\n    }\n\n    if (!a[label]) {\n      a[label] = {\n        language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    const firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\n\nconst organizeVttPlaylists = (playlists, sidxMapping = {}) => {\n  return playlists.reduce((a, playlist) => {\n    const label = playlist.attributes.label || playlist.attributes.lang || 'text';\n\n    if (!a[label]) {\n      a[label] = {\n        language: label,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\n\nconst organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n  if (!svc) {\n    return svcObj;\n  }\n\n  svc.forEach(service => {\n    const {\n      channel,\n      language\n    } = service;\n    svcObj[language] = {\n      autoselect: false,\n      default: false,\n      instreamId: channel,\n      language\n    };\n\n    if (service.hasOwnProperty('aspectRatio')) {\n      svcObj[language].aspectRatio = service.aspectRatio;\n    }\n\n    if (service.hasOwnProperty('easyReader')) {\n      svcObj[language].easyReader = service.easyReader;\n    }\n\n    if (service.hasOwnProperty('3D')) {\n      svcObj[language]['3D'] = service['3D'];\n    }\n  });\n  return svcObj;\n}, {});\n\nconst formatVideoPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  discontinuityStarts\n}) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments\n  };\n\n  if (attributes.frameRate) {\n    playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n  }\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nconst videoOnly = ({\n  attributes\n}) => attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n\nconst audioOnly = ({\n  attributes\n}) => attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n\nconst vttOnly = ({\n  attributes\n}) => attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\n\nconst addMediaSequenceValues = (playlists, timelineStarts) => {\n  // increment all segments sequentially\n  playlists.forEach(playlist => {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    });\n\n    if (!playlist.segments) {\n      return;\n    }\n\n    playlist.segments.forEach((segment, index) => {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\n\nconst flattenMediaGroupPlaylists = mediaGroupObject => {\n  if (!mediaGroupObject) {\n    return [];\n  }\n\n  return Object.keys(mediaGroupObject).reduce((acc, label) => {\n    const labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\n\nconst toM3u8 = ({\n  dashPlaylists,\n  locations,\n  contentSteering,\n  sidxMapping = {},\n  previousManifest,\n  eventStream\n}) => {\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n\n  const {\n    sourceDuration: duration,\n    type,\n    suggestedPresentationDelay,\n    minimumUpdatePeriod\n  } = dashPlaylists[0].attributes;\n  const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n  const manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: {\n      AUDIO: {},\n      VIDEO: {},\n      ['CLOSED-CAPTIONS']: {},\n      SUBTITLES: {}\n    },\n    uri: '',\n    duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n\n  if (locations) {\n    manifest.locations = locations;\n  }\n\n  if (contentSteering) {\n    manifest.contentSteering = contentSteering;\n  }\n\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n\n  if (eventStream && eventStream.length > 0) {\n    manifest.eventStream = eventStream;\n  }\n\n  const isAudioOnly = manifest.playlists.length === 0;\n  const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  const playlistTimelineStarts = formattedPlaylists.map(({\n    timelineStarts\n  }) => timelineStarts);\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n\n  return manifest;\n};\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\n\n\nconst getLiveRValue = (attributes, time, duration) => {\n  const {\n    NOW,\n    clientOffset,\n    availabilityStartTime,\n    timescale = 1,\n    periodStart = 0,\n    minimumUpdatePeriod = 0\n  } = attributes;\n  const now = (NOW + clientOffset) / 1000;\n  const periodStartWC = availabilityStartTime + periodStart;\n  const periodEndWC = now + minimumUpdatePeriod;\n  const periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nconst parseByTimeline = (attributes, segmentTimeline) => {\n  const {\n    type,\n    minimumUpdatePeriod = 0,\n    media = '',\n    sourceDuration,\n    timescale = 1,\n    startNumber = 1,\n    periodStart: timeline\n  } = attributes;\n  const segments = [];\n  let time = -1;\n\n  for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    const S = segmentTimeline[sIndex];\n    const duration = S.d;\n    const repeat = S.r || 0;\n    const segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    let count;\n\n    if (repeat < 0) {\n      const nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    const end = startNumber + segments.length + count;\n    let number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number,\n        duration: duration / timescale,\n        time,\n        timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nconst identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nconst identifierReplacement = values => (match, identifier, format, width) => {\n  if (match === '$$') {\n    // escape sequence\n    return '$';\n  }\n\n  if (typeof values[identifier] === 'undefined') {\n    return match;\n  }\n\n  const value = '' + values[identifier];\n\n  if (identifier === 'RepresentationID') {\n    // Format tag shall not be present with RepresentationID\n    return value;\n  }\n\n  if (!format) {\n    width = 1;\n  } else {\n    width = parseInt(width, 10);\n  }\n\n  if (value.length >= width) {\n    return value;\n  }\n\n  return `${new Array(width - value.length + 1).join('0')}${value}`;\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\n\nconst constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nconst parseTemplateInfo = (attributes, segmentTimeline) => {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\n\nconst segmentsFromTemplate = (attributes, segmentTimeline) => {\n  const templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  const {\n    initialization = {\n      sourceURL: '',\n      range: ''\n    }\n  } = attributes;\n  const mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  const segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(segment => {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    const presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    const map = {\n      uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime\n    };\n    return map;\n  });\n};\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\n\nconst SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n  const {\n    baseUrl,\n    initialization = {}\n  } = attributes;\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nconst segmentsFromList = (attributes, segmentTimeline) => {\n  const {\n    duration,\n    segmentUrls = [],\n    periodStart\n  } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n  let segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  const segments = segmentTimeInfo.map((segmentTime, index) => {\n    if (segmentUrlMap[index]) {\n      const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(segment => segment);\n  return segments;\n};\n\nconst generateSegments = ({\n  attributes,\n  segmentInfo\n}) => {\n  let segmentAttributes;\n  let segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  const segmentsInfo = {\n    attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    const {\n      duration,\n      timescale = 1\n    } = segmentAttributes;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce((max, segment) => {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\n\nconst toPlaylists = representations => representations.map(generateSegments);\n\nconst findChildren = (element, name) => from(element.childNodes).filter(({\n  tagName\n}) => tagName === name);\n\nconst getContent = element => element.textContent.trim();\n/**\n * Converts the provided string that may contain a division operation to a number.\n *\n * @param {string} value - the provided string value\n *\n * @return {number} the parsed string value\n */\n\n\nconst parseDivisionValue = value => {\n  return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n};\n\nconst parseDuration = str => {\n  const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  const SECONDS_IN_DAY = 24 * 60 * 60;\n  const SECONDS_IN_HOUR = 60 * 60;\n  const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  const match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  const [year, month, day, hour, minute, second] = match.slice(1);\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\n\nconst parseDate = str => {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nconst parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type(value) {\n    return value;\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the frame rate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed frame rate\n   */\n  frameRate(value) {\n    return parseDivisionValue(value);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration(value) {\n    const parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTime.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTime\n   */\n  presentationTime(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT(value) {\n    return value;\n  }\n\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nconst parseAttributes = el => {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce((a, e) => {\n    const parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nconst keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {Object[]} references\n *        List of objects containing the reference URL as well as its attributes\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {Object[]}\n *         List of objects with resolved urls and attributes\n */\n\nconst buildBaseUrls = (references, baseUrlElements) => {\n  if (!baseUrlElements.length) {\n    return references;\n  }\n\n  return flatten(references.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      const initialBaseUrl = getContent(baseUrlElement);\n      const resolvedBaseUrl = resolveUrl(reference.baseUrl, initialBaseUrl);\n      const finalBaseUrl = merge(parseAttributes(baseUrlElement), {\n        baseUrl: resolvedBaseUrl\n      }); // If the URL is resolved, we want to get the serviceLocation from the reference\n      // assuming there is no serviceLocation on the initialBaseUrl\n\n      if (resolvedBaseUrl !== initialBaseUrl && !finalBaseUrl.serviceLocation && reference.serviceLocation) {\n        finalBaseUrl.serviceLocation = reference.serviceLocation;\n      }\n\n      return finalBaseUrl;\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\n\nconst getSegmentInformation = adaptationSet => {\n  const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge({\n    tag: 'SegmentURL'\n  }, parseAttributes(s)));\n  const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  const segmentTimelineParentNode = segmentList || segmentTemplate;\n  const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  const template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  const segmentInfo = {\n    template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(key => {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {Object[]} adaptationSetBaseUrls\n *        List of objects containing resolved base URLs and attributes\n *        inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\n\nconst inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n  const repBaseUrlElements = findChildren(representation, 'BaseURL');\n  const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n  const attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n  const representationSegmentInfo = getSegmentInformation(representation);\n  return repBaseUrls.map(baseUrl => {\n    return {\n      segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n      attributes: merge(attributes, baseUrl)\n    };\n  });\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\n\nconst generateKeySystemInformation = contentProtectionNodes => {\n  return contentProtectionNodes.reduce((acc, node) => {\n    const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n\n    const keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes\n      };\n      const psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        const pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n      }\n    }\n\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\n\nconst parseCaptionServiceMetadata = service => {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      let channel;\n      let language; // default language to value\n\n      language = value;\n\n      if (/^CC\\d=/.test(value)) {\n        [channel, language] = value.split('=');\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n\n      return {\n        channel,\n        language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      const flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n\n      if (/=/.test(value)) {\n        const [channel, opts = ''] = value.split('=');\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(opt => {\n          const [name, val] = opt.split(':');\n\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n\n      return flags;\n    });\n  }\n};\n/**\n * A map callback that will parse all event stream data for a collection of periods\n * DASH ISO_IEC_23009 5.10.2.2\n * https://dashif-documents.azurewebsites.net/Events/master/event.html#mpd-event-timing\n *\n * @param {PeriodInformation} period object containing necessary period information\n * @return a collection of parsed eventstream event objects\n */\n\n\nconst toEventStream = period => {\n  // get and flatten all EventStreams tags and parse attributes and children\n  return flatten(findChildren(period.node, 'EventStream').map(eventStream => {\n    const eventStreamAttributes = parseAttributes(eventStream);\n    const schemeIdUri = eventStreamAttributes.schemeIdUri; // find all Events per EventStream tag and map to return objects\n\n    return findChildren(eventStream, 'Event').map(event => {\n      const eventAttributes = parseAttributes(event);\n      const presentationTime = eventAttributes.presentationTime || 0;\n      const timescale = eventStreamAttributes.timescale || 1;\n      const duration = eventAttributes.duration || 0;\n      const start = presentationTime / timescale + period.attributes.start;\n      return {\n        schemeIdUri,\n        value: eventStreamAttributes.value,\n        id: eventAttributes.id,\n        start,\n        end: start + duration / timescale,\n        messageData: getContent(event) || eventAttributes.messageData,\n        contentEncoding: eventStreamAttributes.contentEncoding,\n        presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0\n      };\n    });\n  }));\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {Object[]} periodBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\n\nconst toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n  const adaptationSetAttributes = parseAttributes(adaptationSet);\n  const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n  const role = findChildren(adaptationSet, 'Role')[0];\n  const roleAttributes = {\n    role: parseAttributes(role)\n  };\n  let attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n  const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n  const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n\n  if (captionServices) {\n    attrs = merge(attrs, {\n      captionServices\n    });\n  }\n\n  const label = findChildren(adaptationSet, 'Label')[0];\n\n  if (label && label.childNodes.length) {\n    const labelVal = label.childNodes[0].nodeValue.trim();\n    attrs = merge(attrs, {\n      label: labelVal\n    });\n  }\n\n  const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n  if (Object.keys(contentProtection).length) {\n    attrs = merge(attrs, {\n      contentProtection\n    });\n  }\n\n  const segmentInfo = getSegmentInformation(adaptationSet);\n  const representations = findChildren(adaptationSet, 'Representation');\n  const adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n  return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n  * @param {Object[]} mpdBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\n\nconst toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n  const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n  const periodAttributes = merge(mpdAttributes, {\n    periodStart: period.attributes.start\n  });\n\n  if (typeof period.attributes.duration === 'number') {\n    periodAttributes.periodDuration = period.attributes.duration;\n  }\n\n  const adaptationSets = findChildren(period.node, 'AdaptationSet');\n  const periodSegmentInfo = getSegmentInformation(period.node);\n  return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n};\n/**\n * Tranforms an array of content steering nodes into an object\n * containing CDN content steering information from the MPD manifest.\n *\n * For more information on the DASH spec for Content Steering parsing, see:\n * https://dashif.org/docs/DASH-IF-CTS-00XX-Content-Steering-Community-Review.pdf\n *\n * @param {Node[]} contentSteeringNodes\n *        Content steering nodes\n * @param {Function} eventHandler\n *        The event handler passed into the parser options to handle warnings\n * @return {Object}\n *        Object containing content steering data\n */\n\n\nconst generateContentSteeringInformation = (contentSteeringNodes, eventHandler) => {\n  // If there are more than one ContentSteering tags, throw an error\n  if (contentSteeringNodes.length > 1) {\n    eventHandler({\n      type: 'warn',\n      message: 'The MPD manifest should contain no more than one ContentSteering tag'\n    });\n  } // Return a null value if there are no ContentSteering tags\n\n\n  if (!contentSteeringNodes.length) {\n    return null;\n  }\n\n  const infoFromContentSteeringTag = merge({\n    serverURL: getContent(contentSteeringNodes[0])\n  }, parseAttributes(contentSteeringNodes[0])); // Converts `queryBeforeStart` to a boolean, as well as setting the default value\n  // to `false` if it doesn't exist\n\n  infoFromContentSteeringTag.queryBeforeStart = infoFromContentSteeringTag.queryBeforeStart === 'true';\n  return infoFromContentSteeringTag;\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\n\nconst getPeriodStart = ({\n  attributes,\n  priorPeriodAttributes,\n  mpdType\n}) => {\n  // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\n\nconst inheritAttributes = (mpd, options = {}) => {\n  const {\n    manifestUri = '',\n    NOW = Date.now(),\n    clientOffset = 0,\n    // TODO: For now, we are expecting an eventHandler callback function\n    // to be passed into the mpd parser as an option.\n    // In the future, we should enable stream parsing by using the Stream class from vhs-utils.\n    // This will support new features including a standardized event handler.\n    // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.\n    // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9\n    eventHandler = function () {}\n  } = options;\n  const periodNodes = findChildren(mpd, 'Period');\n\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  const locations = findChildren(mpd, 'Location');\n  const mpdAttributes = parseAttributes(mpd);\n  const mpdBaseUrls = buildBaseUrls([{\n    baseUrl: manifestUri\n  }], findChildren(mpd, 'BaseURL'));\n  const contentSteeringNodes = findChildren(mpd, 'ContentSteering'); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n\n  const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach((node, index) => {\n    const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    const priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node,\n      attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    contentSteeringInfo: generateContentSteeringInformation(contentSteeringNodes, eventHandler),\n    // TODO: There are occurences where this `representationInfo` array contains undesired\n    // duplicates. This generally occurs when there are multiple BaseURL nodes that are\n    // direct children of the MPD node. When we attempt to resolve URLs from a combination of the\n    // parent BaseURL and a child BaseURL, and the value does not resolve,\n    // we end up returning the child BaseURL multiple times.\n    // We need to determine a way to remove these duplicates in a safe way.\n    // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls))),\n    eventStream: flatten(periods.map(toEventStream))\n  };\n};\n\nconst stringToMpdXml = manifestString => {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  const parser = new DOMParser();\n  let xml;\n  let mpd;\n\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throws on invalid xml\n  }\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nconst parseUTCTimingScheme = mpd => {\n  const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  const attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nconst VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nconst parse = (manifestString, options = {}) => {\n  const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    contentSteering: parsedManifestInfo.contentSteeringInfo,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest,\n    eventStream: parsedManifestInfo.eventStream\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nconst parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\n\nexport { VERSION, addSidxSegmentsToPlaylist$1 as addSidxSegmentsToPlaylist, generateSidxKey, inheritAttributes, parse, parseUTCTiming, stringToMpdXml, toM3u8, toPlaylists };","map":{"version":3,"sources":["/home/ann/dev/studip/54/public/plugins_packages/RasmusFuhse/LernmodulePlugin/vue/node_modules/mpd-parser/dist/mpd-parser.es.js"],"names":["resolveUrl","window","forEachMediaGroup","decodeB64ToUint8Array","DOMParser","version","isObject","obj","merge","objects","reduce","result","source","Object","keys","forEach","key","Array","isArray","concat","values","o","map","k","range","start","end","i","push","flatten","lists","x","y","from","list","length","findIndexes","l","a","e","union","keyFunction","acc","el","errors","INVALID_NUMBER_OF_PERIOD","INVALID_NUMBER_OF_CONTENT_STEERING","DASH_EMPTY_MANIFEST","DASH_INVALID_XML","NO_BASE_URL","MISSING_SEGMENT_INFORMATION","SEGMENT_TIME_UNSPECIFIED","UNSUPPORTED_UTC_TIMING_SCHEME","urlTypeToSegment","baseUrl","indexRange","segment","uri","resolvedUri","rangeStr","ranges","split","startRange","BigInt","parseInt","endRange","Number","MAX_SAFE_INTEGER","byterange","offset","byteRangeToString","parseEndNumber","endNumber","isNaN","segmentRange","static","attributes","duration","timescale","sourceDuration","periodDuration","segmentDuration","dynamic","NOW","clientOffset","availabilityStartTime","periodStart","minimumUpdatePeriod","timeShiftBufferDepth","Infinity","now","periodStartWC","periodEndWC","segmentCount","Math","ceil","availableStart","floor","availableEnd","max","min","toSegments","number","startNumber","timeline","time","parseByDuration","type","segments","index","sectionDuration","segmentsFromBase","initialization","presentationTime","Error","initSegment","sourceURL","segmentTimeInfo","addSidxSegmentsToPlaylist$1","playlist","sidx","sidxByteRange","sidxEnd","mediaReferences","references","filter","r","referenceType","endList","mediaSequence","startIndex","firstOffset","reference","size","referencedSize","subsegmentDuration","endIndex","SUPPORTED_MEDIA_TYPES","TIME_FUDGE","getUniqueTimelineStarts","timelineStarts","sort","b","findPlaylistWithName","playlists","name","NAME","getMediaGroupPlaylists","manifest","mediaGroupPlaylists","properties","group","label","updateMediaSequenceForPlaylist","updateSequenceNumbers","oldPlaylists","newPlaylists","discontinuitySequence","findIndex","oldPlaylist","firstNewSegment","oldMatchingSegmentIndex","oldSegment","abs","discontinuity","discontinuityStarts","unshift","oldMatchingSegment","positionManifestOnTimeline","oldManifest","newManifest","generateSidxKey","mergeDiscontiguousPlaylists","playlistsByBaseUrl","cur","allPlaylists","playlistGroup","mergedPlaylists","id","lang","contentProtection","addSidxSegmentsToPlaylist","sidxMapping","sidxKey","sidxMatch","addSidxSegmentsToPlaylists","formatAudioPlaylist","isAudioOnly","BANDWIDTH","bandwidth","CODECS","codecs","targetDuration","serviceLocation","AUDIO","SUBTITLES","formatVttPlaylist","m3u8Attributes","vttPlaylist","organizeAudioPlaylists","mainPlaylist","formattedPlaylists","role","value","language","roleLabel","autoselect","default","formatted","firstLabel","organizeVttPlaylists","organizeCaptionServices","captionServices","svcObj","svc","service","channel","instreamId","hasOwnProperty","aspectRatio","easyReader","formatVideoPlaylist","RESOLUTION","width","height","frameRate","videoOnly","mimeType","contentType","audioOnly","vttOnly","addMediaSequenceValues","flattenMediaGroupPlaylists","mediaGroupObject","labelContents","toM3u8","dashPlaylists","locations","contentSteering","previousManifest","eventStream","suggestedPresentationDelay","videoPlaylists","audioPlaylists","vttPlaylists","captions","Boolean","allowCache","mediaGroups","VIDEO","organizedAudioGroup","organizedVttGroup","playlistTimelineStarts","audio","subs","cc","getLiveRValue","parseByTimeline","segmentTimeline","media","sIndex","S","d","repeat","segmentTime","t","count","nextS","indexOf","identifierPattern","identifierReplacement","match","identifier","format","join","constructTemplateUrl","url","replace","parseTemplateInfo","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","mapSegment","Time","presentationTimeOffset","SegmentURLToSegmentObject","segmentUrl","mediaRange","segmentsFromList","segmentUrls","segmentUrlMap","segmentUrlObject","generateSegments","segmentInfo","segmentAttributes","segmentsFn","template","base","segmentsInfo","toPlaylists","representations","findChildren","element","childNodes","tagName","getContent","textContent","trim","parseDivisionValue","parseFloat","prev","current","parseDuration","str","SECONDS_IN_YEAR","SECONDS_IN_MONTH","SECONDS_IN_DAY","SECONDS_IN_HOUR","SECONDS_IN_MIN","durationRegex","exec","year","month","day","hour","minute","second","slice","parseDate","dateRegex","test","Date","parse","parsers","mediaPresentationDuration","parsedValue","DEFAULT","parseAttributes","parseFn","keySystemsMap","buildBaseUrls","baseUrlElements","baseUrlElement","initialBaseUrl","resolvedBaseUrl","finalBaseUrl","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","s","tag","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","inheritBaseUrls","adaptationSetAttributes","adaptationSetBaseUrls","adaptationSetSegmentInfo","representation","repBaseUrlElements","repBaseUrls","representationSegmentInfo","generateKeySystemInformation","contentProtectionNodes","node","schemeIdUri","toLowerCase","keySystem","psshNode","pssh","parseCaptionServiceMetadata","flags","undefined","opts","opt","val","toEventStream","period","eventStreamAttributes","event","eventAttributes","messageData","contentEncoding","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","roleAttributes","attrs","accessibility","labelVal","nodeValue","toAdaptationSets","mpdAttributes","mpdBaseUrls","adaptationSets","generateContentSteeringInformation","contentSteeringNodes","eventHandler","message","infoFromContentSteeringTag","serverURL","queryBeforeStart","getPeriodStart","priorPeriodAttributes","mpdType","inheritAttributes","mpd","options","manifestUri","periodNodes","periods","priorPeriod","contentSteeringInfo","representationInfo","stringToMpdXml","manifestString","parser","xml","parseFromString","documentElement","getElementsByTagName","parseUTCTimingScheme","UTCTimingNode","method","VERSION","parsedManifestInfo","parseUTCTiming"],"mappings":"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","sourcesContent":["/*! @name mpd-parser @version 1.2.2 @license Apache-2.0 */\nimport resolveUrl from '@videojs/vhs-utils/es/resolve-url';\nimport window from 'global/window';\nimport { forEachMediaGroup } from '@videojs/vhs-utils/es/media-groups';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array';\nimport { DOMParser } from '@xmldom/xmldom';\n\nvar version = \"1.2.2\";\n\nconst isObject = obj => {\n  return !!obj && typeof obj === 'object';\n};\n\nconst merge = (...objects) => {\n  return objects.reduce((result, source) => {\n    if (typeof source !== 'object') {\n      return result;\n    }\n\n    Object.keys(source).forEach(key => {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nconst values = o => Object.keys(o).map(k => o[k]);\n\nconst range = (start, end) => {\n  const result = [];\n\n  for (let i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\nconst flatten = lists => lists.reduce((x, y) => x.concat(y), []);\nconst from = list => {\n  if (!list.length) {\n    return [];\n  }\n\n  const result = [];\n\n  for (let i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\nconst findIndexes = (l, key) => l.reduce((a, e, i) => {\n  if (e[key]) {\n    a.push(i);\n  }\n\n  return a;\n}, []);\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\nconst union = (lists, keyFunction) => {\n  return values(lists.reduce((acc, list) => {\n    list.forEach(el => {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  INVALID_NUMBER_OF_CONTENT_STEERING: 'INVALID_NUMBER_OF_CONTENT_STEERING',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nconst urlTypeToSegment = ({\n  baseUrl = '',\n  source = '',\n  range = '',\n  indexRange = ''\n}) => {\n  const segment = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    const rangeStr = range ? range : indexRange;\n    const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    let startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    let endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n\n    let length;\n\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n\n    segment.byterange = {\n      length,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\nconst byteRangeToString = byterange => {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  let endRange;\n\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n\n  return `${byterange.offset}-${endRange}`;\n};\n\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\nconst parseEndNumber = endNumber => {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n\n  if (isNaN(endNumber)) {\n    return null;\n  }\n\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nconst segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static(attributes) {\n    const {\n      duration,\n      timescale = 1,\n      sourceDuration,\n      periodDuration\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber);\n    const segmentDuration = duration / timescale;\n\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic(attributes) {\n    const {\n      NOW,\n      clientOffset,\n      availabilityStartTime,\n      timescale = 1,\n      duration,\n      periodStart = 0,\n      minimumUpdatePeriod = 0,\n      timeShiftBufferDepth = Infinity\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    const periodEndWC = now + minimumUpdatePeriod;\n    const periodDuration = periodEndWC - periodStartWC;\n    const segmentCount = Math.ceil(periodDuration * timescale / duration);\n    const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nconst toSegments = attributes => number => {\n  const {\n    duration,\n    timescale = 1,\n    periodStart,\n    startNumber = 1\n  } = attributes;\n  return {\n    number: startNumber + number,\n    duration: duration / timescale,\n    timeline: periodStart,\n    time: number * duration\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseByDuration = attributes => {\n  const {\n    type,\n    duration,\n    timescale = 1,\n    periodDuration,\n    sourceDuration\n  } = attributes;\n  const {\n    start,\n    end\n  } = segmentRange[type](attributes);\n  const segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    const index = segments.length - 1; // section is either a period or the full source\n\n    const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nconst segmentsFromBase = attributes => {\n  const {\n    baseUrl,\n    initialization = {},\n    sourceDuration,\n    indexRange = '',\n    periodStart,\n    presentationTime,\n    number = 0,\n    duration\n  } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: baseUrl,\n    indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    const segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\nconst addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n  // Retain init segment information\n  const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  const timeline = playlist.timeline || 0;\n  const sidxByteRange = playlist.sidx.byterange;\n  const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n  const segments = [];\n  const type = playlist.endList ? 'static' : 'dynamic';\n  const periodStart = playlist.sidx.timeline;\n  let presentationTime = periodStart;\n  let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  let startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n\n  for (let i = 0; i < mediaReferences.length; i++) {\n    const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    const duration = reference.subsegmentDuration; // should be an inclusive range\n\n    let endIndex; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n\n    const indexRange = `${startIndex}-${endIndex}`;\n    const attributes = {\n      baseUrl,\n      timescale,\n      timeline,\n      periodStart,\n      presentationTime,\n      number,\n      duration,\n      sourceDuration,\n      indexRange,\n      type\n    };\n    const segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n\n    if (typeof startIndex === 'bigint') {\n      startIndex += window.BigInt(size);\n    } else {\n      startIndex += size;\n    }\n\n    presentationTime += duration / timescale;\n    number++;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nconst SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nconst TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nconst getUniqueTimelineStarts = timelineStarts => {\n  return union(timelineStarts, ({\n    timeline\n  }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\nconst findPlaylistWithName = (playlists, name) => {\n  for (let i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\nconst getMediaGroupPlaylists = manifest => {\n  let mediaGroupPlaylists = [];\n  forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\nconst updateMediaSequenceForPlaylist = ({\n  playlist,\n  mediaSequence\n}) => {\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach((segment, index) => {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\nconst updateSequenceNumbers = ({\n  oldPlaylists,\n  newPlaylists,\n  timelineStarts\n}) => {\n  newPlaylists.forEach(playlist => {\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n\n    const firstNewSegment = playlist.segments[0];\n    const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n\n    const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n\n    updateMediaSequenceForPlaylist({\n      playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\nconst positionManifestOnTimeline = ({\n  oldManifest,\n  newManifest\n}) => {\n  // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n  const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists,\n    newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\n\nconst generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n\nconst mergeDiscontiguousPlaylists = playlists => {\n  // Break out playlists into groups based on their baseUrl\n  const playlistsByBaseUrl = playlists.reduce(function (acc, cur) {\n    if (!acc[cur.attributes.baseUrl]) {\n      acc[cur.attributes.baseUrl] = [];\n    }\n\n    acc[cur.attributes.baseUrl].push(cur);\n    return acc;\n  }, {});\n  let allPlaylists = [];\n  Object.values(playlistsByBaseUrl).forEach(playlistGroup => {\n    const mergedPlaylists = values(playlistGroup.reduce((acc, playlist) => {\n      // assuming playlist IDs are the same across periods\n      // TODO: handle multiperiod where representation sets are not the same\n      // across periods\n      const name = playlist.attributes.id + (playlist.attributes.lang || '');\n\n      if (!acc[name]) {\n        // First Period\n        acc[name] = playlist;\n        acc[name].attributes.timelineStarts = [];\n      } else {\n        // Subsequent Periods\n        if (playlist.segments) {\n          // first segment of subsequent periods signal a discontinuity\n          if (playlist.segments[0]) {\n            playlist.segments[0].discontinuity = true;\n          }\n\n          acc[name].segments.push(...playlist.segments);\n        } // bubble up contentProtection, this assumes all DRM content\n        // has the same contentProtection\n\n\n        if (playlist.attributes.contentProtection) {\n          acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n        }\n      }\n\n      acc[name].attributes.timelineStarts.push({\n        // Although they represent the same number, it's important to have both to make it\n        // compatible with HLS potentially having a similar attribute.\n        start: playlist.attributes.periodStart,\n        timeline: playlist.attributes.periodStart\n      });\n      return acc;\n    }, {}));\n    allPlaylists = allPlaylists.concat(mergedPlaylists);\n  });\n  return allPlaylists.map(playlist => {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\n\nconst addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n  const sidxKey = generateSidxKey(playlist.sidx);\n  const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n\n  return playlist;\n};\nconst addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (const i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n\n  return playlists;\n};\nconst formatAudioPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  mediaSequence,\n  discontinuitySequence,\n  discontinuityStarts\n}, isAudioOnly) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuitySequence,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n\n  return playlist;\n};\nconst formatVttPlaylist = ({\n  attributes,\n  segments,\n  mediaSequence,\n  discontinuityStarts,\n  discontinuitySequence\n}) => {\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  const m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth,\n    ['PROGRAM-ID']: 1\n  };\n\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n\n  const vttPlaylist = {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts,\n    discontinuitySequence,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.serviceLocation) {\n    vttPlaylist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  return vttPlaylist;\n};\nconst organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {\n  let mainPlaylist;\n  const formattedPlaylists = playlists.reduce((a, playlist) => {\n    const role = playlist.attributes.role && playlist.attributes.role.value || '';\n    const language = playlist.attributes.lang || '';\n    let label = playlist.attributes.label || 'main';\n\n    if (language && !playlist.attributes.label) {\n      const roleLabel = role ? ` (${role})` : '';\n      label = `${playlist.attributes.lang}${roleLabel}`;\n    }\n\n    if (!a[label]) {\n      a[label] = {\n        language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    const firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\nconst organizeVttPlaylists = (playlists, sidxMapping = {}) => {\n  return playlists.reduce((a, playlist) => {\n    const label = playlist.attributes.label || playlist.attributes.lang || 'text';\n\n    if (!a[label]) {\n      a[label] = {\n        language: label,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\n\nconst organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n  if (!svc) {\n    return svcObj;\n  }\n\n  svc.forEach(service => {\n    const {\n      channel,\n      language\n    } = service;\n    svcObj[language] = {\n      autoselect: false,\n      default: false,\n      instreamId: channel,\n      language\n    };\n\n    if (service.hasOwnProperty('aspectRatio')) {\n      svcObj[language].aspectRatio = service.aspectRatio;\n    }\n\n    if (service.hasOwnProperty('easyReader')) {\n      svcObj[language].easyReader = service.easyReader;\n    }\n\n    if (service.hasOwnProperty('3D')) {\n      svcObj[language]['3D'] = service['3D'];\n    }\n  });\n  return svcObj;\n}, {});\n\nconst formatVideoPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  discontinuityStarts\n}) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments\n  };\n\n  if (attributes.frameRate) {\n    playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n  }\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nconst videoOnly = ({\n  attributes\n}) => attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n\nconst audioOnly = ({\n  attributes\n}) => attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n\nconst vttOnly = ({\n  attributes\n}) => attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\n\nconst addMediaSequenceValues = (playlists, timelineStarts) => {\n  // increment all segments sequentially\n  playlists.forEach(playlist => {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    });\n\n    if (!playlist.segments) {\n      return;\n    }\n\n    playlist.segments.forEach((segment, index) => {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\nconst flattenMediaGroupPlaylists = mediaGroupObject => {\n  if (!mediaGroupObject) {\n    return [];\n  }\n\n  return Object.keys(mediaGroupObject).reduce((acc, label) => {\n    const labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\nconst toM3u8 = ({\n  dashPlaylists,\n  locations,\n  contentSteering,\n  sidxMapping = {},\n  previousManifest,\n  eventStream\n}) => {\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n\n  const {\n    sourceDuration: duration,\n    type,\n    suggestedPresentationDelay,\n    minimumUpdatePeriod\n  } = dashPlaylists[0].attributes;\n  const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n  const manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: {\n      AUDIO: {},\n      VIDEO: {},\n      ['CLOSED-CAPTIONS']: {},\n      SUBTITLES: {}\n    },\n    uri: '',\n    duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n\n  if (locations) {\n    manifest.locations = locations;\n  }\n\n  if (contentSteering) {\n    manifest.contentSteering = contentSteering;\n  }\n\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n\n  if (eventStream && eventStream.length > 0) {\n    manifest.eventStream = eventStream;\n  }\n\n  const isAudioOnly = manifest.playlists.length === 0;\n  const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  const playlistTimelineStarts = formattedPlaylists.map(({\n    timelineStarts\n  }) => timelineStarts);\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n\n  return manifest;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nconst getLiveRValue = (attributes, time, duration) => {\n  const {\n    NOW,\n    clientOffset,\n    availabilityStartTime,\n    timescale = 1,\n    periodStart = 0,\n    minimumUpdatePeriod = 0\n  } = attributes;\n  const now = (NOW + clientOffset) / 1000;\n  const periodStartWC = availabilityStartTime + periodStart;\n  const periodEndWC = now + minimumUpdatePeriod;\n  const periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nconst parseByTimeline = (attributes, segmentTimeline) => {\n  const {\n    type,\n    minimumUpdatePeriod = 0,\n    media = '',\n    sourceDuration,\n    timescale = 1,\n    startNumber = 1,\n    periodStart: timeline\n  } = attributes;\n  const segments = [];\n  let time = -1;\n\n  for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    const S = segmentTimeline[sIndex];\n    const duration = S.d;\n    const repeat = S.r || 0;\n    const segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    let count;\n\n    if (repeat < 0) {\n      const nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    const end = startNumber + segments.length + count;\n    let number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number,\n        duration: duration / timescale,\n        time,\n        timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nconst identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nconst identifierReplacement = values => (match, identifier, format, width) => {\n  if (match === '$$') {\n    // escape sequence\n    return '$';\n  }\n\n  if (typeof values[identifier] === 'undefined') {\n    return match;\n  }\n\n  const value = '' + values[identifier];\n\n  if (identifier === 'RepresentationID') {\n    // Format tag shall not be present with RepresentationID\n    return value;\n  }\n\n  if (!format) {\n    width = 1;\n  } else {\n    width = parseInt(width, 10);\n  }\n\n  if (value.length >= width) {\n    return value;\n  }\n\n  return `${new Array(width - value.length + 1).join('0')}${value}`;\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nconst constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseTemplateInfo = (attributes, segmentTimeline) => {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nconst segmentsFromTemplate = (attributes, segmentTimeline) => {\n  const templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  const {\n    initialization = {\n      sourceURL: '',\n      range: ''\n    }\n  } = attributes;\n  const mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  const segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(segment => {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    const presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    const map = {\n      uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime\n    };\n    return map;\n  });\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nconst SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n  const {\n    baseUrl,\n    initialization = {}\n  } = attributes;\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nconst segmentsFromList = (attributes, segmentTimeline) => {\n  const {\n    duration,\n    segmentUrls = [],\n    periodStart\n  } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n  let segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  const segments = segmentTimeInfo.map((segmentTime, index) => {\n    if (segmentUrlMap[index]) {\n      const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(segment => segment);\n  return segments;\n};\n\nconst generateSegments = ({\n  attributes,\n  segmentInfo\n}) => {\n  let segmentAttributes;\n  let segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  const segmentsInfo = {\n    attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    const {\n      duration,\n      timescale = 1\n    } = segmentAttributes;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce((max, segment) => {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\nconst toPlaylists = representations => representations.map(generateSegments);\n\nconst findChildren = (element, name) => from(element.childNodes).filter(({\n  tagName\n}) => tagName === name);\nconst getContent = element => element.textContent.trim();\n\n/**\n * Converts the provided string that may contain a division operation to a number.\n *\n * @param {string} value - the provided string value\n *\n * @return {number} the parsed string value\n */\nconst parseDivisionValue = value => {\n  return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n};\n\nconst parseDuration = str => {\n  const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  const SECONDS_IN_DAY = 24 * 60 * 60;\n  const SECONDS_IN_HOUR = 60 * 60;\n  const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  const match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  const [year, month, day, hour, minute, second] = match.slice(1);\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nconst parseDate = str => {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nconst parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type(value) {\n    return value;\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the frame rate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed frame rate\n   */\n  frameRate(value) {\n    return parseDivisionValue(value);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration(value) {\n    const parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTime.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTime\n   */\n  presentationTime(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT(value) {\n    return value;\n  }\n\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nconst parseAttributes = el => {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce((a, e) => {\n    const parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nconst keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {Object[]} references\n *        List of objects containing the reference URL as well as its attributes\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {Object[]}\n *         List of objects with resolved urls and attributes\n */\n\nconst buildBaseUrls = (references, baseUrlElements) => {\n  if (!baseUrlElements.length) {\n    return references;\n  }\n\n  return flatten(references.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      const initialBaseUrl = getContent(baseUrlElement);\n      const resolvedBaseUrl = resolveUrl(reference.baseUrl, initialBaseUrl);\n      const finalBaseUrl = merge(parseAttributes(baseUrlElement), {\n        baseUrl: resolvedBaseUrl\n      }); // If the URL is resolved, we want to get the serviceLocation from the reference\n      // assuming there is no serviceLocation on the initialBaseUrl\n\n      if (resolvedBaseUrl !== initialBaseUrl && !finalBaseUrl.serviceLocation && reference.serviceLocation) {\n        finalBaseUrl.serviceLocation = reference.serviceLocation;\n      }\n\n      return finalBaseUrl;\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nconst getSegmentInformation = adaptationSet => {\n  const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge({\n    tag: 'SegmentURL'\n  }, parseAttributes(s)));\n  const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  const segmentTimelineParentNode = segmentList || segmentTemplate;\n  const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  const template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  const segmentInfo = {\n    template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(key => {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {Object[]} adaptationSetBaseUrls\n *        List of objects containing resolved base URLs and attributes\n *        inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nconst inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n  const repBaseUrlElements = findChildren(representation, 'BaseURL');\n  const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n  const attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n  const representationSegmentInfo = getSegmentInformation(representation);\n  return repBaseUrls.map(baseUrl => {\n    return {\n      segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n      attributes: merge(attributes, baseUrl)\n    };\n  });\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nconst generateKeySystemInformation = contentProtectionNodes => {\n  return contentProtectionNodes.reduce((acc, node) => {\n    const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n\n    const keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes\n      };\n      const psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        const pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n      }\n    }\n\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\n\nconst parseCaptionServiceMetadata = service => {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      let channel;\n      let language; // default language to value\n\n      language = value;\n\n      if (/^CC\\d=/.test(value)) {\n        [channel, language] = value.split('=');\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n\n      return {\n        channel,\n        language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      const flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n\n      if (/=/.test(value)) {\n        const [channel, opts = ''] = value.split('=');\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(opt => {\n          const [name, val] = opt.split(':');\n\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n\n      return flags;\n    });\n  }\n};\n/**\n * A map callback that will parse all event stream data for a collection of periods\n * DASH ISO_IEC_23009 5.10.2.2\n * https://dashif-documents.azurewebsites.net/Events/master/event.html#mpd-event-timing\n *\n * @param {PeriodInformation} period object containing necessary period information\n * @return a collection of parsed eventstream event objects\n */\n\nconst toEventStream = period => {\n  // get and flatten all EventStreams tags and parse attributes and children\n  return flatten(findChildren(period.node, 'EventStream').map(eventStream => {\n    const eventStreamAttributes = parseAttributes(eventStream);\n    const schemeIdUri = eventStreamAttributes.schemeIdUri; // find all Events per EventStream tag and map to return objects\n\n    return findChildren(eventStream, 'Event').map(event => {\n      const eventAttributes = parseAttributes(event);\n      const presentationTime = eventAttributes.presentationTime || 0;\n      const timescale = eventStreamAttributes.timescale || 1;\n      const duration = eventAttributes.duration || 0;\n      const start = presentationTime / timescale + period.attributes.start;\n      return {\n        schemeIdUri,\n        value: eventStreamAttributes.value,\n        id: eventAttributes.id,\n        start,\n        end: start + duration / timescale,\n        messageData: getContent(event) || eventAttributes.messageData,\n        contentEncoding: eventStreamAttributes.contentEncoding,\n        presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0\n      };\n    });\n  }));\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {Object[]} periodBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\nconst toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n  const adaptationSetAttributes = parseAttributes(adaptationSet);\n  const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n  const role = findChildren(adaptationSet, 'Role')[0];\n  const roleAttributes = {\n    role: parseAttributes(role)\n  };\n  let attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n  const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n  const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n\n  if (captionServices) {\n    attrs = merge(attrs, {\n      captionServices\n    });\n  }\n\n  const label = findChildren(adaptationSet, 'Label')[0];\n\n  if (label && label.childNodes.length) {\n    const labelVal = label.childNodes[0].nodeValue.trim();\n    attrs = merge(attrs, {\n      label: labelVal\n    });\n  }\n\n  const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n  if (Object.keys(contentProtection).length) {\n    attrs = merge(attrs, {\n      contentProtection\n    });\n  }\n\n  const segmentInfo = getSegmentInformation(adaptationSet);\n  const representations = findChildren(adaptationSet, 'Representation');\n  const adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n  return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n  * @param {Object[]} mpdBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nconst toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n  const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n  const periodAttributes = merge(mpdAttributes, {\n    periodStart: period.attributes.start\n  });\n\n  if (typeof period.attributes.duration === 'number') {\n    periodAttributes.periodDuration = period.attributes.duration;\n  }\n\n  const adaptationSets = findChildren(period.node, 'AdaptationSet');\n  const periodSegmentInfo = getSegmentInformation(period.node);\n  return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n};\n/**\n * Tranforms an array of content steering nodes into an object\n * containing CDN content steering information from the MPD manifest.\n *\n * For more information on the DASH spec for Content Steering parsing, see:\n * https://dashif.org/docs/DASH-IF-CTS-00XX-Content-Steering-Community-Review.pdf\n *\n * @param {Node[]} contentSteeringNodes\n *        Content steering nodes\n * @param {Function} eventHandler\n *        The event handler passed into the parser options to handle warnings\n * @return {Object}\n *        Object containing content steering data\n */\n\nconst generateContentSteeringInformation = (contentSteeringNodes, eventHandler) => {\n  // If there are more than one ContentSteering tags, throw an error\n  if (contentSteeringNodes.length > 1) {\n    eventHandler({\n      type: 'warn',\n      message: 'The MPD manifest should contain no more than one ContentSteering tag'\n    });\n  } // Return a null value if there are no ContentSteering tags\n\n\n  if (!contentSteeringNodes.length) {\n    return null;\n  }\n\n  const infoFromContentSteeringTag = merge({\n    serverURL: getContent(contentSteeringNodes[0])\n  }, parseAttributes(contentSteeringNodes[0])); // Converts `queryBeforeStart` to a boolean, as well as setting the default value\n  // to `false` if it doesn't exist\n\n  infoFromContentSteeringTag.queryBeforeStart = infoFromContentSteeringTag.queryBeforeStart === 'true';\n  return infoFromContentSteeringTag;\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\nconst getPeriodStart = ({\n  attributes,\n  priorPeriodAttributes,\n  mpdType\n}) => {\n  // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nconst inheritAttributes = (mpd, options = {}) => {\n  const {\n    manifestUri = '',\n    NOW = Date.now(),\n    clientOffset = 0,\n    // TODO: For now, we are expecting an eventHandler callback function\n    // to be passed into the mpd parser as an option.\n    // In the future, we should enable stream parsing by using the Stream class from vhs-utils.\n    // This will support new features including a standardized event handler.\n    // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.\n    // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9\n    eventHandler = function () {}\n  } = options;\n  const periodNodes = findChildren(mpd, 'Period');\n\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  const locations = findChildren(mpd, 'Location');\n  const mpdAttributes = parseAttributes(mpd);\n  const mpdBaseUrls = buildBaseUrls([{\n    baseUrl: manifestUri\n  }], findChildren(mpd, 'BaseURL'));\n  const contentSteeringNodes = findChildren(mpd, 'ContentSteering'); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n\n  const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach((node, index) => {\n    const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    const priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node,\n      attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    contentSteeringInfo: generateContentSteeringInformation(contentSteeringNodes, eventHandler),\n    // TODO: There are occurences where this `representationInfo` array contains undesired\n    // duplicates. This generally occurs when there are multiple BaseURL nodes that are\n    // direct children of the MPD node. When we attempt to resolve URLs from a combination of the\n    // parent BaseURL and a child BaseURL, and the value does not resolve,\n    // we end up returning the child BaseURL multiple times.\n    // We need to determine a way to remove these duplicates in a safe way.\n    // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls))),\n    eventStream: flatten(periods.map(toEventStream))\n  };\n};\n\nconst stringToMpdXml = manifestString => {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  const parser = new DOMParser();\n  let xml;\n  let mpd;\n\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throws on invalid xml\n  }\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nconst parseUTCTimingScheme = mpd => {\n  const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  const attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nconst VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nconst parse = (manifestString, options = {}) => {\n  const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    contentSteering: parsedManifestInfo.contentSteeringInfo,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest,\n    eventStream: parsedManifestInfo.eventStream\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nconst parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\n\nexport { VERSION, addSidxSegmentsToPlaylist$1 as addSidxSegmentsToPlaylist, generateSidxKey, inheritAttributes, parse, parseUTCTiming, stringToMpdXml, toM3u8, toPlaylists };\n"]},"metadata":{},"sourceType":"module"}