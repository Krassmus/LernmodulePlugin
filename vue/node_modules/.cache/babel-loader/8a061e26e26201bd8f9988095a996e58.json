{"ast":null,"code":"import _defineProperty from \"/home/ann/dev/studip/54/public/plugins_packages/RasmusFuhse/LernmodulePlugin/vue/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.error.cause.js\";\nconst ParseErrorCode = {\n  LoadFail: 0,\n  BadSignature: 1,\n  BadTimestamp: 2,\n  BadSettingValue: 3,\n  BadFormat: 4,\n  UnknownSetting: 5\n};\n\nclass ParseError extends Error {\n  constructor(init) {\n    super(init.reason);\n\n    _defineProperty(this, \"code\", void 0);\n\n    _defineProperty(this, \"line\", void 0);\n\n    this.code = init.code;\n    this.line = init.line;\n  }\n\n}\n\nconst LINE_TERMINATOR_RE = /\\r?\\n|\\r/gm;\n\nclass TextLineTransformStream {\n  constructor(encoding) {\n    _defineProperty(this, \"writable\", void 0);\n\n    _defineProperty(this, \"readable\", void 0);\n\n    const transformer = new TextStreamLineIterator(encoding);\n    this.writable = new WritableStream({\n      write(chunk) {\n        transformer.transform(chunk);\n      },\n\n      close() {\n        transformer.close();\n      }\n\n    });\n    this.readable = new ReadableStream({\n      start(controller) {\n        transformer.onLine = line => controller.enqueue(line);\n\n        transformer.onClose = () => controller.close();\n      }\n\n    });\n  }\n\n}\n\nclass TextStreamLineIterator {\n  constructor(encoding) {\n    _defineProperty(this, \"_buffer\", \"\");\n\n    _defineProperty(this, \"_decoder\", void 0);\n\n    _defineProperty(this, \"onLine\", void 0);\n\n    _defineProperty(this, \"onClose\", void 0);\n\n    this._decoder = new TextDecoder(encoding);\n  }\n\n  transform(chunk) {\n    this._buffer += this._decoder.decode(chunk, {\n      stream: true\n    });\n\n    const lines = this._buffer.split(LINE_TERMINATOR_RE);\n\n    this._buffer = lines.pop() || \"\";\n\n    for (let i = 0; i < lines.length; i++) this.onLine(lines[i].trim());\n  }\n\n  close() {\n    if (this._buffer) this.onLine(this._buffer.trim());\n    this._buffer = \"\";\n    this.onClose();\n  }\n\n}\n\nasync function parseText(text, options) {\n  const stream = new ReadableStream({\n    start(controller) {\n      const lines = text.split(LINE_TERMINATOR_RE);\n\n      for (const line of lines) controller.enqueue(line);\n\n      controller.close();\n    }\n\n  });\n  return parseTextStream(stream, options);\n}\n\nasync function parseTextStream(stream, options) {\n  const type = options?.type ?? \"vtt\";\n  let factory;\n\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"srt\":\n        factory = (await import('./srt-parser.js')).default;\n        break;\n\n      case \"ssa\":\n      case \"ass\":\n        factory = (await import('./ssa-parser.js')).default;\n        break;\n\n      default:\n        factory = (await Promise.resolve().then(function () {\n          return vttParser;\n        })).default;\n    }\n  } else {\n    factory = type;\n  }\n\n  let result;\n  const reader = stream.getReader(),\n        parser = factory(),\n        errors = options?.errors !== false || !!options?.strict || !!options?.errors;\n  await parser.init({\n    strict: false,\n    ...options,\n    errors,\n    type,\n\n    cancel() {\n      reader.cancel();\n      result = parser.done(true);\n    }\n\n  });\n  let i = 1;\n\n  while (true) {\n    const {\n      value,\n      done\n    } = await reader.read();\n\n    if (done) {\n      parser.parse(\"\", i);\n      result = parser.done(false);\n      break;\n    }\n\n    parser.parse(value, i);\n    i++;\n  }\n\n  return result;\n}\n\nasync function parseResponse(response, options) {\n  const res = await response;\n\n  if (!res.ok || !res.body) {\n    let error;\n    {\n      error = new ParseError({\n        code: ParseErrorCode.LoadFail,\n        reason: !res.ok ? `response is not ok (status: ${res.status})` : `response body is missing (status: ${res.status})`,\n        line: -1\n      });\n      options?.onError?.(error);\n    }\n    return {\n      metadata: {},\n      cues: [],\n      regions: [],\n      errors: [error]\n    };\n  }\n\n  const contentType = res.headers.get(\"content-type\") || \"\",\n        type = contentType.match(/text\\/(.*?)(?:;|$)/)?.[1],\n        encoding = contentType.match(/charset=(.*?)(?:;|$)/)?.[1];\n  return parseByteStream(res.body, {\n    type,\n    encoding,\n    ...options\n  });\n}\n\nasync function parseByteStream(stream, {\n  encoding = \"utf-8\",\n  ...options\n} = {}) {\n  const textStream = stream.pipeThrough(new TextLineTransformStream(encoding));\n  return parseTextStream(textStream, options);\n}\n\nclass TextCue extends EventTarget {\n  /**\n   * A string that identifies the cue.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/id}\n   */\n\n  /**\n   * A `double` that represents the video time that the cue will start being displayed, in seconds.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/startTime}\n   */\n\n  /**\n   * A `double` that represents the video time that the cue will stop being displayed, in seconds.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/endTime}\n   */\n\n  /**\n   * Returns a string with the contents of the cue.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/text}\n   */\n\n  /**\n   * A `boolean` for whether the video will pause when this cue stops being displayed.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/pauseOnExit}\n   */\n  constructor(startTime, endTime, text) {\n    super();\n\n    _defineProperty(this, \"id\", \"\");\n\n    _defineProperty(this, \"startTime\", void 0);\n\n    _defineProperty(this, \"endTime\", void 0);\n\n    _defineProperty(this, \"text\", void 0);\n\n    _defineProperty(this, \"pauseOnExit\", false);\n\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.text = text;\n  }\n\n  addEventListener(type, listener, options) {\n    super.addEventListener(type, listener, options);\n  }\n\n  removeEventListener(type, listener, options) {\n    super.removeEventListener(type, listener, options);\n  }\n\n}\n\nconst CueBase = window.VTTCue;\n\nclass VTTCue extends CueBase {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"region\", null);\n\n    _defineProperty(this, \"vertical\", \"\");\n\n    _defineProperty(this, \"snapToLines\", true);\n\n    _defineProperty(this, \"line\", \"auto\");\n\n    _defineProperty(this, \"lineAlign\", \"start\");\n\n    _defineProperty(this, \"position\", \"auto\");\n\n    _defineProperty(this, \"positionAlign\", \"auto\");\n\n    _defineProperty(this, \"size\", 100);\n\n    _defineProperty(this, \"align\", \"center\");\n\n    _defineProperty(this, \"style\", void 0);\n  }\n\n}\n\nclass VTTRegion {\n  constructor() {\n    _defineProperty(this, \"id\", \"\");\n\n    _defineProperty(this, \"width\", 100);\n\n    _defineProperty(this, \"lines\", 3);\n\n    _defineProperty(this, \"regionAnchorX\", 0);\n\n    _defineProperty(this, \"regionAnchorY\", 100);\n\n    _defineProperty(this, \"viewportAnchorX\", 0);\n\n    _defineProperty(this, \"viewportAnchorY\", 100);\n\n    _defineProperty(this, \"scroll\", \"\");\n  }\n\n}\n\nconst COMMA$1 = \",\",\n      PERCENT_SIGN$1 = \"%\";\n\nfunction toNumber(text) {\n  const num = parseInt(text, 10);\n  return !Number.isNaN(num) ? num : null;\n}\n\nfunction toPercentage(text) {\n  const num = parseInt(text.replace(PERCENT_SIGN$1, \"\"), 10);\n  return !Number.isNaN(num) && num >= 0 && num <= 100 ? num : null;\n}\n\nfunction toCoords(text) {\n  if (!text.includes(COMMA$1)) return null;\n  const [x, y] = text.split(COMMA$1).map(toPercentage);\n  return x !== null && y !== null ? [x, y] : null;\n}\n\nfunction toFloat(text) {\n  const num = parseFloat(text);\n  return !Number.isNaN(num) ? num : null;\n}\n\nconst HEADER_MAGIC = \"WEBVTT\",\n      COMMA = \",\",\n      PERCENT_SIGN = \"%\",\n      SETTING_SEP_RE = /[:=]/,\n      SETTING_LINE_RE = /^[\\s\\t]*(region|vertical|line|position|size|align)[:=]/,\n      NOTE_BLOCK_START = \"NOTE\",\n      REGION_BLOCK_START = \"REGION\",\n      REGION_BLOCK_START_RE = /^REGION:?[\\s\\t]+/,\n      SPACE_RE = /[\\s\\t]+/,\n      TIMESTAMP_SEP = \"-->\",\n      TIMESTAMP_SEP_RE = /[\\s\\t]*-->[\\s\\t]+/,\n      ALIGN_RE = /start|center|end|left|right/,\n      LINE_ALIGN_RE = /start|center|end/,\n      POS_ALIGN_RE = /line-(?:left|right)|center|auto/,\n      TIMESTAMP_RE = /^(?:(\\d{1,2}):)?(\\d{2}):(\\d{2})(?:\\.(\\d{1,3}))?$/;\n\nvar VTTBlock = /* @__PURE__ */(VTTBlock2 => {\n  VTTBlock2[VTTBlock2[\"None\"] = 0] = \"None\";\n  VTTBlock2[VTTBlock2[\"Header\"] = 1] = \"Header\";\n  VTTBlock2[VTTBlock2[\"Cue\"] = 2] = \"Cue\";\n  VTTBlock2[VTTBlock2[\"Region\"] = 3] = \"Region\";\n  VTTBlock2[VTTBlock2[\"Note\"] = 4] = \"Note\";\n  return VTTBlock2;\n})(VTTBlock || {});\n\nclass VTTParser {\n  constructor() {\n    _defineProperty(this, \"_init\", void 0);\n\n    _defineProperty(this, \"_block\", 0\n    /* None */\n    );\n\n    _defineProperty(this, \"_metadata\", {});\n\n    _defineProperty(this, \"_regions\", {});\n\n    _defineProperty(this, \"_cues\", []);\n\n    _defineProperty(this, \"_cue\", null);\n\n    _defineProperty(this, \"_region\", null);\n\n    _defineProperty(this, \"_errors\", []);\n\n    _defineProperty(this, \"_errorBuilder\", void 0);\n\n    _defineProperty(this, \"_prevLine\", \"\");\n  }\n\n  async init(init) {\n    this._init = init;\n    if (init.strict) this._block = 1\n    /* Header */\n    ;\n    if (init.errors) this._errorBuilder = (await import('./errors.js')).ParseErrorBuilder;\n  }\n\n  parse(line, lineCount) {\n    if (line === \"\") {\n      if (this._cue) {\n        this._cues.push(this._cue);\n\n        this._init.onCue?.(this._cue);\n        this._cue = null;\n      } else if (this._region) {\n        this._regions[this._region.id] = this._region;\n        this._init.onRegion?.(this._region);\n        this._region = null;\n      } else if (this._block === 1\n      /* Header */\n      ) {\n        this._parseHeader(line, lineCount);\n\n        this._init.onHeaderMetadata?.(this._metadata);\n      }\n\n      this._block = 0\n      /* None */\n      ;\n    } else if (this._block) {\n      switch (this._block) {\n        case 1\n        /* Header */\n        :\n          this._parseHeader(line, lineCount);\n\n          break;\n\n        case 2\n        /* Cue */\n        :\n          if (this._cue) {\n            const hasText = this._cue.text.length > 0;\n\n            if (!hasText && SETTING_LINE_RE.test(line)) {\n              this._parseCueSettings(line.split(SPACE_RE), lineCount);\n            } else {\n              this._cue.text += (hasText ? \"\\n\" : \"\") + line;\n            }\n          }\n\n          break;\n\n        case 3\n        /* Region */\n        :\n          this._parseRegionSettings(line.split(SPACE_RE), lineCount);\n\n          break;\n      }\n    } else if (line.startsWith(NOTE_BLOCK_START)) {\n      this._block = 4\n      /* Note */\n      ;\n    } else if (line.startsWith(REGION_BLOCK_START)) {\n      this._block = 3\n      /* Region */\n      ;\n      this._region = new VTTRegion();\n\n      this._parseRegionSettings(line.replace(REGION_BLOCK_START_RE, \"\").split(SPACE_RE), lineCount);\n    } else if (line.includes(TIMESTAMP_SEP)) {\n      const result = this._parseTimestamp(line, lineCount);\n\n      if (result) {\n        this._cue = new VTTCue(result[0], result[1], \"\");\n        this._cue.id = this._prevLine;\n\n        this._parseCueSettings(result[2], lineCount);\n      }\n\n      this._block = 2\n      /* Cue */\n      ;\n    } else if (lineCount === 1) {\n      this._parseHeader(line, lineCount);\n    }\n\n    this._prevLine = line;\n  }\n\n  done() {\n    return {\n      metadata: this._metadata,\n      cues: this._cues,\n      regions: Object.values(this._regions),\n      errors: this._errors\n    };\n  }\n\n  _parseHeader(line, lineCount) {\n    if (lineCount > 1) {\n      if (SETTING_SEP_RE.test(line)) {\n        const [key, value] = line.split(SETTING_SEP_RE);\n        if (key) this._metadata[key] = (value || \"\").replace(SPACE_RE, \"\");\n      }\n    } else if (line.startsWith(HEADER_MAGIC)) {\n      this._block = 1\n      /* Header */\n      ;\n    } else {\n      this._handleError(this._errorBuilder?._badVTTHeader());\n    }\n  }\n\n  _parseTimestamp(line, lineCount) {\n    const [startTimeText, trailingText = \"\"] = line.split(TIMESTAMP_SEP_RE),\n          [endTimeText, ...settingsText] = trailingText.split(SPACE_RE),\n          startTime = parseVTTTimestamp(startTimeText),\n          endTime = parseVTTTimestamp(endTimeText);\n\n    if (startTime !== null && endTime !== null && endTime > startTime) {\n      return [startTime, endTime, settingsText];\n    } else {\n      if (startTime === null) {\n        this._handleError(this._errorBuilder?._badStartTimestamp(startTimeText, lineCount));\n      }\n\n      if (endTime === null) {\n        this._handleError(this._errorBuilder?._badEndTimestamp(endTimeText, lineCount));\n      }\n\n      if (startTime != null && endTime !== null && endTime > startTime) {\n        this._handleError(this._errorBuilder?._badRangeTimestamp(startTime, endTime, lineCount));\n      }\n    }\n  }\n  /**\n   * @see {@link https://www.w3.org/TR/webvtt1/#region-settings-parsing}\n   */\n\n\n  _parseRegionSettings(settings, line) {\n    let badValue;\n\n    for (let i = 0; i < settings.length; i++) {\n      if (SETTING_SEP_RE.test(settings[i])) {\n        badValue = false;\n        const [name, value] = settings[i].split(SETTING_SEP_RE);\n\n        switch (name) {\n          case \"id\":\n            this._region.id = value;\n            break;\n\n          case \"width\":\n            const width = toPercentage(value);\n            if (width !== null) this._region.width = width;else badValue = true;\n            break;\n\n          case \"lines\":\n            const lines = toNumber(value);\n            if (lines !== null) this._region.lines = lines;else badValue = true;\n            break;\n\n          case \"regionanchor\":\n            const region = toCoords(value);\n\n            if (region !== null) {\n              this._region.regionAnchorX = region[0];\n              this._region.regionAnchorY = region[1];\n            } else badValue = true;\n\n            break;\n\n          case \"viewportanchor\":\n            const viewport = toCoords(value);\n\n            if (viewport !== null) {\n              this._region.viewportAnchorX = viewport[0];\n              this._region.viewportAnchorY = viewport[1];\n            } else badValue = true;\n\n            break;\n\n          case \"scroll\":\n            if (value === \"up\") this._region.scroll = \"up\";else badValue = true;\n            break;\n\n          default:\n            this._handleError(this._errorBuilder?._unknownRegionSetting(name, value, line));\n\n        }\n\n        if (badValue) {\n          this._handleError(this._errorBuilder?._badRegionSetting(name, value, line));\n        }\n      }\n    }\n  }\n  /**\n   * @see {@link https://www.w3.org/TR/webvtt1/#cue-timings-and-settings-parsing}\n   */\n\n\n  _parseCueSettings(settings, line) {\n    let badValue;\n\n    for (let i = 0; i < settings.length; i++) {\n      badValue = false;\n\n      if (SETTING_SEP_RE.test(settings[i])) {\n        const [name, value] = settings[i].split(SETTING_SEP_RE);\n\n        switch (name) {\n          case \"region\":\n            const region = this._regions[value];\n            if (region) this._cue.region = region;\n            break;\n\n          case \"vertical\":\n            if (value === \"lr\" || value === \"rl\") {\n              this._cue.vertical = value;\n              this._cue.region = null;\n            } else badValue = true;\n\n            break;\n\n          case \"line\":\n            const [linePos, lineAlign] = value.split(COMMA);\n\n            if (linePos.includes(PERCENT_SIGN)) {\n              const percentage = toPercentage(linePos);\n\n              if (percentage !== null) {\n                this._cue.line = percentage;\n                this._cue.snapToLines = false;\n              } else badValue = true;\n            } else {\n              const number = toFloat(linePos);\n              if (number !== null) this._cue.line = number;else badValue = true;\n            }\n\n            if (LINE_ALIGN_RE.test(lineAlign)) {\n              this._cue.lineAlign = lineAlign;\n            } else if (lineAlign) {\n              badValue = true;\n            }\n\n            if (this._cue.line !== \"auto\") this._cue.region = null;\n            break;\n\n          case \"position\":\n            const [colPos, colAlign] = value.split(COMMA),\n                  position = toPercentage(colPos);\n            if (position !== null) this._cue.position = position;else badValue = true;\n\n            if (colAlign && POS_ALIGN_RE.test(colAlign)) {\n              this._cue.positionAlign = colAlign;\n            } else if (colAlign) {\n              badValue = true;\n            }\n\n            break;\n\n          case \"size\":\n            const size = toPercentage(value);\n\n            if (size !== null) {\n              this._cue.size = size;\n              if (size < 100) this._cue.region = null;\n            } else {\n              badValue = true;\n            }\n\n            break;\n\n          case \"align\":\n            if (ALIGN_RE.test(value)) {\n              this._cue.align = value;\n            } else {\n              badValue = true;\n            }\n\n            break;\n\n          default:\n            this._handleError(this._errorBuilder?._unknownCueSetting(name, value, line));\n\n        }\n\n        if (badValue) {\n          this._handleError(this._errorBuilder?._badCueSetting(name, value, line));\n        }\n      }\n    }\n  }\n\n  _handleError(error) {\n    if (!error) return;\n\n    this._errors.push(error);\n\n    if (this._init.strict) {\n      this._init.cancel();\n\n      throw error;\n    } else {\n      this._init.onError?.(error);\n    }\n  }\n\n}\n\nfunction parseVTTTimestamp(timestamp) {\n  const match = timestamp.match(TIMESTAMP_RE);\n  if (!match) return null;\n  const hours = match[1] ? parseInt(match[1], 10) : 0,\n        minutes = parseInt(match[2], 10),\n        seconds = parseInt(match[3], 10),\n        milliseconds = match[4] ? parseInt(match[4].padEnd(3, \"0\"), 10) : 0,\n        total = hours * 3600 + minutes * 60 + seconds + milliseconds / 1e3;\n\n  if (hours < 0 || minutes < 0 || seconds < 0 || milliseconds < 0 || minutes > 59 || seconds > 59) {\n    return null;\n  }\n\n  return total;\n}\n\nfunction createVTTParser() {\n  return new VTTParser();\n}\n\nvar vttParser = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  VTTBlock: VTTBlock,\n  VTTParser: VTTParser,\n  default: createVTTParser,\n  parseVTTTimestamp: parseVTTTimestamp\n});\nconst DIGIT_RE = /[0-9]/,\n      MULTI_SPACE_RE = /[\\s\\t]+/,\n      TAG_NAME = {\n  c: \"span\",\n  i: \"i\",\n  b: \"b\",\n  u: \"u\",\n  ruby: \"ruby\",\n  rt: \"rt\",\n  v: \"span\",\n  lang: \"span\",\n  timestamp: \"span\"\n},\n      HTML_ENTITIES = {\n  \"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&quot;\": '\"',\n  \"&#39;\": \"'\",\n  \"&nbsp;\": \"\\xA0\",\n  \"&lrm;\": \"\\u200E\",\n  \"&rlm;\": \"\\u200F\"\n},\n      HTML_ENTITY_RE = /&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g,\n      COLORS = /* @__PURE__ */new Set([\"white\", \"lime\", \"cyan\", \"red\", \"yellow\", \"magenta\", \"blue\", \"black\"]),\n      BLOCK_TYPES = /* @__PURE__ */new Set(Object.keys(TAG_NAME));\n\nfunction tokenizeVTTCue(cue) {\n  let buffer = \"\",\n      mode = 1\n  /* Data */\n  ,\n      result = [],\n      stack = [],\n      node;\n\n  for (let i = 0; i < cue.text.length; i++) {\n    const char = cue.text[i];\n\n    switch (mode) {\n      case 1\n      /* Data */\n      :\n        if (char === \"<\") {\n          addText();\n          mode = 2\n          /* Tag */\n          ;\n        } else {\n          buffer += char;\n        }\n\n        break;\n\n      case 2\n      /* Tag */\n      :\n        switch (char) {\n          case \"\\n\":\n          case \"\t\":\n          case \" \":\n            addNode();\n            mode = 4\n            /* Annotation */\n            ;\n            break;\n\n          case \".\":\n            addNode();\n            mode = 3\n            /* Class */\n            ;\n            break;\n\n          case \"/\":\n            mode = 5\n            /* EndTag */\n            ;\n            break;\n\n          case \">\":\n            addNode();\n            mode = 1\n            /* Data */\n            ;\n            break;\n\n          default:\n            if (!buffer && DIGIT_RE.test(char)) mode = 6\n            /* Timestamp */\n            ;\n            buffer += char;\n            break;\n        }\n\n        break;\n\n      case 3\n      /* Class */\n      :\n        switch (char) {\n          case \"\t\":\n          case \" \":\n          case \"\\n\":\n            addClass();\n            if (node) node.class?.trim();\n            mode = 4\n            /* Annotation */\n            ;\n            break;\n\n          case \".\":\n            addClass();\n            break;\n\n          case \">\":\n            addClass();\n            if (node) node.class?.trim();\n            mode = 1\n            /* Data */\n            ;\n            break;\n\n          default:\n            buffer += char;\n        }\n\n        break;\n\n      case 4\n      /* Annotation */\n      :\n        if (char === \">\") {\n          buffer = buffer.replace(MULTI_SPACE_RE, \" \");\n          if (node?.type === \"v\") node.voice = replaceHTMLEntities(buffer);else if (node?.type === \"lang\") node.lang = replaceHTMLEntities(buffer);\n          buffer = \"\";\n          mode = 1\n          /* Data */\n          ;\n        } else {\n          buffer += char;\n        }\n\n        break;\n\n      case 5\n      /* EndTag */\n      :\n        if (char === \">\") {\n          buffer = \"\";\n          node = stack.pop();\n          mode = 1\n          /* Data */\n          ;\n        }\n\n        break;\n\n      case 6\n      /* Timestamp */\n      :\n        if (char === \">\") {\n          const time = parseVTTTimestamp(buffer);\n\n          if (time !== null && time >= cue.startTime && time <= cue.endTime) {\n            buffer = \"timestamp\";\n            addNode();\n            node.time = time;\n          }\n\n          buffer = \"\";\n          mode = 1\n          /* Data */\n          ;\n        } else {\n          buffer += char;\n        }\n\n        break;\n    }\n  }\n\n  function addNode() {\n    if (BLOCK_TYPES.has(buffer)) {\n      const parent = node;\n      node = createBlockNode(buffer);\n\n      if (parent) {\n        if (stack[stack.length - 1] !== parent) stack.push(parent);\n        parent.children.push(node);\n      } else result.push(node);\n    }\n\n    buffer = \"\";\n    mode = 1\n    /* Data */\n    ;\n  }\n\n  function addClass() {\n    if (node && buffer) {\n      const color = buffer.replace(\"bg_\", \"\");\n\n      if (COLORS.has(color)) {\n        node[buffer.startsWith(\"bg_\") ? \"bgColor\" : \"color\"] = color;\n      } else {\n        node.class = !node.class ? buffer : node.class + \" \" + buffer;\n      }\n    }\n\n    buffer = \"\";\n  }\n\n  function addText() {\n    if (!buffer) return;\n    const text = {\n      type: \"text\",\n      data: replaceHTMLEntities(buffer)\n    };\n    node ? node.children.push(text) : result.push(text);\n    buffer = \"\";\n  }\n\n  if (mode === 1\n  /* Data */\n  ) addText();\n  return result;\n}\n\nfunction createBlockNode(type) {\n  return {\n    tagName: TAG_NAME[type],\n    type,\n    children: []\n  };\n}\n\nfunction replaceHTMLEntities(text) {\n  return text.replace(HTML_ENTITY_RE, entity => HTML_ENTITIES[entity] || \"'\");\n}\n\nfunction setCSSVar(el, name, value) {\n  el.style.setProperty(`--${name}`, value + \"\");\n}\n\nfunction setDataAttr(el, name, value = true) {\n  el.setAttribute(`data-${name}`, value === true ? \"\" : value + \"\");\n}\n\nfunction setPartAttr(el, name) {\n  el.setAttribute(\"data-part\", name);\n}\n\nfunction getLineHeight(el) {\n  return parseFloat(getComputedStyle(el).lineHeight) || 0;\n}\n\nfunction createVTTCueTemplate(cue) {\n  const template = document.createElement(\"template\");\n  template.innerHTML = renderVTTCueString(cue);\n  return {\n    cue,\n    content: template.content\n  };\n}\n\nfunction renderVTTCueString(cue, currentTime = 0) {\n  return renderVTTTokensString(tokenizeVTTCue(cue), currentTime);\n}\n\nfunction renderVTTTokensString(tokens, currentTime = 0) {\n  let attrs,\n      result = \"\";\n\n  for (const token of tokens) {\n    if (token.type === \"text\") {\n      result += token.data;\n    } else {\n      const isTimestamp = token.type === \"timestamp\";\n      attrs = {};\n      attrs.class = token.class;\n      attrs.title = token.type === \"v\" && token.voice;\n      attrs.lang = token.type === \"lang\" && token.lang;\n      attrs[\"data-part\"] = token.type === \"v\" && \"voice\";\n\n      if (isTimestamp) {\n        attrs[\"data-part\"] = \"timed\";\n        attrs[\"data-time\"] = token.time;\n        attrs[\"data-future\"] = token.time > currentTime;\n        attrs[\"data-past\"] = token.time < currentTime;\n      }\n\n      attrs.style = `${token.color ? `color: ${token.color};` : \"\"}${token.bgColor ? `background-color: ${token.bgColor};` : \"\"}`;\n      const attributes = Object.entries(attrs).filter(v => v[1]).map(v => `${v[0]}=\"${v[1] === true ? \"\" : v[1]}\"`).join(\" \");\n      result += `<${token.tagName}${attributes ? \" \" + attributes : \"\"}>${renderVTTTokensString(token.children)}</${token.tagName}>`;\n    }\n  }\n\n  return result;\n}\n\nfunction updateTimedVTTCueNodes(root, currentTime) {\n  for (const el of root.querySelectorAll('[data-part=\"timed\"]')) {\n    const time = Number(el.getAttribute(\"data-time\"));\n    if (Number.isNaN(time)) continue;\n    if (time > currentTime) setDataAttr(el, \"future\");else el.removeAttribute(\"data-future\");\n    if (time < currentTime) setDataAttr(el, \"past\");else el.removeAttribute(\"data-past\");\n  }\n}\n\nfunction debounce(fn, delay) {\n  let timeout = null,\n      args;\n\n  function run() {\n    clear();\n    fn(...args);\n    args = void 0;\n  }\n\n  function clear() {\n    clearTimeout(timeout);\n    timeout = null;\n  }\n\n  function debounce2() {\n    args = [].slice.call(arguments);\n    clear();\n    timeout = setTimeout(run, delay);\n  }\n\n  return debounce2;\n}\n\nconst STARTING_BOX = Symbol(\"STARTING_BOX\");\n\nfunction createBox(box) {\n  if (box instanceof HTMLElement) {\n    return {\n      top: box.offsetTop,\n      width: box.clientWidth,\n      height: box.clientHeight,\n      left: box.offsetLeft,\n      right: box.offsetLeft + box.clientWidth,\n      bottom: box.offsetTop + box.clientHeight\n    };\n  }\n\n  return { ...box\n  };\n}\n\nfunction moveBox(box, axis, delta) {\n  switch (axis) {\n    case \"+x\":\n      box.left += delta;\n      box.right += delta;\n      break;\n\n    case \"-x\":\n      box.left -= delta;\n      box.right -= delta;\n      break;\n\n    case \"+y\":\n      box.top += delta;\n      box.bottom += delta;\n      break;\n\n    case \"-y\":\n      box.top -= delta;\n      box.bottom -= delta;\n      break;\n  }\n}\n\nfunction isBoxCollision(a, b) {\n  return a.left <= b.right && a.right >= b.left && a.top <= b.bottom && a.bottom >= b.top;\n}\n\nfunction isAnyBoxCollision(box, boxes) {\n  for (let i = 0; i < boxes.length; i++) if (isBoxCollision(box, boxes[i])) return boxes[i];\n\n  return null;\n}\n\nfunction isWithinBox(container, box) {\n  return box.top >= 0 && box.bottom <= container.height && box.left >= 0 && box.right <= container.width;\n}\n\nfunction isBoxOutOfBounds(container, box, axis) {\n  switch (axis) {\n    case \"+x\":\n      return box.left < 0;\n\n    case \"-x\":\n      return box.right > container.width;\n\n    case \"+y\":\n      return box.top < 0;\n\n    case \"-y\":\n      return box.bottom > container.height;\n  }\n}\n\nfunction calcBoxIntersectPercentage(container, box) {\n  const x = Math.max(0, Math.min(container.width, box.right) - Math.max(0, box.left)),\n        y = Math.max(0, Math.min(container.height, box.bottom) - Math.max(0, box.top)),\n        intersectArea = x * y;\n  return intersectArea / (container.height * container.width);\n}\n\nfunction createCSSBox(container, box) {\n  return {\n    top: box.top / container.height,\n    left: box.left / container.width,\n    right: (container.width - box.right) / container.width,\n    bottom: (container.height - box.bottom) / container.height\n  };\n}\n\nfunction resolveRelativeBox(container, box) {\n  box.top = box.top * container.height;\n  box.left = box.left * container.width;\n  box.right = container.width - box.right * container.width;\n  box.bottom = container.height - box.bottom * container.height;\n  return box;\n}\n\nconst BOX_SIDES = [\"top\", \"left\", \"right\", \"bottom\"];\n\nfunction setBoxCSSVars(el, container, box, prefix) {\n  const cssBox = createCSSBox(container, box);\n\n  for (const side of BOX_SIDES) {\n    setCSSVar(el, `${prefix}-${side}`, cssBox[side] * 100 + \"%\");\n  }\n}\n\nfunction avoidBoxCollisions(container, box, boxes, axis) {\n  let percentage = 1,\n      positionedBox,\n      startBox = { ...box\n  };\n\n  for (let i = 0; i < axis.length; i++) {\n    while (isBoxOutOfBounds(container, box, axis[i]) || isWithinBox(container, box) && isAnyBoxCollision(box, boxes)) {\n      moveBox(box, axis[i], 1);\n    }\n\n    if (isWithinBox(container, box)) return box;\n    const intersection = calcBoxIntersectPercentage(container, box);\n\n    if (percentage > intersection) {\n      positionedBox = { ...box\n      };\n      percentage = intersection;\n    }\n\n    box = { ...startBox\n    };\n  }\n\n  return positionedBox || startBox;\n}\n\nconst POSITION_OVERRIDE = Symbol(\"POSITION_OVERRIDE\");\n\nfunction positionCue(container, cue, displayEl, boxes) {\n  let cueEl = displayEl.firstElementChild,\n      line = computeCueLine(cue),\n      displayBox,\n      axis = [];\n\n  if (!displayEl[STARTING_BOX]) {\n    displayEl[STARTING_BOX] = createStartingBox(container, displayEl);\n  }\n\n  displayBox = resolveRelativeBox(container, { ...displayEl[STARTING_BOX]\n  });\n\n  if (displayEl[POSITION_OVERRIDE]) {\n    axis = [displayEl[POSITION_OVERRIDE] === \"top\" ? \"+y\" : \"-y\", \"+x\", \"-x\"];\n  } else if (cue.snapToLines) {\n    let size;\n\n    switch (cue.vertical) {\n      case \"\":\n        axis = [\"+y\", \"-y\"];\n        size = \"height\";\n        break;\n\n      case \"rl\":\n        axis = [\"+x\", \"-x\"];\n        size = \"width\";\n        break;\n\n      case \"lr\":\n        axis = [\"-x\", \"+x\"];\n        size = \"width\";\n        break;\n    }\n\n    let step = getLineHeight(cueEl),\n        position = step * Math.round(line),\n        maxPosition = container[size] + step,\n        initialAxis = axis[0];\n\n    if (Math.abs(position) > maxPosition) {\n      position = position < 0 ? -1 : 1;\n      position *= Math.ceil(maxPosition / step) * step;\n    }\n\n    if (line < 0) {\n      position += cue.vertical === \"\" ? container.height : container.width;\n      axis = axis.reverse();\n    }\n\n    moveBox(displayBox, initialAxis, position);\n  } else {\n    const isHorizontal = cue.vertical === \"\",\n          posAxis = isHorizontal ? \"+y\" : \"+x\",\n          size = isHorizontal ? displayBox.height : displayBox.width;\n    moveBox(displayBox, posAxis, (isHorizontal ? container.height : container.width) * line / 100);\n    moveBox(displayBox, posAxis, cue.lineAlign === \"center\" ? size / 2 : cue.lineAlign === \"end\" ? size : 0);\n    axis = isHorizontal ? [\"-y\", \"+y\", \"-x\", \"+x\"] : [\"-x\", \"+x\", \"-y\", \"+y\"];\n  }\n\n  displayBox = avoidBoxCollisions(container, displayBox, boxes, axis);\n  setBoxCSSVars(displayEl, container, displayBox, \"cue\");\n  return displayBox;\n}\n\nfunction createStartingBox(container, cueEl) {\n  const box = createBox(cueEl),\n        pos = getStyledPositions(cueEl);\n  cueEl[POSITION_OVERRIDE] = false;\n\n  if (pos.top) {\n    box.top = pos.top;\n    box.bottom = pos.top + box.height;\n    cueEl[POSITION_OVERRIDE] = \"top\";\n  }\n\n  if (pos.bottom) {\n    const bottom = container.height - pos.bottom;\n    box.top = bottom - box.height;\n    box.bottom = bottom;\n    cueEl[POSITION_OVERRIDE] = \"bottom\";\n  }\n\n  if (pos.left) box.left = pos.left;\n  if (pos.right) box.right = container.width - pos.right;\n  return createCSSBox(container, box);\n}\n\nfunction getStyledPositions(el) {\n  const positions = {};\n\n  for (const side of BOX_SIDES) {\n    positions[side] = parseFloat(el.style.getPropertyValue(`--cue-${side}`));\n  }\n\n  return positions;\n}\n\nfunction computeCueLine(cue) {\n  if (cue.line === \"auto\") {\n    if (!cue.snapToLines) {\n      return 100;\n    } else {\n      return -1;\n    }\n  }\n\n  return cue.line;\n}\n\nfunction computeCuePosition(cue) {\n  if (cue.position === \"auto\") {\n    switch (cue.align) {\n      case \"start\":\n      case \"left\":\n        return 0;\n\n      case \"right\":\n      case \"end\":\n        return 100;\n\n      default:\n        return 50;\n    }\n  }\n\n  return cue.position;\n}\n\nfunction computeCuePositionAlignment(cue, dir) {\n  if (cue.positionAlign === \"auto\") {\n    switch (cue.align) {\n      case \"start\":\n        return dir === \"ltr\" ? \"line-left\" : \"line-right\";\n\n      case \"end\":\n        return dir === \"ltr\" ? \"line-right\" : \"line-left\";\n\n      case \"center\":\n        return \"center\";\n\n      default:\n        return `line-${cue.align}`;\n    }\n  }\n\n  return cue.positionAlign;\n}\n\nconst REGION_AXIS = [\"-y\", \"+y\", \"-x\", \"+x\"];\n\nfunction positionRegion(container, region, regionEl, boxes) {\n  let cues = Array.from(regionEl.querySelectorAll('[data-part=\"cue-display\"]')),\n      height = 0,\n      limit = Math.max(0, cues.length - region.lines);\n\n  for (let i = cues.length - 1; i >= limit; i--) {\n    height += cues[i].offsetHeight;\n  }\n\n  setCSSVar(regionEl, \"region-height\", height + \"px\");\n\n  if (!regionEl[STARTING_BOX]) {\n    regionEl[STARTING_BOX] = createCSSBox(container, createBox(regionEl));\n  }\n\n  let box = { ...regionEl[STARTING_BOX]\n  };\n  box = resolveRelativeBox(container, box);\n  box.width = regionEl.clientWidth;\n  box.height = height;\n  box.right = box.left + box.width;\n  box.bottom = box.top + height;\n  box = avoidBoxCollisions(container, box, boxes, REGION_AXIS);\n  setBoxCSSVars(regionEl, container, box, \"region\");\n  return box;\n}\n\nclass CaptionsRenderer {\n  /* Text direction. */\n  get dir() {\n    return this._dir;\n  }\n\n  set dir(dir) {\n    this._dir = dir;\n    setDataAttr(this.overlay, \"dir\", dir);\n  }\n\n  get currentTime() {\n    return this._currentTime;\n  }\n\n  set currentTime(time) {\n    this._currentTime = time;\n    this.update();\n  }\n\n  constructor(overlay, init) {\n    _defineProperty(this, \"overlay\", void 0);\n\n    _defineProperty(this, \"_overlayBox\", void 0);\n\n    _defineProperty(this, \"_currentTime\", 0);\n\n    _defineProperty(this, \"_dir\", \"ltr\");\n\n    _defineProperty(this, \"_activeCues\", []);\n\n    _defineProperty(this, \"_isResizing\", false);\n\n    _defineProperty(this, \"_resizeObserver\", void 0);\n\n    _defineProperty(this, \"_regions\", /* @__PURE__ */new Map());\n\n    _defineProperty(this, \"_cues\", /* @__PURE__ */new Map());\n\n    _defineProperty(this, \"_resize\", debounce(() => {\n      this._isResizing = false;\n\n      this._updateOverlay();\n\n      for (const el of this._regions.values()) {\n        el[STARTING_BOX] = null;\n      }\n\n      for (const el of this._cues.values()) {\n        if (el) el[STARTING_BOX] = null;\n      }\n\n      this._render(true);\n    }, 50));\n\n    this.overlay = overlay;\n    this.dir = init?.dir ?? \"ltr\";\n    overlay.setAttribute(\"translate\", \"yes\");\n    overlay.setAttribute(\"aria-live\", \"off\");\n    overlay.setAttribute(\"aria-atomic\", \"true\");\n    setPartAttr(overlay, \"captions\");\n\n    this._updateOverlay();\n\n    this._resizeObserver = new ResizeObserver(this._resizing.bind(this));\n\n    this._resizeObserver.observe(overlay);\n  }\n\n  changeTrack({\n    regions,\n    cues\n  }) {\n    this.reset();\n\n    this._buildRegions(regions);\n\n    for (const cue of cues) this._cues.set(cue, null);\n\n    this.update();\n  }\n\n  addCue(cue) {\n    this._cues.set(cue, null);\n\n    this.update();\n  }\n\n  removeCue(cue) {\n    this._cues.delete(cue);\n\n    this.update();\n  }\n\n  update(forceUpdate = false) {\n    this._render(forceUpdate);\n  }\n\n  reset() {\n    this._cues.clear();\n\n    this._regions.clear();\n\n    this._activeCues = [];\n    this.overlay.textContent = \"\";\n  }\n\n  destroy() {\n    this.reset();\n\n    this._resizeObserver.disconnect();\n  }\n\n  _resizing() {\n    this._isResizing = true;\n\n    this._resize();\n  }\n\n  _updateOverlay() {\n    this._overlayBox = createBox(this.overlay);\n    setCSSVar(this.overlay, \"overlay-width\", this._overlayBox.width + \"px\");\n    setCSSVar(this.overlay, \"overlay-height\", this._overlayBox.height + \"px\");\n  }\n\n  _render(forceUpdate = false) {\n    if (!this._cues.size || this._isResizing) return;\n    let cue,\n        activeCues = [...this._cues.keys()].filter(cue2 => this._currentTime >= cue2.startTime && this._currentTime <= cue2.endTime).sort((cueA, cueB) => cueA.startTime !== cueB.startTime ? cueA.startTime - cueB.startTime : cueA.endTime - cueB.endTime),\n        activeRegions = activeCues.map(cue2 => cue2.region);\n\n    for (let i = 0; i < this._activeCues.length; i++) {\n      cue = this._activeCues[i];\n      if (activeCues[i] === cue) continue;\n\n      if (cue.region && !activeRegions.includes(cue.region)) {\n        const regionEl = this._regions.get(cue.region.id);\n\n        if (regionEl) {\n          regionEl.removeAttribute(\"data-active\");\n          forceUpdate = true;\n        }\n      }\n\n      const cueEl = this._cues.get(cue);\n\n      if (cueEl) {\n        cueEl.remove();\n        forceUpdate = true;\n      }\n    }\n\n    for (let i = 0; i < activeCues.length; i++) {\n      cue = activeCues[i];\n\n      let cueEl = this._cues.get(cue);\n\n      if (!cueEl) this._cues.set(cue, cueEl = this._createCueElement(cue));\n\n      const regionEl = this._hasRegion(cue) && this._regions.get(cue.region.id);\n\n      if (regionEl && !regionEl.hasAttribute(\"data-active\")) {\n        requestAnimationFrame(() => setDataAttr(regionEl, \"active\"));\n        forceUpdate = true;\n      }\n\n      if (!cueEl.isConnected) {\n        (regionEl || this.overlay).append(cueEl);\n        forceUpdate = true;\n      }\n    }\n\n    if (forceUpdate) {\n      const boxes = [],\n            seen = /* @__PURE__ */new Set();\n\n      for (let i = activeCues.length - 1; i >= 0; i--) {\n        cue = activeCues[i];\n        if (seen.has(cue.region || cue)) continue;\n\n        const isRegion = this._hasRegion(cue),\n              el = isRegion ? this._regions.get(cue.region.id) : this._cues.get(cue);\n\n        if (isRegion) {\n          boxes.push(positionRegion(this._overlayBox, cue.region, el, boxes));\n        } else {\n          boxes.push(positionCue(this._overlayBox, cue, el, boxes));\n        }\n\n        seen.add(isRegion ? cue.region : cue);\n      }\n    }\n\n    updateTimedVTTCueNodes(this.overlay, this._currentTime);\n    this._activeCues = activeCues;\n  }\n\n  _buildRegions(regions) {\n    if (!regions) return;\n\n    for (const region of regions) {\n      const el = this._createRegionElement(region);\n\n      this._regions.set(region.id, el);\n\n      this.overlay.append(el);\n    }\n  }\n\n  _createRegionElement(region) {\n    const el = document.createElement(\"div\");\n    setPartAttr(el, \"region\");\n    setDataAttr(el, \"id\", region.id);\n    setDataAttr(el, \"scroll\", region.scroll);\n    setCSSVar(el, \"region-width\", region.width + \"%\");\n    setCSSVar(el, \"region-anchor-x\", region.regionAnchorX);\n    setCSSVar(el, \"region-anchor-y\", region.regionAnchorY);\n    setCSSVar(el, \"region-viewport-anchor-x\", region.viewportAnchorX);\n    setCSSVar(el, \"region-viewport-anchor-y\", region.viewportAnchorY);\n    setCSSVar(el, \"region-lines\", region.lines);\n    return el;\n  }\n\n  _createCueElement(cue) {\n    const display = document.createElement(\"div\"),\n          position = computeCuePosition(cue),\n          positionAlignment = computeCuePositionAlignment(cue, this._dir);\n    setPartAttr(display, \"cue-display\");\n    if (cue.vertical !== \"\") setDataAttr(display, \"vertical\");\n    setCSSVar(display, \"cue-text-align\", cue.align);\n\n    if (cue.style) {\n      for (const prop of Object.keys(cue.style)) {\n        display.style.setProperty(prop, cue.style[prop]);\n      }\n    }\n\n    if (!this._hasRegion(cue)) {\n      setCSSVar(display, \"cue-writing-mode\", cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\");\n\n      if (!cue.style?.[\"--cue-width\"]) {\n        let maxSize = position;\n\n        if (positionAlignment === \"line-left\") {\n          maxSize = 100 - position;\n        } else if (positionAlignment === \"center\" && position <= 50) {\n          maxSize = position * 2;\n        } else if (positionAlignment === \"center\" && position > 50) {\n          maxSize = (100 - position) * 2;\n        }\n\n        const size = cue.size < maxSize ? cue.size : maxSize;\n        if (cue.vertical === \"\") setCSSVar(display, \"cue-width\", size + \"%\");else setCSSVar(display, \"cue-height\", size + \"%\");\n      }\n    } else {\n      setCSSVar(display, \"cue-offset\", `${position - (positionAlignment === \"line-right\" ? 100 : positionAlignment === \"center\" ? 50 : 0)}%`);\n    }\n\n    const el = document.createElement(\"div\");\n    setPartAttr(el, \"cue\");\n    if (cue.id) setDataAttr(el, \"id\", cue.id);\n    el.innerHTML = renderVTTCueString(cue);\n    display.append(el);\n    return display;\n  }\n\n  _hasRegion(cue) {\n    return cue.region && cue.size === 100 && cue.vertical === \"\" && cue.line === \"auto\";\n  }\n\n}\n\nexport { CaptionsRenderer as C, ParseError as P, TextCue as T, VTTParser as V, VTTBlock as a, VTTCue as b, ParseErrorCode as c, parseResponse as d, parseByteStream as e, parseText as f, parseTextStream as g, VTTRegion as h, createVTTCueTemplate as i, renderVTTTokensString as j, parseVTTTimestamp as p, renderVTTCueString as r, tokenizeVTTCue as t, updateTimedVTTCueNodes as u };","map":{"version":3,"sources":["/home/ann/dev/studip/54/public/plugins_packages/RasmusFuhse/LernmodulePlugin/vue/node_modules/media-captions/dist/dev/index.js"],"names":["ParseErrorCode","LoadFail","BadSignature","BadTimestamp","BadSettingValue","BadFormat","UnknownSetting","ParseError","Error","constructor","init","reason","code","line","LINE_TERMINATOR_RE","TextLineTransformStream","encoding","transformer","TextStreamLineIterator","writable","WritableStream","write","chunk","transform","close","readable","ReadableStream","start","controller","onLine","enqueue","onClose","_decoder","TextDecoder","_buffer","decode","stream","lines","split","pop","i","length","trim","parseText","text","options","parseTextStream","type","factory","default","Promise","resolve","then","vttParser","result","reader","getReader","parser","errors","strict","cancel","done","value","read","parse","parseResponse","response","res","ok","body","error","status","onError","metadata","cues","regions","contentType","headers","get","match","parseByteStream","textStream","pipeThrough","TextCue","EventTarget","startTime","endTime","addEventListener","listener","removeEventListener","CueBase","window","VTTCue","VTTRegion","COMMA$1","PERCENT_SIGN$1","toNumber","num","parseInt","Number","isNaN","toPercentage","replace","toCoords","includes","x","y","map","toFloat","parseFloat","HEADER_MAGIC","COMMA","PERCENT_SIGN","SETTING_SEP_RE","SETTING_LINE_RE","NOTE_BLOCK_START","REGION_BLOCK_START","REGION_BLOCK_START_RE","SPACE_RE","TIMESTAMP_SEP","TIMESTAMP_SEP_RE","ALIGN_RE","LINE_ALIGN_RE","POS_ALIGN_RE","TIMESTAMP_RE","VTTBlock","VTTBlock2","VTTParser","_init","_block","_errorBuilder","ParseErrorBuilder","lineCount","_cue","_cues","push","onCue","_region","_regions","id","onRegion","_parseHeader","onHeaderMetadata","_metadata","hasText","test","_parseCueSettings","_parseRegionSettings","startsWith","_parseTimestamp","_prevLine","Object","values","_errors","key","_handleError","_badVTTHeader","startTimeText","trailingText","endTimeText","settingsText","parseVTTTimestamp","_badStartTimestamp","_badEndTimestamp","_badRangeTimestamp","settings","badValue","name","width","region","regionAnchorX","regionAnchorY","viewport","viewportAnchorX","viewportAnchorY","scroll","_unknownRegionSetting","_badRegionSetting","vertical","linePos","lineAlign","percentage","snapToLines","number","colPos","colAlign","position","positionAlign","size","align","_unknownCueSetting","_badCueSetting","timestamp","hours","minutes","seconds","milliseconds","padEnd","total","createVTTParser","freeze","__proto__","DIGIT_RE","MULTI_SPACE_RE","TAG_NAME","c","b","u","ruby","rt","v","lang","HTML_ENTITIES","HTML_ENTITY_RE","COLORS","Set","BLOCK_TYPES","keys","tokenizeVTTCue","cue","buffer","mode","stack","node","char","addText","addNode","addClass","class","voice","replaceHTMLEntities","time","has","parent","createBlockNode","children","color","data","tagName","entity","setCSSVar","el","style","setProperty","setDataAttr","setAttribute","setPartAttr","getLineHeight","getComputedStyle","lineHeight","createVTTCueTemplate","template","document","createElement","innerHTML","renderVTTCueString","content","currentTime","renderVTTTokensString","tokens","attrs","token","isTimestamp","title","bgColor","attributes","entries","filter","join","updateTimedVTTCueNodes","root","querySelectorAll","getAttribute","removeAttribute","debounce","fn","delay","timeout","args","run","clear","clearTimeout","debounce2","slice","call","arguments","setTimeout","STARTING_BOX","Symbol","createBox","box","HTMLElement","top","offsetTop","clientWidth","height","clientHeight","left","offsetLeft","right","bottom","moveBox","axis","delta","isBoxCollision","a","isAnyBoxCollision","boxes","isWithinBox","container","isBoxOutOfBounds","calcBoxIntersectPercentage","Math","max","min","intersectArea","createCSSBox","resolveRelativeBox","BOX_SIDES","setBoxCSSVars","prefix","cssBox","side","avoidBoxCollisions","positionedBox","startBox","intersection","POSITION_OVERRIDE","positionCue","displayEl","cueEl","firstElementChild","computeCueLine","displayBox","createStartingBox","step","round","maxPosition","initialAxis","abs","ceil","reverse","isHorizontal","posAxis","pos","getStyledPositions","positions","getPropertyValue","computeCuePosition","computeCuePositionAlignment","dir","REGION_AXIS","positionRegion","regionEl","Array","from","limit","offsetHeight","CaptionsRenderer","_dir","overlay","_currentTime","update","Map","_isResizing","_updateOverlay","_render","_resizeObserver","ResizeObserver","_resizing","bind","observe","changeTrack","reset","_buildRegions","set","addCue","removeCue","delete","forceUpdate","_activeCues","textContent","destroy","disconnect","_resize","_overlayBox","activeCues","cue2","sort","cueA","cueB","activeRegions","remove","_createCueElement","_hasRegion","hasAttribute","requestAnimationFrame","isConnected","append","seen","isRegion","add","_createRegionElement","display","positionAlignment","prop","maxSize","C","P","T","V","d","e","f","g","h","j","p","r","t"],"mappings":"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","sourcesContent":["const ParseErrorCode = {\n  LoadFail: 0,\n  BadSignature: 1,\n  BadTimestamp: 2,\n  BadSettingValue: 3,\n  BadFormat: 4,\n  UnknownSetting: 5\n};\nclass ParseError extends Error {\n  code;\n  line;\n  constructor(init) {\n    super(init.reason);\n    this.code = init.code;\n    this.line = init.line;\n  }\n}\n\nconst LINE_TERMINATOR_RE = /\\r?\\n|\\r/gm;\nclass TextLineTransformStream {\n  writable;\n  readable;\n  constructor(encoding) {\n    const transformer = new TextStreamLineIterator(encoding);\n    this.writable = new WritableStream({\n      write(chunk) {\n        transformer.transform(chunk);\n      },\n      close() {\n        transformer.close();\n      }\n    });\n    this.readable = new ReadableStream({\n      start(controller) {\n        transformer.onLine = (line) => controller.enqueue(line);\n        transformer.onClose = () => controller.close();\n      }\n    });\n  }\n}\nclass TextStreamLineIterator {\n  _buffer = \"\";\n  _decoder;\n  onLine;\n  onClose;\n  constructor(encoding) {\n    this._decoder = new TextDecoder(encoding);\n  }\n  transform(chunk) {\n    this._buffer += this._decoder.decode(chunk, { stream: true });\n    const lines = this._buffer.split(LINE_TERMINATOR_RE);\n    this._buffer = lines.pop() || \"\";\n    for (let i = 0; i < lines.length; i++)\n      this.onLine(lines[i].trim());\n  }\n  close() {\n    if (this._buffer)\n      this.onLine(this._buffer.trim());\n    this._buffer = \"\";\n    this.onClose();\n  }\n}\n\nasync function parseText(text, options) {\n  const stream = new ReadableStream({\n    start(controller) {\n      const lines = text.split(LINE_TERMINATOR_RE);\n      for (const line of lines)\n        controller.enqueue(line);\n      controller.close();\n    }\n  });\n  return parseTextStream(stream, options);\n}\nasync function parseTextStream(stream, options) {\n  const type = options?.type ?? \"vtt\";\n  let factory;\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"srt\":\n        factory = (await import('./srt-parser.js')).default;\n        break;\n      case \"ssa\":\n      case \"ass\":\n        factory = (await import('./ssa-parser.js')).default;\n        break;\n      default:\n        factory = (await Promise.resolve().then(function () { return vttParser; })).default;\n    }\n  } else {\n    factory = type;\n  }\n  let result;\n  const reader = stream.getReader(), parser = factory(), errors = options?.errors !== false || !!options?.strict || !!options?.errors;\n  await parser.init({\n    strict: false,\n    ...options,\n    errors,\n    type,\n    cancel() {\n      reader.cancel();\n      result = parser.done(true);\n    }\n  });\n  let i = 1;\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) {\n      parser.parse(\"\", i);\n      result = parser.done(false);\n      break;\n    }\n    parser.parse(value, i);\n    i++;\n  }\n  return result;\n}\n\nasync function parseResponse(response, options) {\n  const res = await response;\n  if (!res.ok || !res.body) {\n    let error;\n    {\n      error = new ParseError({\n        code: ParseErrorCode.LoadFail,\n        reason: !res.ok ? `response is not ok (status: ${res.status})` : `response body is missing (status: ${res.status})`,\n        line: -1\n      });\n      options?.onError?.(error);\n    }\n    return {\n      metadata: {},\n      cues: [],\n      regions: [],\n      errors: [error]\n    };\n  }\n  const contentType = res.headers.get(\"content-type\") || \"\", type = contentType.match(/text\\/(.*?)(?:;|$)/)?.[1], encoding = contentType.match(/charset=(.*?)(?:;|$)/)?.[1];\n  return parseByteStream(res.body, { type, encoding, ...options });\n}\nasync function parseByteStream(stream, { encoding = \"utf-8\", ...options } = {}) {\n  const textStream = stream.pipeThrough(new TextLineTransformStream(encoding));\n  return parseTextStream(textStream, options);\n}\n\nclass TextCue extends EventTarget {\n  /**\n   * A string that identifies the cue.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/id}\n   */\n  id = \"\";\n  /**\n   * A `double` that represents the video time that the cue will start being displayed, in seconds.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/startTime}\n   */\n  startTime;\n  /**\n   * A `double` that represents the video time that the cue will stop being displayed, in seconds.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/endTime}\n   */\n  endTime;\n  /**\n   * Returns a string with the contents of the cue.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/text}\n   */\n  text;\n  /**\n   * A `boolean` for whether the video will pause when this cue stops being displayed.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/pauseOnExit}\n   */\n  pauseOnExit = false;\n  constructor(startTime, endTime, text) {\n    super();\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.text = text;\n  }\n  addEventListener(type, listener, options) {\n    super.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    super.removeEventListener(type, listener, options);\n  }\n}\n\nconst CueBase = window.VTTCue;\nclass VTTCue extends CueBase {\n  /**\n   * A `VTTRegion` object describing the video's sub-region that the cue will be drawn onto,\n   * or `null` if none is assigned.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/region}\n   */\n  region = null;\n  /**\n   * The cue writing direction.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/vertical}\n   */\n  vertical = \"\";\n  /**\n   * Returns `true` if the `VTTCue.line` attribute is an integer number of lines or a percentage\n   * of the video size.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/snapToLines}\n   */\n  snapToLines = true;\n  /**\n   * Returns the line positioning of the cue. This can be the string `'auto'` or a number whose\n   * interpretation depends on the value of `VTTCue.snapToLines`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/line}\n   */\n  line = \"auto\";\n  /**\n   * Returns an enum representing the alignment of the `VTTCue.line`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/lineAlign}\n   */\n  lineAlign = \"start\";\n  /**\n   * Returns the indentation of the cue within the line. This can be the string `'auto'` or a\n   * number representing the percentage of the `VTTCue.region`, or the video size if `VTTCue`.region`\n   * is `null`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/position}\n   */\n  position = \"auto\";\n  /**\n   * Returns an enum representing the alignment of the cue. This is used to determine what\n   * the `VTTCue.position` is anchored to. The default is `'auto'`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/positionAlign}\n   */\n  positionAlign = \"auto\";\n  /**\n   * Returns a double representing the size of the cue, as a percentage of the video size.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/size}\n   */\n  size = 100;\n  /**\n   * Returns an enum representing the alignment of all the lines of text within the cue box.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/align}\n   */\n  align = \"center\";\n  /**\n   * Additional styles associated with the cue.\n   */\n  style;\n}\n\nclass VTTRegion {\n  /**\n   * A string that identifies the region.\n   */\n  id = \"\";\n  /**\n   * A `double` representing the width of the region, as a percentage of the video.\n   */\n  width = 100;\n  /**\n   * A `double` representing the height of the region, in number of lines.\n   */\n  lines = 3;\n  /**\n   * A `double` representing the region anchor X offset, as a percentage of the region.\n   */\n  regionAnchorX = 0;\n  /**\n   * A `double` representing the region anchor Y offset, as a percentage of the region.\n   */\n  regionAnchorY = 100;\n  /**\n   * A `double` representing the viewport anchor X offset, as a percentage of the video.\n   */\n  viewportAnchorX = 0;\n  /**\n   * A `double` representing the viewport anchor Y offset, as a percentage of the video.\n   */\n  viewportAnchorY = 100;\n  /**\n   * An enum representing how adding new cues will move existing cues.\n   */\n  scroll = \"\";\n}\n\nconst COMMA$1 = \",\", PERCENT_SIGN$1 = \"%\";\nfunction toNumber(text) {\n  const num = parseInt(text, 10);\n  return !Number.isNaN(num) ? num : null;\n}\nfunction toPercentage(text) {\n  const num = parseInt(text.replace(PERCENT_SIGN$1, \"\"), 10);\n  return !Number.isNaN(num) && num >= 0 && num <= 100 ? num : null;\n}\nfunction toCoords(text) {\n  if (!text.includes(COMMA$1))\n    return null;\n  const [x, y] = text.split(COMMA$1).map(toPercentage);\n  return x !== null && y !== null ? [x, y] : null;\n}\nfunction toFloat(text) {\n  const num = parseFloat(text);\n  return !Number.isNaN(num) ? num : null;\n}\n\nconst HEADER_MAGIC = \"WEBVTT\", COMMA = \",\", PERCENT_SIGN = \"%\", SETTING_SEP_RE = /[:=]/, SETTING_LINE_RE = /^[\\s\\t]*(region|vertical|line|position|size|align)[:=]/, NOTE_BLOCK_START = \"NOTE\", REGION_BLOCK_START = \"REGION\", REGION_BLOCK_START_RE = /^REGION:?[\\s\\t]+/, SPACE_RE = /[\\s\\t]+/, TIMESTAMP_SEP = \"-->\", TIMESTAMP_SEP_RE = /[\\s\\t]*-->[\\s\\t]+/, ALIGN_RE = /start|center|end|left|right/, LINE_ALIGN_RE = /start|center|end/, POS_ALIGN_RE = /line-(?:left|right)|center|auto/, TIMESTAMP_RE = /^(?:(\\d{1,2}):)?(\\d{2}):(\\d{2})(?:\\.(\\d{1,3}))?$/;\nvar VTTBlock = /* @__PURE__ */ ((VTTBlock2) => {\n  VTTBlock2[VTTBlock2[\"None\"] = 0] = \"None\";\n  VTTBlock2[VTTBlock2[\"Header\"] = 1] = \"Header\";\n  VTTBlock2[VTTBlock2[\"Cue\"] = 2] = \"Cue\";\n  VTTBlock2[VTTBlock2[\"Region\"] = 3] = \"Region\";\n  VTTBlock2[VTTBlock2[\"Note\"] = 4] = \"Note\";\n  return VTTBlock2;\n})(VTTBlock || {});\nclass VTTParser {\n  _init;\n  _block = 0 /* None */;\n  _metadata = {};\n  _regions = {};\n  _cues = [];\n  _cue = null;\n  _region = null;\n  _errors = [];\n  _errorBuilder;\n  _prevLine = \"\";\n  async init(init) {\n    this._init = init;\n    if (init.strict)\n      this._block = 1 /* Header */;\n    if (init.errors)\n      this._errorBuilder = (await import('./errors.js')).ParseErrorBuilder;\n  }\n  parse(line, lineCount) {\n    if (line === \"\") {\n      if (this._cue) {\n        this._cues.push(this._cue);\n        this._init.onCue?.(this._cue);\n        this._cue = null;\n      } else if (this._region) {\n        this._regions[this._region.id] = this._region;\n        this._init.onRegion?.(this._region);\n        this._region = null;\n      } else if (this._block === 1 /* Header */) {\n        this._parseHeader(line, lineCount);\n        this._init.onHeaderMetadata?.(this._metadata);\n      }\n      this._block = 0 /* None */;\n    } else if (this._block) {\n      switch (this._block) {\n        case 1 /* Header */:\n          this._parseHeader(line, lineCount);\n          break;\n        case 2 /* Cue */:\n          if (this._cue) {\n            const hasText = this._cue.text.length > 0;\n            if (!hasText && SETTING_LINE_RE.test(line)) {\n              this._parseCueSettings(line.split(SPACE_RE), lineCount);\n            } else {\n              this._cue.text += (hasText ? \"\\n\" : \"\") + line;\n            }\n          }\n          break;\n        case 3 /* Region */:\n          this._parseRegionSettings(line.split(SPACE_RE), lineCount);\n          break;\n      }\n    } else if (line.startsWith(NOTE_BLOCK_START)) {\n      this._block = 4 /* Note */;\n    } else if (line.startsWith(REGION_BLOCK_START)) {\n      this._block = 3 /* Region */;\n      this._region = new VTTRegion();\n      this._parseRegionSettings(line.replace(REGION_BLOCK_START_RE, \"\").split(SPACE_RE), lineCount);\n    } else if (line.includes(TIMESTAMP_SEP)) {\n      const result = this._parseTimestamp(line, lineCount);\n      if (result) {\n        this._cue = new VTTCue(result[0], result[1], \"\");\n        this._cue.id = this._prevLine;\n        this._parseCueSettings(result[2], lineCount);\n      }\n      this._block = 2 /* Cue */;\n    } else if (lineCount === 1) {\n      this._parseHeader(line, lineCount);\n    }\n    this._prevLine = line;\n  }\n  done() {\n    return {\n      metadata: this._metadata,\n      cues: this._cues,\n      regions: Object.values(this._regions),\n      errors: this._errors\n    };\n  }\n  _parseHeader(line, lineCount) {\n    if (lineCount > 1) {\n      if (SETTING_SEP_RE.test(line)) {\n        const [key, value] = line.split(SETTING_SEP_RE);\n        if (key)\n          this._metadata[key] = (value || \"\").replace(SPACE_RE, \"\");\n      }\n    } else if (line.startsWith(HEADER_MAGIC)) {\n      this._block = 1 /* Header */;\n    } else {\n      this._handleError(this._errorBuilder?._badVTTHeader());\n    }\n  }\n  _parseTimestamp(line, lineCount) {\n    const [startTimeText, trailingText = \"\"] = line.split(TIMESTAMP_SEP_RE), [endTimeText, ...settingsText] = trailingText.split(SPACE_RE), startTime = parseVTTTimestamp(startTimeText), endTime = parseVTTTimestamp(endTimeText);\n    if (startTime !== null && endTime !== null && endTime > startTime) {\n      return [startTime, endTime, settingsText];\n    } else {\n      if (startTime === null) {\n        this._handleError(this._errorBuilder?._badStartTimestamp(startTimeText, lineCount));\n      }\n      if (endTime === null) {\n        this._handleError(this._errorBuilder?._badEndTimestamp(endTimeText, lineCount));\n      }\n      if (startTime != null && endTime !== null && endTime > startTime) {\n        this._handleError(this._errorBuilder?._badRangeTimestamp(startTime, endTime, lineCount));\n      }\n    }\n  }\n  /**\n   * @see {@link https://www.w3.org/TR/webvtt1/#region-settings-parsing}\n   */\n  _parseRegionSettings(settings, line) {\n    let badValue;\n    for (let i = 0; i < settings.length; i++) {\n      if (SETTING_SEP_RE.test(settings[i])) {\n        badValue = false;\n        const [name, value] = settings[i].split(SETTING_SEP_RE);\n        switch (name) {\n          case \"id\":\n            this._region.id = value;\n            break;\n          case \"width\":\n            const width = toPercentage(value);\n            if (width !== null)\n              this._region.width = width;\n            else\n              badValue = true;\n            break;\n          case \"lines\":\n            const lines = toNumber(value);\n            if (lines !== null)\n              this._region.lines = lines;\n            else\n              badValue = true;\n            break;\n          case \"regionanchor\":\n            const region = toCoords(value);\n            if (region !== null) {\n              this._region.regionAnchorX = region[0];\n              this._region.regionAnchorY = region[1];\n            } else\n              badValue = true;\n            break;\n          case \"viewportanchor\":\n            const viewport = toCoords(value);\n            if (viewport !== null) {\n              this._region.viewportAnchorX = viewport[0];\n              this._region.viewportAnchorY = viewport[1];\n            } else\n              badValue = true;\n            break;\n          case \"scroll\":\n            if (value === \"up\")\n              this._region.scroll = \"up\";\n            else\n              badValue = true;\n            break;\n          default:\n            this._handleError(this._errorBuilder?._unknownRegionSetting(name, value, line));\n        }\n        if (badValue) {\n          this._handleError(this._errorBuilder?._badRegionSetting(name, value, line));\n        }\n      }\n    }\n  }\n  /**\n   * @see {@link https://www.w3.org/TR/webvtt1/#cue-timings-and-settings-parsing}\n   */\n  _parseCueSettings(settings, line) {\n    let badValue;\n    for (let i = 0; i < settings.length; i++) {\n      badValue = false;\n      if (SETTING_SEP_RE.test(settings[i])) {\n        const [name, value] = settings[i].split(SETTING_SEP_RE);\n        switch (name) {\n          case \"region\":\n            const region = this._regions[value];\n            if (region)\n              this._cue.region = region;\n            break;\n          case \"vertical\":\n            if (value === \"lr\" || value === \"rl\") {\n              this._cue.vertical = value;\n              this._cue.region = null;\n            } else\n              badValue = true;\n            break;\n          case \"line\":\n            const [linePos, lineAlign] = value.split(COMMA);\n            if (linePos.includes(PERCENT_SIGN)) {\n              const percentage = toPercentage(linePos);\n              if (percentage !== null) {\n                this._cue.line = percentage;\n                this._cue.snapToLines = false;\n              } else\n                badValue = true;\n            } else {\n              const number = toFloat(linePos);\n              if (number !== null)\n                this._cue.line = number;\n              else\n                badValue = true;\n            }\n            if (LINE_ALIGN_RE.test(lineAlign)) {\n              this._cue.lineAlign = lineAlign;\n            } else if (lineAlign) {\n              badValue = true;\n            }\n            if (this._cue.line !== \"auto\")\n              this._cue.region = null;\n            break;\n          case \"position\":\n            const [colPos, colAlign] = value.split(COMMA), position = toPercentage(colPos);\n            if (position !== null)\n              this._cue.position = position;\n            else\n              badValue = true;\n            if (colAlign && POS_ALIGN_RE.test(colAlign)) {\n              this._cue.positionAlign = colAlign;\n            } else if (colAlign) {\n              badValue = true;\n            }\n            break;\n          case \"size\":\n            const size = toPercentage(value);\n            if (size !== null) {\n              this._cue.size = size;\n              if (size < 100)\n                this._cue.region = null;\n            } else {\n              badValue = true;\n            }\n            break;\n          case \"align\":\n            if (ALIGN_RE.test(value)) {\n              this._cue.align = value;\n            } else {\n              badValue = true;\n            }\n            break;\n          default:\n            this._handleError(this._errorBuilder?._unknownCueSetting(name, value, line));\n        }\n        if (badValue) {\n          this._handleError(this._errorBuilder?._badCueSetting(name, value, line));\n        }\n      }\n    }\n  }\n  _handleError(error) {\n    if (!error)\n      return;\n    this._errors.push(error);\n    if (this._init.strict) {\n      this._init.cancel();\n      throw error;\n    } else {\n      this._init.onError?.(error);\n    }\n  }\n}\nfunction parseVTTTimestamp(timestamp) {\n  const match = timestamp.match(TIMESTAMP_RE);\n  if (!match)\n    return null;\n  const hours = match[1] ? parseInt(match[1], 10) : 0, minutes = parseInt(match[2], 10), seconds = parseInt(match[3], 10), milliseconds = match[4] ? parseInt(match[4].padEnd(3, \"0\"), 10) : 0, total = hours * 3600 + minutes * 60 + seconds + milliseconds / 1e3;\n  if (hours < 0 || minutes < 0 || seconds < 0 || milliseconds < 0 || minutes > 59 || seconds > 59) {\n    return null;\n  }\n  return total;\n}\nfunction createVTTParser() {\n  return new VTTParser();\n}\n\nvar vttParser = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  VTTBlock: VTTBlock,\n  VTTParser: VTTParser,\n  default: createVTTParser,\n  parseVTTTimestamp: parseVTTTimestamp\n});\n\nconst DIGIT_RE = /[0-9]/, MULTI_SPACE_RE = /[\\s\\t]+/, TAG_NAME = {\n  c: \"span\",\n  i: \"i\",\n  b: \"b\",\n  u: \"u\",\n  ruby: \"ruby\",\n  rt: \"rt\",\n  v: \"span\",\n  lang: \"span\",\n  timestamp: \"span\"\n}, HTML_ENTITIES = {\n  \"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&quot;\": '\"',\n  \"&#39;\": \"'\",\n  \"&nbsp;\": \"\\xA0\",\n  \"&lrm;\": \"\\u200E\",\n  \"&rlm;\": \"\\u200F\"\n}, HTML_ENTITY_RE = /&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g, COLORS = /* @__PURE__ */ new Set([\n  \"white\",\n  \"lime\",\n  \"cyan\",\n  \"red\",\n  \"yellow\",\n  \"magenta\",\n  \"blue\",\n  \"black\"\n]), BLOCK_TYPES = /* @__PURE__ */ new Set(Object.keys(TAG_NAME));\nfunction tokenizeVTTCue(cue) {\n  let buffer = \"\", mode = 1 /* Data */, result = [], stack = [], node;\n  for (let i = 0; i < cue.text.length; i++) {\n    const char = cue.text[i];\n    switch (mode) {\n      case 1 /* Data */:\n        if (char === \"<\") {\n          addText();\n          mode = 2 /* Tag */;\n        } else {\n          buffer += char;\n        }\n        break;\n      case 2 /* Tag */:\n        switch (char) {\n          case \"\\n\":\n          case \"\t\":\n          case \" \":\n            addNode();\n            mode = 4 /* Annotation */;\n            break;\n          case \".\":\n            addNode();\n            mode = 3 /* Class */;\n            break;\n          case \"/\":\n            mode = 5 /* EndTag */;\n            break;\n          case \">\":\n            addNode();\n            mode = 1 /* Data */;\n            break;\n          default:\n            if (!buffer && DIGIT_RE.test(char))\n              mode = 6 /* Timestamp */;\n            buffer += char;\n            break;\n        }\n        break;\n      case 3 /* Class */:\n        switch (char) {\n          case \"\t\":\n          case \" \":\n          case \"\\n\":\n            addClass();\n            if (node)\n              node.class?.trim();\n            mode = 4 /* Annotation */;\n            break;\n          case \".\":\n            addClass();\n            break;\n          case \">\":\n            addClass();\n            if (node)\n              node.class?.trim();\n            mode = 1 /* Data */;\n            break;\n          default:\n            buffer += char;\n        }\n        break;\n      case 4 /* Annotation */:\n        if (char === \">\") {\n          buffer = buffer.replace(MULTI_SPACE_RE, \" \");\n          if (node?.type === \"v\")\n            node.voice = replaceHTMLEntities(buffer);\n          else if (node?.type === \"lang\")\n            node.lang = replaceHTMLEntities(buffer);\n          buffer = \"\";\n          mode = 1 /* Data */;\n        } else {\n          buffer += char;\n        }\n        break;\n      case 5 /* EndTag */:\n        if (char === \">\") {\n          buffer = \"\";\n          node = stack.pop();\n          mode = 1 /* Data */;\n        }\n        break;\n      case 6 /* Timestamp */:\n        if (char === \">\") {\n          const time = parseVTTTimestamp(buffer);\n          if (time !== null && time >= cue.startTime && time <= cue.endTime) {\n            buffer = \"timestamp\";\n            addNode();\n            node.time = time;\n          }\n          buffer = \"\";\n          mode = 1 /* Data */;\n        } else {\n          buffer += char;\n        }\n        break;\n    }\n  }\n  function addNode() {\n    if (BLOCK_TYPES.has(buffer)) {\n      const parent = node;\n      node = createBlockNode(buffer);\n      if (parent) {\n        if (stack[stack.length - 1] !== parent)\n          stack.push(parent);\n        parent.children.push(node);\n      } else\n        result.push(node);\n    }\n    buffer = \"\";\n    mode = 1 /* Data */;\n  }\n  function addClass() {\n    if (node && buffer) {\n      const color = buffer.replace(\"bg_\", \"\");\n      if (COLORS.has(color)) {\n        node[buffer.startsWith(\"bg_\") ? \"bgColor\" : \"color\"] = color;\n      } else {\n        node.class = !node.class ? buffer : node.class + \" \" + buffer;\n      }\n    }\n    buffer = \"\";\n  }\n  function addText() {\n    if (!buffer)\n      return;\n    const text = { type: \"text\", data: replaceHTMLEntities(buffer) };\n    node ? node.children.push(text) : result.push(text);\n    buffer = \"\";\n  }\n  if (mode === 1 /* Data */)\n    addText();\n  return result;\n}\nfunction createBlockNode(type) {\n  return {\n    tagName: TAG_NAME[type],\n    type,\n    children: []\n  };\n}\nfunction replaceHTMLEntities(text) {\n  return text.replace(HTML_ENTITY_RE, (entity) => HTML_ENTITIES[entity] || \"'\");\n}\n\nfunction setCSSVar(el, name, value) {\n  el.style.setProperty(`--${name}`, value + \"\");\n}\nfunction setDataAttr(el, name, value = true) {\n  el.setAttribute(`data-${name}`, value === true ? \"\" : value + \"\");\n}\nfunction setPartAttr(el, name) {\n  el.setAttribute(\"data-part\", name);\n}\nfunction getLineHeight(el) {\n  return parseFloat(getComputedStyle(el).lineHeight) || 0;\n}\n\nfunction createVTTCueTemplate(cue) {\n  const template = document.createElement(\"template\");\n  template.innerHTML = renderVTTCueString(cue);\n  return { cue, content: template.content };\n}\nfunction renderVTTCueString(cue, currentTime = 0) {\n  return renderVTTTokensString(tokenizeVTTCue(cue), currentTime);\n}\nfunction renderVTTTokensString(tokens, currentTime = 0) {\n  let attrs, result = \"\";\n  for (const token of tokens) {\n    if (token.type === \"text\") {\n      result += token.data;\n    } else {\n      const isTimestamp = token.type === \"timestamp\";\n      attrs = {};\n      attrs.class = token.class;\n      attrs.title = token.type === \"v\" && token.voice;\n      attrs.lang = token.type === \"lang\" && token.lang;\n      attrs[\"data-part\"] = token.type === \"v\" && \"voice\";\n      if (isTimestamp) {\n        attrs[\"data-part\"] = \"timed\";\n        attrs[\"data-time\"] = token.time;\n        attrs[\"data-future\"] = token.time > currentTime;\n        attrs[\"data-past\"] = token.time < currentTime;\n      }\n      attrs.style = `${token.color ? `color: ${token.color};` : \"\"}${token.bgColor ? `background-color: ${token.bgColor};` : \"\"}`;\n      const attributes = Object.entries(attrs).filter((v) => v[1]).map((v) => `${v[0]}=\"${v[1] === true ? \"\" : v[1]}\"`).join(\" \");\n      result += `<${token.tagName}${attributes ? \" \" + attributes : \"\"}>${renderVTTTokensString(\n        token.children\n      )}</${token.tagName}>`;\n    }\n  }\n  return result;\n}\nfunction updateTimedVTTCueNodes(root, currentTime) {\n  for (const el of root.querySelectorAll('[data-part=\"timed\"]')) {\n    const time = Number(el.getAttribute(\"data-time\"));\n    if (Number.isNaN(time))\n      continue;\n    if (time > currentTime)\n      setDataAttr(el, \"future\");\n    else\n      el.removeAttribute(\"data-future\");\n    if (time < currentTime)\n      setDataAttr(el, \"past\");\n    else\n      el.removeAttribute(\"data-past\");\n  }\n}\n\nfunction debounce(fn, delay) {\n  let timeout = null, args;\n  function run() {\n    clear();\n    fn(...args);\n    args = void 0;\n  }\n  function clear() {\n    clearTimeout(timeout);\n    timeout = null;\n  }\n  function debounce2() {\n    args = [].slice.call(arguments);\n    clear();\n    timeout = setTimeout(run, delay);\n  }\n  return debounce2;\n}\n\nconst STARTING_BOX = Symbol(\"STARTING_BOX\" );\nfunction createBox(box) {\n  if (box instanceof HTMLElement) {\n    return {\n      top: box.offsetTop,\n      width: box.clientWidth,\n      height: box.clientHeight,\n      left: box.offsetLeft,\n      right: box.offsetLeft + box.clientWidth,\n      bottom: box.offsetTop + box.clientHeight\n    };\n  }\n  return { ...box };\n}\nfunction moveBox(box, axis, delta) {\n  switch (axis) {\n    case \"+x\":\n      box.left += delta;\n      box.right += delta;\n      break;\n    case \"-x\":\n      box.left -= delta;\n      box.right -= delta;\n      break;\n    case \"+y\":\n      box.top += delta;\n      box.bottom += delta;\n      break;\n    case \"-y\":\n      box.top -= delta;\n      box.bottom -= delta;\n      break;\n  }\n}\nfunction isBoxCollision(a, b) {\n  return a.left <= b.right && a.right >= b.left && a.top <= b.bottom && a.bottom >= b.top;\n}\nfunction isAnyBoxCollision(box, boxes) {\n  for (let i = 0; i < boxes.length; i++)\n    if (isBoxCollision(box, boxes[i]))\n      return boxes[i];\n  return null;\n}\nfunction isWithinBox(container, box) {\n  return box.top >= 0 && box.bottom <= container.height && box.left >= 0 && box.right <= container.width;\n}\nfunction isBoxOutOfBounds(container, box, axis) {\n  switch (axis) {\n    case \"+x\":\n      return box.left < 0;\n    case \"-x\":\n      return box.right > container.width;\n    case \"+y\":\n      return box.top < 0;\n    case \"-y\":\n      return box.bottom > container.height;\n  }\n}\nfunction calcBoxIntersectPercentage(container, box) {\n  const x = Math.max(0, Math.min(container.width, box.right) - Math.max(0, box.left)), y = Math.max(0, Math.min(container.height, box.bottom) - Math.max(0, box.top)), intersectArea = x * y;\n  return intersectArea / (container.height * container.width);\n}\nfunction createCSSBox(container, box) {\n  return {\n    top: box.top / container.height,\n    left: box.left / container.width,\n    right: (container.width - box.right) / container.width,\n    bottom: (container.height - box.bottom) / container.height\n  };\n}\nfunction resolveRelativeBox(container, box) {\n  box.top = box.top * container.height;\n  box.left = box.left * container.width;\n  box.right = container.width - box.right * container.width;\n  box.bottom = container.height - box.bottom * container.height;\n  return box;\n}\nconst BOX_SIDES = [\"top\", \"left\", \"right\", \"bottom\"];\nfunction setBoxCSSVars(el, container, box, prefix) {\n  const cssBox = createCSSBox(container, box);\n  for (const side of BOX_SIDES) {\n    setCSSVar(el, `${prefix}-${side}`, cssBox[side] * 100 + \"%\");\n  }\n}\nfunction avoidBoxCollisions(container, box, boxes, axis) {\n  let percentage = 1, positionedBox, startBox = { ...box };\n  for (let i = 0; i < axis.length; i++) {\n    while (isBoxOutOfBounds(container, box, axis[i]) || isWithinBox(container, box) && isAnyBoxCollision(box, boxes)) {\n      moveBox(box, axis[i], 1);\n    }\n    if (isWithinBox(container, box))\n      return box;\n    const intersection = calcBoxIntersectPercentage(container, box);\n    if (percentage > intersection) {\n      positionedBox = { ...box };\n      percentage = intersection;\n    }\n    box = { ...startBox };\n  }\n  return positionedBox || startBox;\n}\n\nconst POSITION_OVERRIDE = Symbol(\"POSITION_OVERRIDE\" );\nfunction positionCue(container, cue, displayEl, boxes) {\n  let cueEl = displayEl.firstElementChild, line = computeCueLine(cue), displayBox, axis = [];\n  if (!displayEl[STARTING_BOX]) {\n    displayEl[STARTING_BOX] = createStartingBox(container, displayEl);\n  }\n  displayBox = resolveRelativeBox(container, { ...displayEl[STARTING_BOX] });\n  if (displayEl[POSITION_OVERRIDE]) {\n    axis = [displayEl[POSITION_OVERRIDE] === \"top\" ? \"+y\" : \"-y\", \"+x\", \"-x\"];\n  } else if (cue.snapToLines) {\n    let size;\n    switch (cue.vertical) {\n      case \"\":\n        axis = [\"+y\", \"-y\"];\n        size = \"height\";\n        break;\n      case \"rl\":\n        axis = [\"+x\", \"-x\"];\n        size = \"width\";\n        break;\n      case \"lr\":\n        axis = [\"-x\", \"+x\"];\n        size = \"width\";\n        break;\n    }\n    let step = getLineHeight(cueEl), position = step * Math.round(line), maxPosition = container[size] + step, initialAxis = axis[0];\n    if (Math.abs(position) > maxPosition) {\n      position = position < 0 ? -1 : 1;\n      position *= Math.ceil(maxPosition / step) * step;\n    }\n    if (line < 0) {\n      position += cue.vertical === \"\" ? container.height : container.width;\n      axis = axis.reverse();\n    }\n    moveBox(displayBox, initialAxis, position);\n  } else {\n    const isHorizontal = cue.vertical === \"\", posAxis = isHorizontal ? \"+y\" : \"+x\", size = isHorizontal ? displayBox.height : displayBox.width;\n    moveBox(\n      displayBox,\n      posAxis,\n      (isHorizontal ? container.height : container.width) * line / 100\n    );\n    moveBox(\n      displayBox,\n      posAxis,\n      cue.lineAlign === \"center\" ? size / 2 : cue.lineAlign === \"end\" ? size : 0\n    );\n    axis = isHorizontal ? [\"-y\", \"+y\", \"-x\", \"+x\"] : [\"-x\", \"+x\", \"-y\", \"+y\"];\n  }\n  displayBox = avoidBoxCollisions(container, displayBox, boxes, axis);\n  setBoxCSSVars(displayEl, container, displayBox, \"cue\");\n  return displayBox;\n}\nfunction createStartingBox(container, cueEl) {\n  const box = createBox(cueEl), pos = getStyledPositions(cueEl);\n  cueEl[POSITION_OVERRIDE] = false;\n  if (pos.top) {\n    box.top = pos.top;\n    box.bottom = pos.top + box.height;\n    cueEl[POSITION_OVERRIDE] = \"top\";\n  }\n  if (pos.bottom) {\n    const bottom = container.height - pos.bottom;\n    box.top = bottom - box.height;\n    box.bottom = bottom;\n    cueEl[POSITION_OVERRIDE] = \"bottom\";\n  }\n  if (pos.left)\n    box.left = pos.left;\n  if (pos.right)\n    box.right = container.width - pos.right;\n  return createCSSBox(container, box);\n}\nfunction getStyledPositions(el) {\n  const positions = {};\n  for (const side of BOX_SIDES) {\n    positions[side] = parseFloat(el.style.getPropertyValue(`--cue-${side}`));\n  }\n  return positions;\n}\nfunction computeCueLine(cue) {\n  if (cue.line === \"auto\") {\n    if (!cue.snapToLines) {\n      return 100;\n    } else {\n      return -1;\n    }\n  }\n  return cue.line;\n}\nfunction computeCuePosition(cue) {\n  if (cue.position === \"auto\") {\n    switch (cue.align) {\n      case \"start\":\n      case \"left\":\n        return 0;\n      case \"right\":\n      case \"end\":\n        return 100;\n      default:\n        return 50;\n    }\n  }\n  return cue.position;\n}\nfunction computeCuePositionAlignment(cue, dir) {\n  if (cue.positionAlign === \"auto\") {\n    switch (cue.align) {\n      case \"start\":\n        return dir === \"ltr\" ? \"line-left\" : \"line-right\";\n      case \"end\":\n        return dir === \"ltr\" ? \"line-right\" : \"line-left\";\n      case \"center\":\n        return \"center\";\n      default:\n        return `line-${cue.align}`;\n    }\n  }\n  return cue.positionAlign;\n}\n\nconst REGION_AXIS = [\"-y\", \"+y\", \"-x\", \"+x\"];\nfunction positionRegion(container, region, regionEl, boxes) {\n  let cues = Array.from(regionEl.querySelectorAll('[data-part=\"cue-display\"]')), height = 0, limit = Math.max(0, cues.length - region.lines);\n  for (let i = cues.length - 1; i >= limit; i--) {\n    height += cues[i].offsetHeight;\n  }\n  setCSSVar(regionEl, \"region-height\", height + \"px\");\n  if (!regionEl[STARTING_BOX]) {\n    regionEl[STARTING_BOX] = createCSSBox(container, createBox(regionEl));\n  }\n  let box = { ...regionEl[STARTING_BOX] };\n  box = resolveRelativeBox(container, box);\n  box.width = regionEl.clientWidth;\n  box.height = height;\n  box.right = box.left + box.width;\n  box.bottom = box.top + height;\n  box = avoidBoxCollisions(container, box, boxes, REGION_AXIS);\n  setBoxCSSVars(regionEl, container, box, \"region\");\n  return box;\n}\n\nclass CaptionsRenderer {\n  overlay;\n  _overlayBox;\n  _currentTime = 0;\n  _dir = \"ltr\";\n  _activeCues = [];\n  _isResizing = false;\n  _resizeObserver;\n  _regions = /* @__PURE__ */ new Map();\n  _cues = /* @__PURE__ */ new Map();\n  /* Text direction. */\n  get dir() {\n    return this._dir;\n  }\n  set dir(dir) {\n    this._dir = dir;\n    setDataAttr(this.overlay, \"dir\", dir);\n  }\n  get currentTime() {\n    return this._currentTime;\n  }\n  set currentTime(time) {\n    this._currentTime = time;\n    this.update();\n  }\n  constructor(overlay, init) {\n    this.overlay = overlay;\n    this.dir = init?.dir ?? \"ltr\";\n    overlay.setAttribute(\"translate\", \"yes\");\n    overlay.setAttribute(\"aria-live\", \"off\");\n    overlay.setAttribute(\"aria-atomic\", \"true\");\n    setPartAttr(overlay, \"captions\");\n    this._updateOverlay();\n    this._resizeObserver = new ResizeObserver(this._resizing.bind(this));\n    this._resizeObserver.observe(overlay);\n  }\n  changeTrack({ regions, cues }) {\n    this.reset();\n    this._buildRegions(regions);\n    for (const cue of cues)\n      this._cues.set(cue, null);\n    this.update();\n  }\n  addCue(cue) {\n    this._cues.set(cue, null);\n    this.update();\n  }\n  removeCue(cue) {\n    this._cues.delete(cue);\n    this.update();\n  }\n  update(forceUpdate = false) {\n    this._render(forceUpdate);\n  }\n  reset() {\n    this._cues.clear();\n    this._regions.clear();\n    this._activeCues = [];\n    this.overlay.textContent = \"\";\n  }\n  destroy() {\n    this.reset();\n    this._resizeObserver.disconnect();\n  }\n  _resizing() {\n    this._isResizing = true;\n    this._resize();\n  }\n  _resize = debounce(() => {\n    this._isResizing = false;\n    this._updateOverlay();\n    for (const el of this._regions.values()) {\n      el[STARTING_BOX] = null;\n    }\n    for (const el of this._cues.values()) {\n      if (el)\n        el[STARTING_BOX] = null;\n    }\n    this._render(true);\n  }, 50);\n  _updateOverlay() {\n    this._overlayBox = createBox(this.overlay);\n    setCSSVar(this.overlay, \"overlay-width\", this._overlayBox.width + \"px\");\n    setCSSVar(this.overlay, \"overlay-height\", this._overlayBox.height + \"px\");\n  }\n  _render(forceUpdate = false) {\n    if (!this._cues.size || this._isResizing)\n      return;\n    let cue, activeCues = [...this._cues.keys()].filter((cue2) => this._currentTime >= cue2.startTime && this._currentTime <= cue2.endTime).sort(\n      (cueA, cueB) => cueA.startTime !== cueB.startTime ? cueA.startTime - cueB.startTime : cueA.endTime - cueB.endTime\n    ), activeRegions = activeCues.map((cue2) => cue2.region);\n    for (let i = 0; i < this._activeCues.length; i++) {\n      cue = this._activeCues[i];\n      if (activeCues[i] === cue)\n        continue;\n      if (cue.region && !activeRegions.includes(cue.region)) {\n        const regionEl = this._regions.get(cue.region.id);\n        if (regionEl) {\n          regionEl.removeAttribute(\"data-active\");\n          forceUpdate = true;\n        }\n      }\n      const cueEl = this._cues.get(cue);\n      if (cueEl) {\n        cueEl.remove();\n        forceUpdate = true;\n      }\n    }\n    for (let i = 0; i < activeCues.length; i++) {\n      cue = activeCues[i];\n      let cueEl = this._cues.get(cue);\n      if (!cueEl)\n        this._cues.set(cue, cueEl = this._createCueElement(cue));\n      const regionEl = this._hasRegion(cue) && this._regions.get(cue.region.id);\n      if (regionEl && !regionEl.hasAttribute(\"data-active\")) {\n        requestAnimationFrame(() => setDataAttr(regionEl, \"active\"));\n        forceUpdate = true;\n      }\n      if (!cueEl.isConnected) {\n        (regionEl || this.overlay).append(cueEl);\n        forceUpdate = true;\n      }\n    }\n    if (forceUpdate) {\n      const boxes = [], seen = /* @__PURE__ */ new Set();\n      for (let i = activeCues.length - 1; i >= 0; i--) {\n        cue = activeCues[i];\n        if (seen.has(cue.region || cue))\n          continue;\n        const isRegion = this._hasRegion(cue), el = isRegion ? this._regions.get(cue.region.id) : this._cues.get(cue);\n        if (isRegion) {\n          boxes.push(positionRegion(this._overlayBox, cue.region, el, boxes));\n        } else {\n          boxes.push(positionCue(this._overlayBox, cue, el, boxes));\n        }\n        seen.add(isRegion ? cue.region : cue);\n      }\n    }\n    updateTimedVTTCueNodes(this.overlay, this._currentTime);\n    this._activeCues = activeCues;\n  }\n  _buildRegions(regions) {\n    if (!regions)\n      return;\n    for (const region of regions) {\n      const el = this._createRegionElement(region);\n      this._regions.set(region.id, el);\n      this.overlay.append(el);\n    }\n  }\n  _createRegionElement(region) {\n    const el = document.createElement(\"div\");\n    setPartAttr(el, \"region\");\n    setDataAttr(el, \"id\", region.id);\n    setDataAttr(el, \"scroll\", region.scroll);\n    setCSSVar(el, \"region-width\", region.width + \"%\");\n    setCSSVar(el, \"region-anchor-x\", region.regionAnchorX);\n    setCSSVar(el, \"region-anchor-y\", region.regionAnchorY);\n    setCSSVar(el, \"region-viewport-anchor-x\", region.viewportAnchorX);\n    setCSSVar(el, \"region-viewport-anchor-y\", region.viewportAnchorY);\n    setCSSVar(el, \"region-lines\", region.lines);\n    return el;\n  }\n  _createCueElement(cue) {\n    const display = document.createElement(\"div\"), position = computeCuePosition(cue), positionAlignment = computeCuePositionAlignment(cue, this._dir);\n    setPartAttr(display, \"cue-display\");\n    if (cue.vertical !== \"\")\n      setDataAttr(display, \"vertical\");\n    setCSSVar(display, \"cue-text-align\", cue.align);\n    if (cue.style) {\n      for (const prop of Object.keys(cue.style)) {\n        display.style.setProperty(prop, cue.style[prop]);\n      }\n    }\n    if (!this._hasRegion(cue)) {\n      setCSSVar(\n        display,\n        \"cue-writing-mode\",\n        cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\"\n      );\n      if (!cue.style?.[\"--cue-width\"]) {\n        let maxSize = position;\n        if (positionAlignment === \"line-left\") {\n          maxSize = 100 - position;\n        } else if (positionAlignment === \"center\" && position <= 50) {\n          maxSize = position * 2;\n        } else if (positionAlignment === \"center\" && position > 50) {\n          maxSize = (100 - position) * 2;\n        }\n        const size = cue.size < maxSize ? cue.size : maxSize;\n        if (cue.vertical === \"\")\n          setCSSVar(display, \"cue-width\", size + \"%\");\n        else\n          setCSSVar(display, \"cue-height\", size + \"%\");\n      }\n    } else {\n      setCSSVar(\n        display,\n        \"cue-offset\",\n        `${position - (positionAlignment === \"line-right\" ? 100 : positionAlignment === \"center\" ? 50 : 0)}%`\n      );\n    }\n    const el = document.createElement(\"div\");\n    setPartAttr(el, \"cue\");\n    if (cue.id)\n      setDataAttr(el, \"id\", cue.id);\n    el.innerHTML = renderVTTCueString(cue);\n    display.append(el);\n    return display;\n  }\n  _hasRegion(cue) {\n    return cue.region && cue.size === 100 && cue.vertical === \"\" && cue.line === \"auto\";\n  }\n}\n\nexport { CaptionsRenderer as C, ParseError as P, TextCue as T, VTTParser as V, VTTBlock as a, VTTCue as b, ParseErrorCode as c, parseResponse as d, parseByteStream as e, parseText as f, parseTextStream as g, VTTRegion as h, createVTTCueTemplate as i, renderVTTTokensString as j, parseVTTTimestamp as p, renderVTTCueString as r, tokenizeVTTCue as t, updateTimedVTTCueNodes as u };\n"]},"metadata":{},"sourceType":"module"}