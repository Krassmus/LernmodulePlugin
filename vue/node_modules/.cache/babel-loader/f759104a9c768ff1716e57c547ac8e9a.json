{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/**\r\n * Takes the properties on object from parameter source and adds them to the object\r\n * parameter target\r\n * @param {object} target  Object to have properties copied onto from y\r\n * @param {object} source  Object with properties to be copied to x\r\n */\nfunction addPropertiesToObject(target, source) {\n  for (let k of Object.keys(source || {})) {\n    Object.defineProperty(target, k, {\n      get: () => source[k]\n    });\n  }\n}\n/**\r\n * Returns a namespaced name of the module to be used as a store getter\r\n * @param module\r\n */\n\n\nfunction getModuleName(module) {\n  if (!module._vmdModuleName) {\n    throw new Error(`ERR_GET_MODULE_NAME : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`);\n  }\n\n  return `vuexModuleDecorators/${module._vmdModuleName}`;\n}\n\nclass VuexModule {\n  constructor(module) {\n    this.actions = module.actions;\n    this.mutations = module.mutations;\n    this.state = module.state;\n    this.getters = module.getters;\n    this.namespaced = module.namespaced;\n    this.modules = module.modules;\n  }\n\n}\n\nfunction getModule(moduleClass, store) {\n  const moduleName = getModuleName(moduleClass);\n\n  if (store && store.getters[moduleName]) {\n    return store.getters[moduleName];\n  } else if (moduleClass._statics) {\n    return moduleClass._statics;\n  }\n\n  const genStatic = moduleClass._genStatic;\n\n  if (!genStatic) {\n    throw new Error(`ERR_GET_MODULE_NO_STATICS : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`);\n  }\n\n  const storeModule = genStatic(store);\n\n  if (store) {\n    store.getters[moduleName] = storeModule;\n  } else {\n    moduleClass._statics = storeModule;\n  }\n\n  return storeModule;\n}\n\nconst reservedKeys = ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit'];\n\nfunction stateFactory(module) {\n  const state = new module.prototype.constructor({});\n  const s = {};\n  Object.keys(state).forEach(key => {\n    if (reservedKeys.indexOf(key) !== -1) {\n      if (typeof state[key] !== 'undefined') {\n        throw new Error(`ERR_RESERVED_STATE_KEY_USED: You cannot use the following\n        ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\n        as fields in your module. These are reserved as they have special purpose in Vuex`);\n      }\n\n      return;\n    }\n\n    if (state.hasOwnProperty(key)) {\n      if (typeof state[key] !== 'function') {\n        s[key] = state[key];\n      }\n    }\n  });\n  return s;\n}\n\nfunction staticStateGenerator(module, modOpt, statics) {\n  const state = modOpt.stateFactory ? module.state() : module.state;\n  Object.keys(state).forEach(key => {\n    if (state.hasOwnProperty(key)) {\n      // If not undefined or function means it is a state value\n      if (['undefined', 'function'].indexOf(typeof state[key]) === -1) {\n        Object.defineProperty(statics, key, {\n          get() {\n            const path = modOpt.name.split('/');\n            let data = statics.store.state;\n\n            for (let segment of path) {\n              data = data[segment];\n            }\n\n            return data[key];\n          }\n\n        });\n      }\n    }\n  });\n}\n\nfunction staticGetterGenerator(module, modOpt, statics) {\n  Object.keys(module.getters).forEach(key => {\n    if (module.namespaced) {\n      Object.defineProperty(statics, key, {\n        get() {\n          return statics.store.getters[`${modOpt.name}/${key}`];\n        }\n\n      });\n    } else {\n      Object.defineProperty(statics, key, {\n        get() {\n          return statics.store.getters[key];\n        }\n\n      });\n    }\n  });\n}\n\nfunction staticMutationGenerator(module, modOpt, statics) {\n  Object.keys(module.mutations).forEach(key => {\n    if (module.namespaced) {\n      statics[key] = function (...args) {\n        statics.store.commit(`${modOpt.name}/${key}`, ...args);\n      };\n    } else {\n      statics[key] = function (...args) {\n        statics.store.commit(key, ...args);\n      };\n    }\n  });\n}\n\nfunction staticActionGenerators(module, modOpt, statics) {\n  Object.keys(module.actions).forEach(key => {\n    if (module.namespaced) {\n      statics[key] = async function (...args) {\n        return statics.store.dispatch(`${modOpt.name}/${key}`, ...args);\n      };\n    } else {\n      statics[key] = async function (...args) {\n        return statics.store.dispatch(key, ...args);\n      };\n    }\n  });\n}\n\nfunction registerDynamicModule(module, modOpt) {\n  if (!modOpt.name) {\n    throw new Error('Name of module not provided in decorator options');\n  }\n\n  if (!modOpt.store) {\n    throw new Error('Store not provided in decorator options when using dynamic option');\n  }\n\n  modOpt.store.registerModule(modOpt.name, // TODO: Handle nested modules too in future\n  module, {\n    preserveState: modOpt.preserveState || false\n  });\n}\n\nfunction addGettersToModule(targetModule, srcModule) {\n  Object.getOwnPropertyNames(srcModule.prototype).forEach(funcName => {\n    const descriptor = Object.getOwnPropertyDescriptor(srcModule.prototype, funcName);\n\n    if (descriptor.get && targetModule.getters) {\n      targetModule.getters[funcName] = function (state, getters, rootState, rootGetters) {\n        const thisObj = {\n          context: {\n            state,\n            getters,\n            rootState,\n            rootGetters\n          }\n        };\n        addPropertiesToObject(thisObj, state);\n        addPropertiesToObject(thisObj, getters);\n        const got = descriptor.get.call(thisObj);\n        return got;\n      };\n    }\n  });\n}\n\nfunction moduleDecoratorFactory(moduleOptions) {\n  return function (constructor) {\n    const module = constructor;\n\n    const stateFactory$1 = () => stateFactory(module);\n\n    if (!module.state) {\n      module.state = moduleOptions && moduleOptions.stateFactory ? stateFactory$1 : stateFactory$1();\n    }\n\n    if (!module.getters) {\n      module.getters = {};\n    }\n\n    if (!module.namespaced) {\n      module.namespaced = moduleOptions && moduleOptions.namespaced;\n    }\n\n    let parentModule = Object.getPrototypeOf(module);\n\n    while (parentModule.name !== 'VuexModule' && parentModule.name !== '') {\n      addGettersToModule(module, parentModule);\n      parentModule = Object.getPrototypeOf(parentModule);\n    }\n\n    addGettersToModule(module, module);\n    const modOpt = moduleOptions;\n\n    if (modOpt.name) {\n      Object.defineProperty(constructor, '_genStatic', {\n        value: store => {\n          let statics = {\n            store: store || modOpt.store\n          };\n\n          if (!statics.store) {\n            throw new Error(`ERR_STORE_NOT_PROVIDED: To use getModule(), either the module\n            should be decorated with store in decorator, i.e. @Module({store: store}) or\n            store should be passed when calling getModule(), i.e. getModule(MyModule, this.$store)`);\n          } // ===========  For statics ==============\n          // ------ state -------\n\n\n          staticStateGenerator(module, modOpt, statics); // ------- getters -------\n\n          if (module.getters) {\n            staticGetterGenerator(module, modOpt, statics);\n          } // -------- mutations --------\n\n\n          if (module.mutations) {\n            staticMutationGenerator(module, modOpt, statics);\n          } // -------- actions ---------\n\n\n          if (module.actions) {\n            staticActionGenerators(module, modOpt, statics);\n          }\n\n          return statics;\n        }\n      });\n      Object.defineProperty(constructor, '_vmdModuleName', {\n        value: modOpt.name\n      });\n    }\n\n    if (modOpt.dynamic) {\n      registerDynamicModule(module, modOpt);\n    }\n\n    return constructor;\n  };\n}\n\nfunction Module(modOrOpt) {\n  if (typeof modOrOpt === 'function') {\n    /*\r\n     * @Module decorator called without options (directly on the class definition)\r\n     */\n    moduleDecoratorFactory({})(modOrOpt);\n  } else {\n    /*\r\n     * @Module({...}) decorator called with options\r\n     */\n    return moduleDecoratorFactory(modOrOpt);\n  }\n}\n\nconst config = {};\n\nfunction actionDecoratorFactory(params) {\n  const {\n    commit = undefined,\n    rawError = !!config.rawError,\n    root = false\n  } = params || {};\n  return function (target, key, descriptor) {\n    const module = target.constructor;\n\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions);\n    }\n\n    const actionFunction = descriptor.value;\n\n    const action = async function (context, payload) {\n      try {\n        let actionPayload = null;\n\n        if (module._genStatic) {\n          const moduleName = getModuleName(module);\n          const moduleAccessor = context.rootGetters[moduleName] ? context.rootGetters[moduleName] : getModule(module);\n          moduleAccessor.context = context;\n          actionPayload = await actionFunction.call(moduleAccessor, payload);\n        } else {\n          const thisObj = {\n            context\n          };\n          addPropertiesToObject(thisObj, context.state);\n          addPropertiesToObject(thisObj, context.getters);\n          actionPayload = await actionFunction.call(thisObj, payload);\n        }\n\n        if (commit) {\n          context.commit(commit, actionPayload);\n        }\n\n        return actionPayload;\n      } catch (e) {\n        throw rawError ? e : new Error('ERR_ACTION_ACCESS_UNDEFINED: Are you trying to access ' + 'this.someMutation() or this.someGetter inside an @Action? \\n' + 'That works only in dynamic modules. \\n' + 'If not dynamic use this.context.commit(\"mutationName\", payload) ' + 'and this.context.getters[\"getterName\"]' + '\\n' + new Error(`Could not perform action ${key.toString()}`).stack + '\\n' + e.stack);\n      }\n    };\n\n    module.actions[key] = root ? {\n      root,\n      handler: action\n    } : action;\n  };\n}\n/**\r\n * The @Action decorator turns an async function into an Vuex action\r\n *\r\n * @param targetOrParams the module class\r\n * @param key name of the action\r\n * @param descriptor the action function descriptor\r\n * @constructor\r\n */\n\n\nfunction Action(targetOrParams, key, descriptor) {\n  if (!key && !descriptor) {\n    /*\r\n     * This is the case when `targetOrParams` is params.\r\n     * i.e. when used as -\r\n     * <pre>\r\n        @Action({commit: 'incrCount'})\r\n        async getCountDelta() {\r\n          return 5\r\n        }\r\n     * </pre>\r\n     */\n    return actionDecoratorFactory(targetOrParams);\n  } else {\n    /*\r\n     * This is the case when @Action is called on action function\r\n     * without any params\r\n     * <pre>\r\n     *   @Action\r\n     *   async doSomething() {\r\n     *    ...\r\n     *   }\r\n     * </pre>\r\n     */\n    actionDecoratorFactory()(targetOrParams, key, descriptor);\n  }\n}\n\nfunction Mutation(target, key, descriptor) {\n  const module = target.constructor;\n\n  if (!module.hasOwnProperty('mutations')) {\n    module.mutations = Object.assign({}, module.mutations);\n  }\n\n  const mutationFunction = descriptor.value;\n\n  const mutation = function (state, payload) {\n    mutationFunction.call(state, payload);\n  };\n\n  module.mutations[key] = mutation;\n}\n\nfunction mutationActionDecoratorFactory(params) {\n  return function (target, key, descriptor) {\n    const module = target.constructor;\n\n    if (!module.hasOwnProperty('mutations')) {\n      module.mutations = Object.assign({}, module.mutations);\n    }\n\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions);\n    }\n\n    const mutactFunction = descriptor.value;\n\n    const action = async function (context, payload) {\n      try {\n        const thisObj = {\n          context\n        };\n        addPropertiesToObject(thisObj, context.state);\n        addPropertiesToObject(thisObj, context.getters);\n        const actionPayload = await mutactFunction.call(thisObj, payload);\n        if (actionPayload === undefined) return;\n        context.commit(key, actionPayload);\n      } catch (e) {\n        if (params.rawError) {\n          throw e;\n        } else {\n          console.error('Could not perform action ' + key.toString());\n          console.error(e);\n          return Promise.reject(e);\n        }\n      }\n    };\n\n    const mutation = function (state, payload) {\n      if (!params.mutate) {\n        params.mutate = Object.keys(payload);\n      }\n\n      for (let stateItem of params.mutate) {\n        if (state.hasOwnProperty(stateItem) && payload.hasOwnProperty(stateItem)) {\n          state[stateItem] = payload[stateItem];\n        } else {\n          throw new Error(`ERR_MUTATE_PARAMS_NOT_IN_PAYLOAD\n          In @MutationAction, mutate: ['a', 'b', ...] array keys must\n          match with return type = {a: {}, b: {}, ...} and must\n          also be in state.`);\n        }\n      }\n    };\n\n    module.actions[key] = params.root ? {\n      root: true,\n      handler: action\n    } : action;\n    module.mutations[key] = mutation;\n  };\n}\n/**\r\n * The @MutationAction decorator turns this into an action that further calls a mutation\r\n * Both the action and the mutation are generated for you\r\n *\r\n * @param paramsOrTarget the params or the target class\r\n * @param key the name of the function\r\n * @param descriptor the function body\r\n * @constructor\r\n */\n\n\nfunction MutationAction(paramsOrTarget, key, descriptor) {\n  if (!key && !descriptor) {\n    /*\r\n     * This is the case when `paramsOrTarget` is params.\r\n     * i.e. when used as -\r\n     * <pre>\r\n        @MutationAction({mutate: ['incrCount']})\r\n        async getCountDelta() {\r\n          return {incrCount: 5}\r\n        }\r\n     * </pre>\r\n     */\n    return mutationActionDecoratorFactory(paramsOrTarget);\n  } else {\n    /*\r\n     * This is the case when `paramsOrTarget` is target.\r\n     * i.e. when used as -\r\n     * <pre>\r\n        @MutationAction\r\n        async getCountDelta() {\r\n          return {incrCount: 5}\r\n        }\r\n     * </pre>\r\n     */\n    mutationActionDecoratorFactory({})(paramsOrTarget, key, descriptor);\n  }\n}\n\nexport { Action, Module, Mutation, MutationAction, VuexModule, config, getModule };","map":{"version":3,"mappings":";;AAAA;;;;;;SAMgBA,sBAAsBC,QAAaC,QAAW;AAC5D,OAAK,IAAIC,CAAT,IAAcC,MAAM,CAACC,IAAP,CAAYH,MAAM,IAAI,EAAtB,CAAd,EAAyC;AACvCE,UAAM,CAACE,cAAP,CAAsBL,MAAtB,EAA8BE,CAA9B,EAAiC;AAC/BI,SAAG,EAAE,MAAML,MAAM,CAACC,CAAD;AADc,KAAjC;AAGD;AACF;AAED;;;;;;SAIgBK,cAAcC,QAAW;AACvC,MAAI,CAACA,MAAM,CAACC,cAAZ,EAA4B;AAC1B,UAAM,IAAIC,KAAJ,CAAU;;0CAAV,CAAN;AAGD;;AACD,SAAO,wBAAwBF,MAAM,CAACC,cAAc,EAApD;AACF;;MCdaE,WAAU;AAuBrBC,cAAYJ,MAAZ,EAA+B;AAC7B,SAAKK,OAAL,GAAeL,MAAM,CAACK,OAAtB;AACA,SAAKC,SAAL,GAAiBN,MAAM,CAACM,SAAxB;AACA,SAAKC,KAAL,GAAaP,MAAM,CAACO,KAApB;AACA,SAAKC,OAAL,GAAeR,MAAM,CAACQ,OAAtB;AACA,SAAKC,UAAL,GAAkBT,MAAM,CAACS,UAAzB;AACA,SAAKC,OAAL,GAAeV,MAAM,CAACU,OAAtB;AACD;;AA9BoB;;SAkCPC,UACdC,aACAC,OAAkB;AAElB,QAAMC,UAAU,GAAGf,aAAa,CAACa,WAAD,CAAhC;;AACA,MAAIC,KAAK,IAAIA,KAAK,CAACL,OAAN,CAAcM,UAAd,CAAb,EAAwC;AACtC,WAAOD,KAAK,CAACL,OAAN,CAAcM,UAAd,CAAP;AACD,GAFD,MAEO,IAAKF,WAAmB,CAACG,QAAzB,EAAmC;AACxC,WAAQH,WAAmB,CAACG,QAA5B;AACD;;AAED,QAAMC,SAAS,GAAuCJ,WAAmB,CAACK,UAA1E;;AACA,MAAI,CAACD,SAAL,EAAgB;AACd,UAAM,IAAId,KAAJ,CAAU;;0CAAV,CAAN;AAGD;;AAED,QAAMgB,WAAW,GAAGF,SAAS,CAACH,KAAD,CAA7B;;AAEA,MAAIA,KAAJ,EAAW;AACTA,SAAK,CAACL,OAAN,CAAcM,UAAd,IAA4BI,WAA5B;AACD,GAFD,MAEO;AACHN,eAAmB,CAACG,QAApB,GAA+BG,WAA/B;AACH;;AAED,SAAOA,WAAP;AACF;;ACtEA,MAAMC,YAAY,GAAG,CAAC,SAAD,EAAY,SAAZ,EAAuB,WAAvB,EAAoC,SAApC,EAA+C,OAA/C,EAAwD,YAAxD,EAAsE,QAAtE,CAArB;;SACgBC,aAAgBpB,QAA8B;AAC5D,QAAMO,KAAK,GAAG,IAAIP,MAAM,CAACqB,SAAP,CAAiBjB,WAArB,CAAiC,EAAjC,CAAd;AACA,QAAMkB,CAAC,GAAG,EAAV;AACA3B,QAAM,CAACC,IAAP,CAAYW,KAAZ,EAAmBgB,OAAnB,CAA4BC,GAAD,IAAY;AACrC,QAAIL,YAAY,CAACM,OAAb,CAAqBD,GAArB,MAA8B,CAAC,CAAnC,EAAsC;AACpC,UAAI,OAAOjB,KAAK,CAACiB,GAAD,CAAZ,KAAsB,WAA1B,EAAuC;AACrC,cAAM,IAAItB,KAAJ,CACJ;;0FADI,CAAN;AAKD;;AACD;AACD;;AACD,QAAIK,KAAK,CAACmB,cAAN,CAAqBF,GAArB,CAAJ,EAA+B;AAC7B,UAAI,OAAOjB,KAAK,CAACiB,GAAD,CAAZ,KAAsB,UAA1B,EAAsC;AAClCF,SAAS,CAACE,GAAD,CAAT,GAAiBjB,KAAK,CAACiB,GAAD,CAAtB;AACH;AACF;AACF,GAhBD;AAkBA,SAAOF,CAAP;AACF;;SCtBgBK,qBACd3B,QACA4B,QACAC,SAAY;AAEZ,QAAMtB,KAAK,GAAMqB,MAAM,CAACR,YAAP,GAAuBpB,MAAc,CAACO,KAAf,EAAvB,GAAgDP,MAAM,CAACO,KAAxE;AACAZ,QAAM,CAACC,IAAP,CAAYW,KAAZ,EAAmBgB,OAAnB,CAA4BC,GAAD,IAAI;AAC7B,QAAIjB,KAAK,CAACmB,cAAN,CAAqBF,GAArB,CAAJ,EAA+B;;AAE7B,UAAI,CAAC,WAAD,EAAc,UAAd,EAA0BC,OAA1B,CAAkC,OAAQlB,KAAa,CAACiB,GAAD,CAAvD,MAAkE,CAAC,CAAvE,EAA0E;AACxE7B,cAAM,CAACE,cAAP,CAAsBgC,OAAtB,EAA+BL,GAA/B,EAAoC;AAClC1B,aAAG;AACD,kBAAMgC,IAAI,GAAGF,MAAM,CAACG,IAAP,CAAYC,KAAZ,CAAkB,GAAlB,CAAb;AACA,gBAAIC,IAAI,GAAGJ,OAAO,CAAChB,KAAR,CAAcN,KAAzB;;AACA,iBAAK,IAAI2B,OAAT,IAAoBJ,IAApB,EAA0B;AACxBG,kBAAI,GAAGA,IAAI,CAACC,OAAD,CAAX;AACD;;AACD,mBAAOD,IAAI,CAACT,GAAD,CAAX;AACD;;AARiC,SAApC;AAUD;AACF;AACF,GAhBD;AAiBD;;SAEeW,sBACdnC,QACA4B,QACAC,SAAY;AAEZlC,QAAM,CAACC,IAAP,CAAYI,MAAM,CAACQ,OAAnB,EAAkDe,OAAlD,CAA2DC,GAAD,IAAI;AAC5D,QAAIxB,MAAM,CAACS,UAAX,EAAuB;AACrBd,YAAM,CAACE,cAAP,CAAsBgC,OAAtB,EAA+BL,GAA/B,EAAoC;AAClC1B,WAAG;AACD,iBAAO+B,OAAO,CAAChB,KAAR,CAAcL,OAAd,CAAsB,GAAGoB,MAAM,CAACG,IAAI,IAAIP,GAAG,EAA3C,CAAP;AACD;;AAHiC,OAApC;AAKD,KAND,MAMO;AACL7B,YAAM,CAACE,cAAP,CAAsBgC,OAAtB,EAA+BL,GAA/B,EAAoC;AAClC1B,WAAG;AACD,iBAAO+B,OAAO,CAAChB,KAAR,CAAcL,OAAd,CAAsBgB,GAAtB,CAAP;AACD;;AAHiC,OAApC;AAKD;AACF,GAdD;AAeD;;SAEeY,wBACdpC,QACA4B,QACAC,SAAY;AAEZlC,QAAM,CAACC,IAAP,CAAYI,MAAM,CAACM,SAAnB,EAAiDiB,OAAjD,CAA0DC,GAAD,IAAI;AAC3D,QAAIxB,MAAM,CAACS,UAAX,EAAuB;AACrBoB,aAAO,CAACL,GAAD,CAAP,GAAe,UAAU,GAAGa,IAAb,EAAwB;AACrCR,eAAO,CAAChB,KAAR,CAAcyB,MAAd,CAAqB,GAAGV,MAAM,CAACG,IAAI,IAAIP,GAAG,EAA1C,EAA8C,GAAGa,IAAjD;AACD,OAFD;AAGD,KAJD,MAIO;AACLR,aAAO,CAACL,GAAD,CAAP,GAAe,UAAU,GAAGa,IAAb,EAAwB;AACrCR,eAAO,CAAChB,KAAR,CAAcyB,MAAd,CAAqBd,GAArB,EAA0B,GAAGa,IAA7B;AACD,OAFD;AAGD;AACF,GAVD;AAWD;;SAEeE,uBACdvC,QACA4B,QACAC,SAAY;AAEZlC,QAAM,CAACC,IAAP,CAAYI,MAAM,CAACK,OAAnB,EAAkDkB,OAAlD,CAA2DC,GAAD,IAAI;AAC5D,QAAIxB,MAAM,CAACS,UAAX,EAAuB;AACrBoB,aAAO,CAACL,GAAD,CAAP,GAAe,gBAAgB,GAAGa,IAAnB,EAA8B;AAC3C,eAAOR,OAAO,CAAChB,KAAR,CAAc2B,QAAd,CAAuB,GAAGZ,MAAM,CAACG,IAAI,IAAIP,GAAG,EAA5C,EAAgD,GAAGa,IAAnD,CAAP;AACD,OAFD;AAGD,KAJD,MAIO;AACLR,aAAO,CAACL,GAAD,CAAP,GAAe,gBAAgB,GAAGa,IAAnB,EAA8B;AAC3C,eAAOR,OAAO,CAAChB,KAAR,CAAc2B,QAAd,CAAuBhB,GAAvB,EAA4B,GAAGa,IAA/B,CAAP;AACD,OAFD;AAGD;AACF,GAVD;AAWF;;ACzEA,SAASI,qBAAT,CAAkCzC,MAAlC,EAAuD4B,MAAvD,EAAmF;AACjF,MAAI,CAACA,MAAM,CAACG,IAAZ,EAAkB;AAChB,UAAM,IAAI7B,KAAJ,CAAU,kDAAV,CAAN;AACD;;AAED,MAAI,CAAC0B,MAAM,CAACf,KAAZ,EAAmB;AACjB,UAAM,IAAIX,KAAJ,CAAU,mEAAV,CAAN;AACD;;AAED0B,QAAM,CAACf,KAAP,CAAa6B,cAAb,CACEd,MAAM,CAACG,IADT,EACa;AACX/B,QAFF,EAGE;AAAE2C,iBAAa,EAAEf,MAAM,CAACe,aAAP,IAAwB;AAAzC,GAHF;AAKD;;AAED,SAASC,kBAAT,CACEC,YADF,EAEEC,SAFF,EAEmC;AAEjCnD,QAAM,CAACoD,mBAAP,CAA2BD,SAAS,CAACzB,SAArC,EAAgDE,OAAhD,CAAyDyB,QAAD,IAAiB;AACvE,UAAMC,UAAU,GAAGtD,MAAM,CAACuD,wBAAP,CACjBJ,SAAS,CAACzB,SADO,EAEjB2B,QAFiB,CAAnB;;AAIA,QAAIC,UAAU,CAACnD,GAAX,IAAkB+C,YAAY,CAACrC,OAAnC,EAA4C;AAC1CqC,kBAAY,CAACrC,OAAb,CAAqBwC,QAArB,IAAiC,UAC/BzC,KAD+B,EAE/BC,OAF+B,EAG/B2C,SAH+B,EAI/BC,WAJ+B,EAIE;AAEjC,cAAMC,OAAO,GAAG;AAAEC,iBAAO,EAAE;AAAE/C,iBAAF;AAASC,mBAAT;AAAkB2C,qBAAlB;AAA6BC;AAA7B;AAAX,SAAhB;AACA7D,6BAAqB,CAAC8D,OAAD,EAAU9C,KAAV,CAArB;AACAhB,6BAAqB,CAAC8D,OAAD,EAAU7C,OAAV,CAArB;AACA,cAAM+C,GAAG,GAAIN,UAAU,CAACnD,GAAX,CAA4B0D,IAA5B,CAAiCH,OAAjC,CAAb;AACA,eAAOE,GAAP;AACD,OAXD;AAYD;AACF,GAnBD;AAoBD;;AAED,SAASE,sBAAT,CAAmCC,aAAnC,EAA+D;AAC7D,SAAO,UAAsCtD,WAAtC,EAA4D;AACjE,UAAMJ,MAAM,GAA2BI,WAAvC;;AACA,UAAMgB,cAAY,GAAG,MAAMuC,YAAE,CAAC3D,MAAD,CAA7B;;AAEA,QAAI,CAACA,MAAM,CAACO,KAAZ,EAAmB;AACjBP,YAAM,CAACO,KAAP,GAAemD,aAAa,IAAIA,aAAa,CAACtC,YAA/B,GAA8CA,cAA9C,GAA6DA,cAAY,EAAxF;AACD;;AACD,QAAI,CAACpB,MAAM,CAACQ,OAAZ,EAAqB;AACnBR,YAAM,CAACQ,OAAP,GAAiB,EAAjB;AACD;;AACD,QAAI,CAACR,MAAM,CAACS,UAAZ,EAAwB;AACtBT,YAAM,CAACS,UAAP,GAAoBiD,aAAa,IAAIA,aAAa,CAACjD,UAAnD;AACD;;AACD,QAAImD,YAAY,GAAGjE,MAAM,CAACkE,cAAP,CAAsB7D,MAAtB,CAAnB;;AACA,WAAO4D,YAAY,CAAC7B,IAAb,KAAsB,YAAtB,IAAsC6B,YAAY,CAAC7B,IAAb,KAAsB,EAAnE,EAAuE;AACrEa,wBAAkB,CAAC5C,MAAD,EAAS4D,YAAT,CAAlB;AACAA,kBAAY,GAAGjE,MAAM,CAACkE,cAAP,CAAsBD,YAAtB,CAAf;AACD;;AACDhB,sBAAkB,CAAC5C,MAAD,EAASA,MAAT,CAAlB;AACA,UAAM4B,MAAM,GAAG8B,aAAf;;AACA,QAAI9B,MAAM,CAACG,IAAX,EAAiB;AACfpC,YAAM,CAACE,cAAP,CAAsBO,WAAtB,EAAmC,YAAnC,EAAiD;AAC/C0D,aAAK,EAAGjD,KAAD,IAAmB;AACxB,cAAIgB,OAAO,GAAG;AAAEhB,iBAAK,EAAEA,KAAK,IAAIe,MAAM,CAACf;AAAzB,WAAd;;AACA,cAAI,CAACgB,OAAO,CAAChB,KAAb,EAAoB;AAClB,kBAAM,IAAIX,KAAJ,CAAU;;mGAAV,CAAN;AAGD,WANuB;;;;AASxByB,8BAAoB,CAAC3B,MAAD,EAAS4B,MAAT,EAAiBC,OAAjB,CAApB,CATwB;;AAYxB,cAAI7B,MAAM,CAACQ,OAAX,EAAoB;AAClB2B,iCAAqB,CAACnC,MAAD,EAAS4B,MAAT,EAAiBC,OAAjB,CAArB;AACD,WAduB;;;AAiBxB,cAAI7B,MAAM,CAACM,SAAX,EAAsB;AACpB8B,mCAAuB,CAACpC,MAAD,EAAS4B,MAAT,EAAiBC,OAAjB,CAAvB;AACD,WAnBuB;;;AAqBxB,cAAI7B,MAAM,CAACK,OAAX,EAAoB;AAClBkC,kCAAsB,CAACvC,MAAD,EAAS4B,MAAT,EAAiBC,OAAjB,CAAtB;AACD;;AACD,iBAAOA,OAAP;AACD;AA1B8C,OAAjD;AA6BAlC,YAAM,CAACE,cAAP,CAAsBO,WAAtB,EAAmC,gBAAnC,EAAqD;AACnD0D,aAAK,EAAElC,MAAM,CAACG;AADqC,OAArD;AAGD;;AAED,QAAIH,MAAM,CAACmC,OAAX,EAAoB;AAClBtB,2BAAqB,CAACzC,MAAD,EAAS4B,MAAT,CAArB;AACD;;AACD,WAAOxB,WAAP;AACD,GA3DD;AA4DD;;SAKe4D,OAAUC,UAAkD;AAC1E,MAAI,OAAQA,QAAR,KAA6B,UAAjC,EAA6C;;;;AAI3CR,0BAAsB,CAAC,EAAD,CAAtB,CAA2BQ,QAA3B;AACD,GALD,MAKO;;;;AAIL,WAAOR,sBAAsB,CAACQ,QAAD,CAA7B;AACD;AACH;;MCnIaC,MAAM,GAAY;;ACa/B,SAASC,sBAAT,CAAmCC,MAAnC,EAAiE;AAC/D,QAAM;AAAE9B,UAAM,GAAG+B,SAAX;AAAsBC,YAAQ,GAAG,CAAC,CAACJ,MAAM,CAACI,QAA1C;AAAoDC,QAAI,GAAG;AAA3D,MAAqEH,MAAM,IAAI,EAArF;AACA,SAAO,UAAU5E,MAAV,EAA0BgC,GAA1B,EAAgDyB,UAAhD,EAAwF;AAC7F,UAAMjD,MAAM,GAAGR,MAAM,CAACY,WAAtB;;AACA,QAAI,CAACJ,MAAM,CAAC0B,cAAP,CAAsB,SAAtB,CAAL,EAAuC;AACrC1B,YAAM,CAACK,OAAP,GAAiBV,MAAM,CAAC6E,MAAP,CAAc,EAAd,EAAkBxE,MAAM,CAACK,OAAzB,CAAjB;AACD;;AACD,UAAMoE,cAAc,GAAaxB,UAAU,CAACa,KAA5C;;AACA,UAAMY,MAAM,GAA4B,gBACtCpB,OADsC,EAEtCqB,OAFsC,EAEtB;AAEhB,UAAI;AACF,YAAIC,aAAa,GAAG,IAApB;;AAEA,YAAK5E,MAAc,CAACiB,UAApB,EAAgC;AAC9B,gBAAMH,UAAU,GAAGf,aAAa,CAACC,MAAD,CAAhC;AACA,gBAAM6E,cAAc,GAAGvB,OAAO,CAACF,WAAR,CAAoBtC,UAApB,IACnBwC,OAAO,CAACF,WAAR,CAAoBtC,UAApB,CADmB,GAEnBH,SAAS,CAACX,MAAD,CAFb;AAGA6E,wBAAc,CAACvB,OAAf,GAAyBA,OAAzB;AACAsB,uBAAa,GAAG,MAAMH,cAAc,CAACjB,IAAf,CAAoBqB,cAApB,EAAoCF,OAApC,CAAtB;AACD,SAPD,MAOO;AACL,gBAAMtB,OAAO,GAAG;AAAEC;AAAF,WAAhB;AACA/D,+BAAqB,CAAC8D,OAAD,EAAUC,OAAO,CAAC/C,KAAlB,CAArB;AACAhB,+BAAqB,CAAC8D,OAAD,EAAUC,OAAO,CAAC9C,OAAlB,CAArB;AACAoE,uBAAa,GAAG,MAAMH,cAAc,CAACjB,IAAf,CAAoBH,OAApB,EAA6BsB,OAA7B,CAAtB;AACD;;AACD,YAAIrC,MAAJ,EAAY;AACVgB,iBAAO,CAAChB,MAAR,CAAeA,MAAf,EAAuBsC,aAAvB;AACD;;AACD,eAAOA,aAAP;AACD,OApBD,CAoBE,OAAOE,CAAP,EAAe;AACf,cAAMR,QAAQ,GACVQ,CADU,GAEV,IAAI5E,KAAJ,CACE,2DACE,8DADF,GAEE,wCAFF,GAGE,kEAHF,GAIE,wCAJF,GAKE,IALF,GAME,IAAIA,KAAJ,CAAU,4BAA4BsB,GAAG,CAACuD,QAAJ,EAAc,EAApD,EAAwDC,KAN1D,GAOE,IAPF,GAQEF,CAAC,CAACE,KATN,CAFJ;AAaD;AACF,KAvCD;;AAwCAhF,UAAM,CAACK,OAAP,CAAgBmB,GAAhB,IAAiC+C,IAAI,GAAG;AAAEA,UAAF;AAAQU,aAAO,EAAEP;AAAjB,KAAH,GAA+BA,MAApE;AACD,GA/CD;AAgDD;AASD;;;;;;;;;;SAQgBQ,OACdC,gBACA3D,KACAyB,YAA2D;AAE3D,MAAI,CAACzB,GAAD,IAAQ,CAACyB,UAAb,EAAyB;;;;;;;;;;;AAWvB,WAAOkB,sBAAsB,CAACgB,cAAD,CAA7B;AACD,GAZD,MAYO;;;;;;;;;;;AAWLhB,0BAAsB,GAAGgB,cAAH,EAAmB3D,GAAnB,EAAyByB,UAAzB,CAAtB;AACD;AACH;;SC5GgBmC,SACd5F,QACAgC,KACAyB,YAA0D;AAE1D,QAAMjD,MAAM,GAAGR,MAAM,CAACY,WAAtB;;AACA,MAAI,CAACJ,MAAM,CAAC0B,cAAP,CAAsB,WAAtB,CAAL,EAAyC;AACvC1B,UAAM,CAACM,SAAP,GAAmBX,MAAM,CAAC6E,MAAP,CAAc,EAAd,EAAkBxE,MAAM,CAACM,SAAzB,CAAnB;AACD;;AACD,QAAM+E,gBAAgB,GAAapC,UAAU,CAACa,KAA9C;;AACA,QAAMwB,QAAQ,GAAuB,UAAU/E,KAAV,EAAgCoE,OAAhC,EAAgD;AACnFU,oBAAgB,CAAC7B,IAAjB,CAAsBjD,KAAtB,EAA6BoE,OAA7B;AACD,GAFD;;AAGA3E,QAAM,CAACM,SAAP,CAAkBkB,GAAlB,IAAmC8D,QAAnC;AACF;;ACPA,SAASC,8BAAT,CAA0DnB,MAA1D,EAAyF;AACvF,SAAO,UACL5E,MADK,EAELgC,GAFK,EAGLyB,UAHK,EAGmF;AAExF,UAAMjD,MAAM,GAAGR,MAAM,CAACY,WAAtB;;AACA,QAAI,CAACJ,MAAM,CAAC0B,cAAP,CAAsB,WAAtB,CAAL,EAAyC;AACvC1B,YAAM,CAACM,SAAP,GAAmBX,MAAM,CAAC6E,MAAP,CAAc,EAAd,EAAkBxE,MAAM,CAACM,SAAzB,CAAnB;AACD;;AACD,QAAI,CAACN,MAAM,CAAC0B,cAAP,CAAsB,SAAtB,CAAL,EAAuC;AACrC1B,YAAM,CAACK,OAAP,GAAiBV,MAAM,CAAC6E,MAAP,CAAc,EAAd,EAAkBxE,MAAM,CAACK,OAAzB,CAAjB;AACD;;AACD,UAAMmF,cAAc,GAAGvC,UAAU,CAACa,KAAlC;;AAEA,UAAMY,MAAM,GAA4B,gBACtCpB,OADsC,EAEtCqB,OAFsC,EAEtB;AAEhB,UAAI;AACF,cAAMtB,OAAO,GAAG;AAAEC;AAAF,SAAhB;AACA/D,6BAAqB,CAAC8D,OAAD,EAAUC,OAAO,CAAC/C,KAAlB,CAArB;AACAhB,6BAAqB,CAAC8D,OAAD,EAAUC,OAAO,CAAC9C,OAAlB,CAArB;AACA,cAAMoE,aAAa,GAAG,MAAMY,cAAc,CAAChC,IAAf,CAAoBH,OAApB,EAA6BsB,OAA7B,CAA5B;AACA,YAAIC,aAAa,KAAKP,SAAtB,EAAiC;AACjCf,eAAO,CAAChB,MAAR,CAAed,GAAf,EAA8BoD,aAA9B;AACD,OAPD,CAOE,OAAOE,CAAP,EAAe;AACf,YAAIV,MAAM,CAACE,QAAX,EAAqB;AACnB,gBAAMQ,CAAN;AACD,SAFD,MAEO;AACLW,iBAAO,CAACC,KAAR,CAAc,8BAA8BlE,GAAG,CAACuD,QAAJ,EAA5C;AACAU,iBAAO,CAACC,KAAR,CAAcZ,CAAd;AACA,iBAAOa,OAAO,CAACC,MAAR,CAAed,CAAf,CAAP;AACD;AACF;AACF,KApBD;;AAsBA,UAAMQ,QAAQ,GAAuB,UACnC/E,KADmC,EAEnCoE,OAFmC,EAEO;AAE1C,UAAI,CAACP,MAAM,CAACyB,MAAZ,EAAoB;AAClBzB,cAAM,CAACyB,MAAP,GAAgBlG,MAAM,CAACC,IAAP,CAAY+E,OAAZ,CAAhB;AACD;;AACD,WAAK,IAAImB,SAAT,IAAsB1B,MAAM,CAACyB,MAA7B,EAAqC;AACnC,YAAItF,KAAK,CAACmB,cAAN,CAAqBoE,SAArB,KAAmCnB,OAAO,CAACjD,cAAR,CAAuBoE,SAAvB,CAAvC,EAA0E;AACtEvF,eAAW,CAACuF,SAAD,CAAX,GAAyBnB,OAAO,CAACmB,SAAD,CAAhC;AACH,SAFD,MAEO;AACL,gBAAM,IAAI5F,KAAJ,CAAU;;;4BAAV,CAAN;AAID;AACF;AACF,KAjBD;;AAkBAF,UAAM,CAACK,OAAP,CAAgBmB,GAAhB,IAAiC4C,MAAM,CAACG,IAAP,GAAc;AAAEA,UAAI,EAAE,IAAR;AAAcU,aAAO,EAAEP;AAAvB,KAAd,GAAgDA,MAAjF;AACA1E,UAAM,CAACM,SAAP,CAAkBkB,GAAlB,IAAmC8D,QAAnC;AACD,GAxDD;AAyDD;AAgBD;;;;;;;;;;;SASgBS,eACdC,gBACAxE,KACAyB,YAAyF;AAQzF,MAAI,CAACzB,GAAD,IAAQ,CAACyB,UAAb,EAAyB;;;;;;;;;;;AAWvB,WAAOsC,8BAA8B,CAACS,cAAD,CAArC;AACD,GAZD,MAYO;;;;;;;;;;;AAWLT,kCAA8B,CAAC,EAAD,CAA9B,CACES,cADF,EAEExE,GAFF,EAGEyB,UAHF;AAKD;AACH","names":["addPropertiesToObject","target","source","k","Object","keys","defineProperty","get","getModuleName","module","_vmdModuleName","Error","VuexModule","constructor","actions","mutations","state","getters","namespaced","modules","getModule","moduleClass","store","moduleName","_statics","genStatic","_genStatic","storeModule","reservedKeys","stateFactory","prototype","s","forEach","key","indexOf","hasOwnProperty","staticStateGenerator","modOpt","statics","path","name","split","data","segment","staticGetterGenerator","staticMutationGenerator","args","commit","staticActionGenerators","dispatch","registerDynamicModule","registerModule","preserveState","addGettersToModule","targetModule","srcModule","getOwnPropertyNames","funcName","descriptor","getOwnPropertyDescriptor","rootState","rootGetters","thisObj","context","got","call","moduleDecoratorFactory","moduleOptions","sf","parentModule","getPrototypeOf","value","dynamic","Module","modOrOpt","config","actionDecoratorFactory","params","undefined","rawError","root","assign","actionFunction","action","payload","actionPayload","moduleAccessor","e","toString","stack","handler","Action","targetOrParams","Mutation","mutationFunction","mutation","mutationActionDecoratorFactory","mutactFunction","console","error","Promise","reject","mutate","stateItem","MutationAction","paramsOrTarget"],"sources":["../../src/helpers.ts","../../src/vuexmodule.ts","../../src/module/stateFactory.ts","../../src/module/staticGenerators.ts","../../src/module/index.ts","../../src/config.ts","../../src/action.ts","../../src/mutation.ts","../../src/mutationaction.ts"],"sourcesContent":["/**\n * Takes the properties on object from parameter source and adds them to the object\n * parameter target\n * @param {object} target  Object to have properties copied onto from y\n * @param {object} source  Object with properties to be copied to x\n */\nexport function addPropertiesToObject(target: any, source: any) {\n  for (let k of Object.keys(source || {})) {\n    Object.defineProperty(target, k, {\n      get: () => source[k]\n    })\n  }\n}\n\n/**\n * Returns a namespaced name of the module to be used as a store getter\n * @param module\n */\nexport function getModuleName(module: any): string {\n  if (!module._vmdModuleName) {\n    throw new Error(`ERR_GET_MODULE_NAME : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`)\n  }\n  return `vuexModuleDecorators/${module._vmdModuleName}`\n}\n","import {\n  ActionTree,\n  GetterTree,\n  Module as Mod,\n  ModuleTree,\n  MutationTree,\n  Store,\n  ActionContext\n} from 'vuex'\nimport { getModuleName } from './helpers'\n\nexport class VuexModule<S = ThisType<any>, R = any> implements Mod<S, R> {\n  /*\n   * To use with `extends Class` syntax along with decorators\n   */\n  static namespaced?: boolean\n  static state?: any | (() => any)\n  static getters?: GetterTree<any, any>\n  static actions?: ActionTree<any, any>\n  static mutations?: MutationTree<any>\n  static modules?: ModuleTree<any>\n\n  /*\n   * To use with `new VuexModule(<ModuleOptions>{})` syntax\n   */\n\n  modules?: ModuleTree<any>\n  namespaced?: boolean\n  getters?: GetterTree<S, R>\n  state?: S | (() => S)\n  mutations?: MutationTree<S>\n  actions?: ActionTree<S, R>\n  context!: ActionContext<S, R>\n\n  constructor(module: Mod<S, any>) {\n    this.actions = module.actions\n    this.mutations = module.mutations\n    this.state = module.state\n    this.getters = module.getters\n    this.namespaced = module.namespaced\n    this.modules = module.modules\n  }\n}\ntype ConstructorOf<C> = { new (...args: any[]): C }\n\nexport function getModule<M extends VuexModule>(\n  moduleClass: ConstructorOf<M>,\n  store?: Store<any>\n): M {\n  const moduleName = getModuleName(moduleClass)\n  if (store && store.getters[moduleName]) {\n    return store.getters[moduleName]\n  } else if ((moduleClass as any)._statics) {\n    return (moduleClass as any)._statics\n  }\n\n  const genStatic: (providedStore?: Store<any>) => M = (moduleClass as any)._genStatic\n  if (!genStatic) {\n    throw new Error(`ERR_GET_MODULE_NO_STATICS : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`)\n  }\n\n  const storeModule = genStatic(store)\n\n  if (store) {\n    store.getters[moduleName] = storeModule\n  } else {\n    ;(moduleClass as any)._statics = storeModule\n  }\n\n  return storeModule\n}\n","import { Module as Mod } from 'vuex'\n\nconst reservedKeys = ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\nexport function stateFactory<S>(module: Function & Mod<S, any>) {\n  const state = new module.prototype.constructor({})\n  const s = {} as S\n  Object.keys(state).forEach((key: string) => {\n    if (reservedKeys.indexOf(key) !== -1) {\n      if (typeof state[key] !== 'undefined') {\n        throw new Error(\n          `ERR_RESERVED_STATE_KEY_USED: You cannot use the following\n        ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\n        as fields in your module. These are reserved as they have special purpose in Vuex`\n        )\n      }\n      return\n    }\n    if (state.hasOwnProperty(key)) {\n      if (typeof state[key] !== 'function') {\n        ;(s as any)[key] = state[key]\n      }\n    }\n  })\n\n  return s\n}\n","import { ActionTree, GetterTree, Module as Mod, MutationTree } from 'vuex'\nimport { DynamicModuleOptions } from '../moduleoptions'\n\nexport function staticStateGenerator<S extends Object>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  const state: S = modOpt.stateFactory ? (module as any).state() : module.state\n  Object.keys(state).forEach((key) => {\n    if (state.hasOwnProperty(key)) {\n      // If not undefined or function means it is a state value\n      if (['undefined', 'function'].indexOf(typeof (state as any)[key]) === -1) {\n        Object.defineProperty(statics, key, {\n          get() {\n            const path = modOpt.name.split('/')\n            let data = statics.store.state\n            for (let segment of path) {\n              data = data[segment]\n            }\n            return data[key]\n          }\n        })\n      }\n    }\n  })\n}\n\nexport function staticGetterGenerator<S>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  Object.keys(module.getters as GetterTree<S, any>).forEach((key) => {\n    if (module.namespaced) {\n      Object.defineProperty(statics, key, {\n        get() {\n          return statics.store.getters[`${modOpt.name}/${key}`]\n        }\n      })\n    } else {\n      Object.defineProperty(statics, key, {\n        get() {\n          return statics.store.getters[key]\n        }\n      })\n    }\n  })\n}\n\nexport function staticMutationGenerator<S>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  Object.keys(module.mutations as MutationTree<S>).forEach((key) => {\n    if (module.namespaced) {\n      statics[key] = function (...args: any[]) {\n        statics.store.commit(`${modOpt.name}/${key}`, ...args)\n      }\n    } else {\n      statics[key] = function (...args: any[]) {\n        statics.store.commit(key, ...args)\n      }\n    }\n  })\n}\n\nexport function staticActionGenerators<S>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  Object.keys(module.actions as ActionTree<S, any>).forEach((key) => {\n    if (module.namespaced) {\n      statics[key] = async function (...args: any[]) {\n        return statics.store.dispatch(`${modOpt.name}/${key}`, ...args)\n      }\n    } else {\n      statics[key] = async function (...args: any[]) {\n        return statics.store.dispatch(key, ...args)\n      }\n    }\n  })\n}\n","import { GetterTree, Module as Mod, Store } from 'vuex'\nimport { DynamicModuleOptions, ModuleOptions } from '../moduleoptions'\nimport { stateFactory as sf } from './stateFactory'\nimport { addPropertiesToObject } from '../helpers'\nimport {\n  staticActionGenerators,\n  staticGetterGenerator,\n  staticMutationGenerator,\n  staticStateGenerator\n} from './staticGenerators'\n\nfunction registerDynamicModule<S>(module: Mod<S, any>, modOpt: DynamicModuleOptions) {\n  if (!modOpt.name) {\n    throw new Error('Name of module not provided in decorator options')\n  }\n\n  if (!modOpt.store) {\n    throw new Error('Store not provided in decorator options when using dynamic option')\n  }\n\n  modOpt.store.registerModule(\n    modOpt.name, // TODO: Handle nested modules too in future\n    module,\n    { preserveState: modOpt.preserveState || false }\n  )\n}\n\nfunction addGettersToModule<S>(\n  targetModule: Function & Mod<S, any>,\n  srcModule: Function & Mod<S, any>\n) {\n  Object.getOwnPropertyNames(srcModule.prototype).forEach((funcName: string) => {\n    const descriptor = Object.getOwnPropertyDescriptor(\n      srcModule.prototype,\n      funcName\n    ) as PropertyDescriptor\n    if (descriptor.get && targetModule.getters) {\n      targetModule.getters[funcName] = function (\n        state: S,\n        getters: GetterTree<S, any>,\n        rootState: any,\n        rootGetters: GetterTree<any, any>\n      ) {\n        const thisObj = { context: { state, getters, rootState, rootGetters } }\n        addPropertiesToObject(thisObj, state)\n        addPropertiesToObject(thisObj, getters)\n        const got = (descriptor.get as Function).call(thisObj)\n        return got\n      }\n    }\n  })\n}\n\nfunction moduleDecoratorFactory<S>(moduleOptions: ModuleOptions) {\n  return function <TFunction extends Function>(constructor: TFunction): TFunction | void {\n    const module: Function & Mod<S, any> = constructor\n    const stateFactory = () => sf(module)\n\n    if (!module.state) {\n      module.state = moduleOptions && moduleOptions.stateFactory ? stateFactory : stateFactory()\n    }\n    if (!module.getters) {\n      module.getters = {} as GetterTree<S, any>\n    }\n    if (!module.namespaced) {\n      module.namespaced = moduleOptions && moduleOptions.namespaced\n    }\n    let parentModule = Object.getPrototypeOf(module)\n    while (parentModule.name !== 'VuexModule' && parentModule.name !== '') {\n      addGettersToModule(module, parentModule)\n      parentModule = Object.getPrototypeOf(parentModule)\n    }\n    addGettersToModule(module, module)\n    const modOpt = moduleOptions as DynamicModuleOptions\n    if (modOpt.name) {\n      Object.defineProperty(constructor, '_genStatic', {\n        value: (store?: Store<any>) => {\n          let statics = { store: store || modOpt.store }\n          if (!statics.store) {\n            throw new Error(`ERR_STORE_NOT_PROVIDED: To use getModule(), either the module\n            should be decorated with store in decorator, i.e. @Module({store: store}) or\n            store should be passed when calling getModule(), i.e. getModule(MyModule, this.$store)`)\n          }\n          // ===========  For statics ==============\n          // ------ state -------\n          staticStateGenerator(module, modOpt, statics)\n\n          // ------- getters -------\n          if (module.getters) {\n            staticGetterGenerator(module, modOpt, statics)\n          }\n\n          // -------- mutations --------\n          if (module.mutations) {\n            staticMutationGenerator(module, modOpt, statics)\n          }\n          // -------- actions ---------\n          if (module.actions) {\n            staticActionGenerators(module, modOpt, statics)\n          }\n          return statics\n        }\n      })\n\n      Object.defineProperty(constructor, '_vmdModuleName', {\n        value: modOpt.name\n      })\n    }\n\n    if (modOpt.dynamic) {\n      registerDynamicModule(module, modOpt)\n    }\n    return constructor\n  }\n}\n\nexport function Module<S>(module: Function & Mod<S, any>): void\nexport function Module<S>(options: ModuleOptions): ClassDecorator\n\nexport function Module<S>(modOrOpt: ModuleOptions | (Function & Mod<S, any>)) {\n  if (typeof (modOrOpt as any) === 'function') {\n    /*\n     * @Module decorator called without options (directly on the class definition)\n     */\n    moduleDecoratorFactory({})(modOrOpt as Function & Mod<S, any>)\n  } else {\n    /*\n     * @Module({...}) decorator called with options\n     */\n    return moduleDecoratorFactory(modOrOpt)\n  }\n}\n","export const config: IConfig = {}\n\nexport interface IConfig {\n  rawError?: boolean\n}\n","import { Action as Act, ActionContext, Module as Mod, Payload } from 'vuex'\nimport { getModule, VuexModule } from './vuexmodule'\nimport { addPropertiesToObject, getModuleName } from './helpers'\nimport { config } from './config'\n\n/**\n * Parameters that can be passed to the @Action decorator\n */\nexport interface ActionDecoratorParams {\n  commit?: string\n  rawError?: boolean\n  root?: boolean\n}\nfunction actionDecoratorFactory<T>(params?: ActionDecoratorParams): MethodDecorator {\n  const { commit = undefined, rawError = !!config.rawError, root = false } = params || {}\n  return function (target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<any>) {\n    const module = target.constructor as Mod<T, any>\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions)\n    }\n    const actionFunction: Function = descriptor.value\n    const action: Act<typeof target, any> = async function (\n      context: ActionContext<typeof target, any>,\n      payload: Payload\n    ) {\n      try {\n        let actionPayload = null\n\n        if ((module as any)._genStatic) {\n          const moduleName = getModuleName(module)\n          const moduleAccessor = context.rootGetters[moduleName]\n            ? context.rootGetters[moduleName]\n            : getModule(module as typeof VuexModule)\n          moduleAccessor.context = context\n          actionPayload = await actionFunction.call(moduleAccessor, payload)\n        } else {\n          const thisObj = { context }\n          addPropertiesToObject(thisObj, context.state)\n          addPropertiesToObject(thisObj, context.getters)\n          actionPayload = await actionFunction.call(thisObj, payload)\n        }\n        if (commit) {\n          context.commit(commit, actionPayload)\n        }\n        return actionPayload\n      } catch (e: any) {\n        throw rawError\n          ? e\n          : new Error(\n              'ERR_ACTION_ACCESS_UNDEFINED: Are you trying to access ' +\n                'this.someMutation() or this.someGetter inside an @Action? \\n' +\n                'That works only in dynamic modules. \\n' +\n                'If not dynamic use this.context.commit(\"mutationName\", payload) ' +\n                'and this.context.getters[\"getterName\"]' +\n                '\\n' +\n                new Error(`Could not perform action ${key.toString()}`).stack +\n                '\\n' +\n                e.stack\n            )\n      }\n    }\n    module.actions![key as string] = root ? { root, handler: action } : action\n  }\n}\n\nexport function Action<T, R>(\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\n): void\nexport function Action<T>(params: ActionDecoratorParams): MethodDecorator\n\n/**\n * The @Action decorator turns an async function into an Vuex action\n *\n * @param targetOrParams the module class\n * @param key name of the action\n * @param descriptor the action function descriptor\n * @constructor\n */\nexport function Action<T, R>(\n  targetOrParams: T | ActionDecoratorParams,\n  key?: string | symbol,\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => R>\n) {\n  if (!key && !descriptor) {\n    /*\n     * This is the case when `targetOrParams` is params.\n     * i.e. when used as -\n     * <pre>\n        @Action({commit: 'incrCount'})\n        async getCountDelta() {\n          return 5\n        }\n     * </pre>\n     */\n    return actionDecoratorFactory(targetOrParams as ActionDecoratorParams)\n  } else {\n    /*\n     * This is the case when @Action is called on action function\n     * without any params\n     * <pre>\n     *   @Action\n     *   async doSomething() {\n     *    ...\n     *   }\n     * </pre>\n     */\n    actionDecoratorFactory()(targetOrParams, key!, descriptor!)\n  }\n}\n","import { Module as Mod, Mutation as Mut, Payload } from 'vuex'\n\nexport function Mutation<T extends Object, R>(\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\n) {\n  const module = target.constructor as Mod<T, any>\n  if (!module.hasOwnProperty('mutations')) {\n    module.mutations = Object.assign({}, module.mutations)\n  }\n  const mutationFunction: Function = descriptor.value!\n  const mutation: Mut<typeof target> = function (state: typeof target, payload: Payload) {\n    mutationFunction.call(state, payload)\n  }\n  module.mutations![key as string] = mutation\n}\n","import { Action as Act, ActionContext, Module as Mod, Mutation as Mut, Payload, Store } from 'vuex'\nimport { addPropertiesToObject } from './helpers'\n\nexport interface MutationActionParams<M> {\n  mutate?: (keyof Partial<M>)[]\n  rawError?: boolean\n  root?: boolean\n}\n\nfunction mutationActionDecoratorFactory<T extends Object>(params: MutationActionParams<T>) {\n  return function (\n    target: T,\n    key: string | symbol,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T> | undefined>>\n  ) {\n    const module = target.constructor as Mod<T, any>\n    if (!module.hasOwnProperty('mutations')) {\n      module.mutations = Object.assign({}, module.mutations)\n    }\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions)\n    }\n    const mutactFunction = descriptor.value as (payload: any) => Promise<any>\n\n    const action: Act<typeof target, any> = async function (\n      context: ActionContext<typeof target, any>,\n      payload: Payload\n    ) {\n      try {\n        const thisObj = { context }\n        addPropertiesToObject(thisObj, context.state)\n        addPropertiesToObject(thisObj, context.getters)\n        const actionPayload = await mutactFunction.call(thisObj, payload)\n        if (actionPayload === undefined) return\n        context.commit(key as string, actionPayload)\n      } catch (e: any) {\n        if (params.rawError) {\n          throw e\n        } else {\n          console.error('Could not perform action ' + key.toString())\n          console.error(e)\n          return Promise.reject(e)\n        }\n      }\n    }\n\n    const mutation: Mut<typeof target> = function (\n      state: typeof target | Store<T>,\n      payload: Payload & { [k in keyof T]: any }\n    ) {\n      if (!params.mutate) {\n        params.mutate = Object.keys(payload) as (keyof T)[]\n      }\n      for (let stateItem of params.mutate) {\n        if (state.hasOwnProperty(stateItem) && payload.hasOwnProperty(stateItem)) {\n          ;(state as T)[stateItem] = payload[stateItem]\n        } else {\n          throw new Error(`ERR_MUTATE_PARAMS_NOT_IN_PAYLOAD\n          In @MutationAction, mutate: ['a', 'b', ...] array keys must\n          match with return type = {a: {}, b: {}, ...} and must\n          also be in state.`)\n        }\n      }\n    }\n    module.actions![key as string] = params.root ? { root: true, handler: action } : action\n    module.mutations![key as string] = mutation\n  }\n}\n\nexport function MutationAction<K, T extends K>(\n  target: { [k in keyof T]: T[k] | null },\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<K>>\n): void\n\nexport function MutationAction<T>(\n  params: MutationActionParams<T>\n): (\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<T>>\n) => void\n\n/**\n * The @MutationAction decorator turns this into an action that further calls a mutation\n * Both the action and the mutation are generated for you\n *\n * @param paramsOrTarget the params or the target class\n * @param key the name of the function\n * @param descriptor the function body\n * @constructor\n */\nexport function MutationAction<T, K, M extends K>(\n  paramsOrTarget: MutationActionParams<T> | M,\n  key?: string | symbol,\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<K> | undefined>>\n):\n  | ((\n      target: T,\n      key: string | symbol,\n      descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T> | undefined>>\n    ) => void)\n  | void {\n  if (!key && !descriptor) {\n    /*\n     * This is the case when `paramsOrTarget` is params.\n     * i.e. when used as -\n     * <pre>\n        @MutationAction({mutate: ['incrCount']})\n        async getCountDelta() {\n          return {incrCount: 5}\n        }\n     * </pre>\n     */\n    return mutationActionDecoratorFactory(paramsOrTarget as MutationActionParams<T>)\n  } else {\n    /*\n     * This is the case when `paramsOrTarget` is target.\n     * i.e. when used as -\n     * <pre>\n        @MutationAction\n        async getCountDelta() {\n          return {incrCount: 5}\n        }\n     * </pre>\n     */\n    mutationActionDecoratorFactory({} as MutationActionParams<K>)(\n      paramsOrTarget as K,\n      key!,\n      descriptor!\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}