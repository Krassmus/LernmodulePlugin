{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\n\n/*! @name m3u8-parser @version 6.2.0 @license Apache-2.0 */\nimport Stream from '@videojs/vhs-utils/es/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array.js';\n/**\n * @file m3u8/line-stream.js\n */\n\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nclass LineStream extends Stream {\n  constructor() {\n    super();\n    this.buffer = '';\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  push(data) {\n    let nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  }\n\n}\n\nconst TAB = String.fromCharCode(0x09);\n\nconst parseByterange = function (byterangeString) {\n  // optionally match and capture 0+ digits before `@`\n  // optionally match and capture 0+ digits after `@`\n  const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n  const result = {};\n\n  if (match[1]) {\n    result.length = parseInt(match[1], 10);\n  }\n\n  if (match[2]) {\n    result.offset = parseInt(match[2], 10);\n  }\n\n  return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nconst attributeSeparator = function () {\n  const key = '[^=]*';\n  const value = '\"[^\"]*\"|[^,]*';\n  const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nconst parseAttributes = function (attributes) {\n  const result = {};\n\n  if (!attributes) {\n    return result;\n  } // split the string using attributes as the separator\n\n\n  const attrs = attributes.split(attributeSeparator());\n  let i = attrs.length;\n  let attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nclass ParseStream extends Stream {\n  constructor() {\n    super();\n    this.customParsers = [];\n    this.tagMappers = [];\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  push(line) {\n    let match;\n    let event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    const newLines = this.tagMappers.reduce((acc, mapper) => {\n      const mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(newLine => {\n      for (let i = 0; i < this.customParsers.length; i++) {\n        if (this.customParsers[i].call(this, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        this.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n        return;\n      }\n\n      match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = _extends(parseByterange(match[1]), {\n          type: 'tag',\n          tagType: 'byterange'\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          const attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            event.byterange = parseByterange(attributes.BYTERANGE);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            const split = event.attributes.RESOLUTION.split('x');\n            const resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n\n            event.attributes.RESOLUTION = resolution;\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['FRAME-RATE']) {\n            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-START:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'skip'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n        }\n\n        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['INDEPENDENT', 'GAP'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n\n        if (event.attributes.hasOwnProperty('BYTERANGE')) {\n          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'server-control'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part-inf'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['PART-TARGET'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'preload-hint'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n            event.attributes.byterange = event.attributes.byterange || {};\n            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n            delete event.attributes[key];\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'rendition-report'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'daterange'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['ID', 'CLASS'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = String(event.attributes[key]);\n          }\n        });\n        ['START-DATE', 'END-DATE'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = new Date(event.attributes[key]);\n          }\n        });\n        ['DURATION', 'PLANNED-DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['END-ON-NEXT'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/i.test(event.attributes[key]);\n          }\n        });\n        ['SCTE35-CMD', ' SCTE35-OUT', 'SCTE35-IN'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = event.attributes[key].toString(16);\n          }\n        });\n        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n\n        for (const key in event.attributes) {\n          if (!clientAttributePattern.test(key)) {\n            continue;\n          }\n\n          const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n          const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n          event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'independent-segments'\n        });\n        return;\n      } // unknown tag type\n\n\n      this.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser({\n    expression,\n    customType,\n    dataParser,\n    segment\n  }) {\n    if (typeof dataParser !== 'function') {\n      dataParser = line => line;\n    }\n\n    this.customParsers.push(line => {\n      const match = expression.exec(line);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType,\n          segment\n        });\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper({\n    expression,\n    map\n  }) {\n    const mapFn = line => {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  }\n\n}\n\nconst camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n\nconst camelCaseKeys = function (attributes) {\n  const result = {};\n  Object.keys(attributes).forEach(function (key) {\n    result[camelCase(key)] = attributes[key];\n  });\n  return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\n\n\nconst setHoldBack = function (manifest) {\n  const {\n    serverControl,\n    targetDuration,\n    partTargetDuration\n  } = manifest;\n\n  if (!serverControl) {\n    return;\n  }\n\n  const tag = '#EXT-X-SERVER-CONTROL';\n  const hb = 'holdBack';\n  const phb = 'partHoldBack';\n  const minTargetDuration = targetDuration && targetDuration * 3;\n  const minPartDuration = partTargetDuration && partTargetDuration * 2;\n\n  if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n    serverControl[hb] = minTargetDuration;\n    this.trigger('info', {\n      message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n    });\n  }\n\n  if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n    });\n    serverControl[hb] = minTargetDuration;\n  } // default no part hold back to part target duration * 3\n\n\n  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n    serverControl[phb] = partTargetDuration * 3;\n    this.trigger('info', {\n      message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n    });\n  } // if part hold back is too small default it to part target duration * 2\n\n\n  if (partTargetDuration && serverControl[phb] < minPartDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n    });\n    serverControl[phb] = minPartDuration;\n  }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\n\nclass Parser extends Stream {\n  constructor() {\n    super();\n    this.lineStream = new LineStream();\n    this.parseStream = new ParseStream();\n    this.lineStream.pipe(this.parseStream);\n    /* eslint-disable consistent-this */\n\n    const self = this;\n    /* eslint-enable consistent-this */\n\n    const uris = [];\n    let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    let currentMap; // if specified, the active decryption key\n\n    let key;\n    let hasParts = false;\n\n    const noop = function () {};\n\n    const defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n    let lastPartByterangeEnd = 0;\n    const daterangeTags = {};\n    this.on('end', () => {\n      // only add preloadSegment if we don't yet have a uri for it.\n      // and we actually have parts/preloadHints\n      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n        return;\n      }\n\n      if (!currentUri.map && currentMap) {\n        currentUri.map = currentMap;\n      }\n\n      if (!currentUri.key && key) {\n        currentUri.key = key;\n      }\n\n      if (!currentUri.timeline && typeof currentTimeline === 'number') {\n        currentUri.timeline = currentTimeline;\n      }\n\n      this.manifest.preloadSegment = currentUri;\n    }); // update the manifest with the m3u8 entry from the parse stream\n\n    this.parseStream.on('data', function (entry) {\n      let mediaGroup;\n      let rendition;\n      ({\n        tag() {\n          // switch based on the tag type\n          (({\n            version() {\n              if (entry.version) {\n                this.manifest.version = entry.version;\n              }\n            },\n\n            'allow-cache'() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n\n            byterange() {\n              const byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n\n            endlist() {\n              this.manifest.endList = true;\n            },\n\n            inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n\n            key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                  attributes: entry.attributes\n                };\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.microsoft.playready'] = {\n                  uri: entry.attributes.URI\n                };\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = this.manifest.contentProtection || {};\n                this.manifest.contentProtection['com.widevine.alpha'] = {\n                  attributes: {\n                    schemeIdUri: entry.attributes.KEYFORMAT,\n                    // remove '0x' from the key id string\n                    keyId: entry.attributes.KEYID.substring(2)\n                  },\n                  // decode the base64-encoded PSSH box\n                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                key.iv = entry.attributes.IV;\n              }\n            },\n\n            'media-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n\n            'discontinuity-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n\n            'playlist-type'() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n\n            map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n\n              if (key) {\n                currentMap.key = key;\n              }\n            },\n\n            'stream-inf'() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n\n            media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n\n            discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n\n            'program-date-time'() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n            },\n\n            targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n              setHoldBack.call(this, this.manifest);\n            },\n\n            start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n\n            'cue-out'() {\n              currentUri.cueOut = entry.data;\n            },\n\n            'cue-out-cont'() {\n              currentUri.cueOutCont = entry.data;\n            },\n\n            'cue-in'() {\n              currentUri.cueIn = entry.data;\n            },\n\n            'skip'() {\n              this.manifest.skip = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n            },\n\n            'part'() {\n              hasParts = true; // parts are always specifed before a segment\n\n              const segmentIndex = this.manifest.segments.length;\n              const part = camelCaseKeys(entry.attributes);\n              currentUri.parts = currentUri.parts || [];\n              currentUri.parts.push(part);\n\n              if (part.byterange) {\n                if (!part.byterange.hasOwnProperty('offset')) {\n                  part.byterange.offset = lastPartByterangeEnd;\n                }\n\n                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n              }\n\n              const partIndex = currentUri.parts.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n\n              if (this.manifest.renditionReports) {\n                this.manifest.renditionReports.forEach((r, i) => {\n                  if (!r.hasOwnProperty('lastPart')) {\n                    this.trigger('warn', {\n                      message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                    });\n                  }\n                });\n              }\n            },\n\n            'server-control'() {\n              const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n\n              if (!attrs.hasOwnProperty('canBlockReload')) {\n                attrs.canBlockReload = false;\n                this.trigger('info', {\n                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                });\n              }\n\n              setHoldBack.call(this, this.manifest);\n\n              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                this.trigger('warn', {\n                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                });\n              }\n            },\n\n            'preload-hint'() {\n              // parts are always specifed before a segment\n              const segmentIndex = this.manifest.segments.length;\n              const hint = camelCaseKeys(entry.attributes);\n              const isPart = hint.type && hint.type === 'PART';\n              currentUri.preloadHints = currentUri.preloadHints || [];\n              currentUri.preloadHints.push(hint);\n\n              if (hint.byterange) {\n                if (!hint.byterange.hasOwnProperty('offset')) {\n                  // use last part byterange end or zero if not a part.\n                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n\n                  if (isPart) {\n                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                  }\n                }\n              }\n\n              const index = currentUri.preloadHints.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n\n              if (!hint.type) {\n                return;\n              } // search through all preload hints except for the current one for\n              // a duplicate type.\n\n\n              for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                const otherHint = currentUri.preloadHints[i];\n\n                if (!otherHint.type) {\n                  continue;\n                }\n\n                if (otherHint.type === hint.type) {\n                  this.trigger('warn', {\n                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                  });\n                }\n              }\n            },\n\n            'rendition-report'() {\n              const report = camelCaseKeys(entry.attributes);\n              this.manifest.renditionReports = this.manifest.renditionReports || [];\n              this.manifest.renditionReports.push(report);\n              const index = this.manifest.renditionReports.length - 1;\n              const required = ['LAST-MSN', 'URI'];\n\n              if (hasParts) {\n                required.push('LAST-PART');\n              }\n\n              this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n            },\n\n            'part-inf'() {\n              this.manifest.partInf = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n\n              if (this.manifest.partInf.partTarget) {\n                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n              }\n\n              setHoldBack.call(this, this.manifest);\n            },\n\n            'daterange'() {\n              this.manifest.daterange = this.manifest.daterange || [];\n              this.manifest.daterange.push(camelCaseKeys(entry.attributes));\n              const index = this.manifest.daterange.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ['ID', 'START-DATE']);\n              const daterange = this.manifest.daterange[index];\n\n              if (daterange.endDate && daterange.startDate && new Date(daterange.endDate) < new Date(daterange.startDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE'\n                });\n              }\n\n              if (daterange.duration && daterange.duration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE DURATION must not be negative'\n                });\n              }\n\n              if (daterange.plannedDuration && daterange.plannedDuration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE PLANNED-DURATION must not be negative'\n                });\n              }\n\n              const endOnNextYes = !!daterange.endOnNext;\n\n              if (endOnNextYes && !daterange.class) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute'\n                });\n              }\n\n              if (endOnNextYes && (daterange.duration || daterange.endDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes'\n                });\n              }\n\n              if (daterange.duration && daterange.endDate) {\n                const startDate = daterange.startDate;\n                const newDateInSeconds = startDate.setSeconds(startDate.getSeconds() + daterange.duration);\n                this.manifest.daterange[index].endDate = new Date(newDateInSeconds);\n              }\n\n              if (daterange && !this.manifest.dateTimeString) {\n                this.trigger('warn', {\n                  message: 'A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag'\n                });\n              }\n\n              if (!daterangeTags[daterange.id]) {\n                daterangeTags[daterange.id] = daterange;\n              } else {\n                for (const attribute in daterangeTags[daterange.id]) {\n                  if (daterangeTags[daterange.id][attribute] !== daterange[attribute]) {\n                    this.trigger('warn', {\n                      message: 'EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes and same attribute values'\n                    });\n                    break;\n                  }\n                }\n              }\n            },\n\n            'independent-segments'() {\n              this.manifest.independentSegments = true;\n            }\n\n          })[entry.tagType] || noop).call(self);\n        },\n\n        uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (key) {\n            currentUri.key = key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // reset the last byterange end as it needs to be 0 between parts\n\n\n          lastPartByterangeEnd = 0; // prepare for the next URI\n\n          currentUri = {};\n        },\n\n        comment() {// comments are not important for playback\n        },\n\n        custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n\n      })[entry.type].call(self);\n    });\n  }\n\n  warnOnMissingAttributes_(identifier, attributes, required) {\n    const missing = [];\n    required.forEach(function (key) {\n      if (!attributes.hasOwnProperty(key)) {\n        missing.push(key);\n      }\n    });\n\n    if (missing.length) {\n      this.trigger('warn', {\n        message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n      });\n    }\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n\n  end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n    this.trigger('end');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.type         the type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  }\n\n}\n\nexport { LineStream, ParseStream, Parser };","map":{"version":3,"sources":["/home/ann/dev/studip/54/public/plugins_packages/RasmusFuhse/LernmodulePlugin/vue/node_modules/m3u8-parser/dist/m3u8-parser.es.js"],"names":["Stream","_extends","decodeB64ToUint8Array","LineStream","constructor","buffer","push","data","nextNewline","indexOf","trigger","substring","TAB","String","fromCharCode","parseByterange","byterangeString","match","exec","result","length","parseInt","offset","attributeSeparator","key","value","keyvalue","RegExp","parseAttributes","attributes","attrs","split","i","attr","slice","replace","ParseStream","customParsers","tagMappers","line","event","trim","type","uri","newLines","reduce","acc","mapper","mappedLine","concat","forEach","newLine","call","text","tagType","duration","parseFloat","title","version","number","playlistType","allowed","test","URI","BYTERANGE","byterange","RESOLUTION","resolution","width","height","BANDWIDTH","dateTimeString","dateTimeObject","Date","IV","toLowerCase","Uint32Array","PRECISE","hasOwnProperty","subkey","toString","clientAttributePattern","isHexaDecimal","isDecimalFloating","addParser","expression","customType","dataParser","segment","addTagMapper","map","mapFn","camelCase","str","a","toUpperCase","camelCaseKeys","Object","keys","setHoldBack","manifest","serverControl","targetDuration","partTargetDuration","tag","hb","phb","minTargetDuration","minPartDuration","message","Parser","lineStream","parseStream","pipe","self","uris","currentUri","currentMap","hasParts","noop","defaultMediaGroups","widevineUuid","currentTimeline","allowCache","discontinuityStarts","segments","lastByterangeEnd","lastPartByterangeEnd","daterangeTags","on","parts","preloadHints","timeline","preloadSegment","entry","mediaGroup","rendition","endlist","endList","inf","mediaSequence","discontinuitySequence","METHOD","KEYFORMAT","contentProtection","VALID_METHODS","KEYID","schemeIdUri","keyId","pssh","method","iv","isFinite","playlist","playlists","mediaGroups","media","TYPE","NAME","mediaGroupType","default","DEFAULT","autoselect","AUTOSELECT","LANGUAGE","language","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","discontinuity","targetduration","start","isNaN","timeOffset","precise","cueOut","cueOutCont","cueIn","skip","warnOnMissingAttributes_","segmentIndex","part","partIndex","renditionReports","r","canBlockReload","canSkipDateranges","hint","isPart","index","otherHint","report","required","partInf","partTarget","daterange","endDate","startDate","plannedDuration","endOnNextYes","endOnNext","class","newDateInSeconds","setSeconds","getSeconds","id","attribute","independentSegments","comment","custom","identifier","missing","join","chunk","end","options"],"mappings":"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","sourcesContent":["/*! @name m3u8-parser @version 6.2.0 @license Apache-2.0 */\nimport Stream from '@videojs/vhs-utils/es/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array.js';\n\n/**\n * @file m3u8/line-stream.js\n */\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nclass LineStream extends Stream {\n  constructor() {\n    super();\n    this.buffer = '';\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  push(data) {\n    let nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  }\n\n}\n\nconst TAB = String.fromCharCode(0x09);\n\nconst parseByterange = function (byterangeString) {\n  // optionally match and capture 0+ digits before `@`\n  // optionally match and capture 0+ digits after `@`\n  const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n  const result = {};\n\n  if (match[1]) {\n    result.length = parseInt(match[1], 10);\n  }\n\n  if (match[2]) {\n    result.offset = parseInt(match[2], 10);\n  }\n\n  return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nconst attributeSeparator = function () {\n  const key = '[^=]*';\n  const value = '\"[^\"]*\"|[^,]*';\n  const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nconst parseAttributes = function (attributes) {\n  const result = {};\n\n  if (!attributes) {\n    return result;\n  } // split the string using attributes as the separator\n\n\n  const attrs = attributes.split(attributeSeparator());\n  let i = attrs.length;\n  let attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nclass ParseStream extends Stream {\n  constructor() {\n    super();\n    this.customParsers = [];\n    this.tagMappers = [];\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  push(line) {\n    let match;\n    let event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    const newLines = this.tagMappers.reduce((acc, mapper) => {\n      const mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(newLine => {\n      for (let i = 0; i < this.customParsers.length; i++) {\n        if (this.customParsers[i].call(this, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        this.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n        return;\n      }\n\n      match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = _extends(parseByterange(match[1]), {\n          type: 'tag',\n          tagType: 'byterange'\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          const attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            event.byterange = parseByterange(attributes.BYTERANGE);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            const split = event.attributes.RESOLUTION.split('x');\n            const resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n\n            event.attributes.RESOLUTION = resolution;\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['FRAME-RATE']) {\n            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-START:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'skip'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n        }\n\n        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['INDEPENDENT', 'GAP'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n\n        if (event.attributes.hasOwnProperty('BYTERANGE')) {\n          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'server-control'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part-inf'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['PART-TARGET'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'preload-hint'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n            event.attributes.byterange = event.attributes.byterange || {};\n            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n            delete event.attributes[key];\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'rendition-report'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'daterange'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['ID', 'CLASS'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = String(event.attributes[key]);\n          }\n        });\n        ['START-DATE', 'END-DATE'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = new Date(event.attributes[key]);\n          }\n        });\n        ['DURATION', 'PLANNED-DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['END-ON-NEXT'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/i.test(event.attributes[key]);\n          }\n        });\n        ['SCTE35-CMD', ' SCTE35-OUT', 'SCTE35-IN'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = event.attributes[key].toString(16);\n          }\n        });\n        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n\n        for (const key in event.attributes) {\n          if (!clientAttributePattern.test(key)) {\n            continue;\n          }\n\n          const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n          const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n          event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'independent-segments'\n        });\n        return;\n      } // unknown tag type\n\n\n      this.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser({\n    expression,\n    customType,\n    dataParser,\n    segment\n  }) {\n    if (typeof dataParser !== 'function') {\n      dataParser = line => line;\n    }\n\n    this.customParsers.push(line => {\n      const match = expression.exec(line);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType,\n          segment\n        });\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper({\n    expression,\n    map\n  }) {\n    const mapFn = line => {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  }\n\n}\n\nconst camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n\nconst camelCaseKeys = function (attributes) {\n  const result = {};\n  Object.keys(attributes).forEach(function (key) {\n    result[camelCase(key)] = attributes[key];\n  });\n  return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\n\n\nconst setHoldBack = function (manifest) {\n  const {\n    serverControl,\n    targetDuration,\n    partTargetDuration\n  } = manifest;\n\n  if (!serverControl) {\n    return;\n  }\n\n  const tag = '#EXT-X-SERVER-CONTROL';\n  const hb = 'holdBack';\n  const phb = 'partHoldBack';\n  const minTargetDuration = targetDuration && targetDuration * 3;\n  const minPartDuration = partTargetDuration && partTargetDuration * 2;\n\n  if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n    serverControl[hb] = minTargetDuration;\n    this.trigger('info', {\n      message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n    });\n  }\n\n  if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n    });\n    serverControl[hb] = minTargetDuration;\n  } // default no part hold back to part target duration * 3\n\n\n  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n    serverControl[phb] = partTargetDuration * 3;\n    this.trigger('info', {\n      message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n    });\n  } // if part hold back is too small default it to part target duration * 2\n\n\n  if (partTargetDuration && serverControl[phb] < minPartDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n    });\n    serverControl[phb] = minPartDuration;\n  }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\n\nclass Parser extends Stream {\n  constructor() {\n    super();\n    this.lineStream = new LineStream();\n    this.parseStream = new ParseStream();\n    this.lineStream.pipe(this.parseStream);\n    /* eslint-disable consistent-this */\n\n    const self = this;\n    /* eslint-enable consistent-this */\n\n    const uris = [];\n    let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    let currentMap; // if specified, the active decryption key\n\n    let key;\n    let hasParts = false;\n\n    const noop = function () {};\n\n    const defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n    let lastPartByterangeEnd = 0;\n    const daterangeTags = {};\n    this.on('end', () => {\n      // only add preloadSegment if we don't yet have a uri for it.\n      // and we actually have parts/preloadHints\n      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n        return;\n      }\n\n      if (!currentUri.map && currentMap) {\n        currentUri.map = currentMap;\n      }\n\n      if (!currentUri.key && key) {\n        currentUri.key = key;\n      }\n\n      if (!currentUri.timeline && typeof currentTimeline === 'number') {\n        currentUri.timeline = currentTimeline;\n      }\n\n      this.manifest.preloadSegment = currentUri;\n    }); // update the manifest with the m3u8 entry from the parse stream\n\n    this.parseStream.on('data', function (entry) {\n      let mediaGroup;\n      let rendition;\n      ({\n        tag() {\n          // switch based on the tag type\n          (({\n            version() {\n              if (entry.version) {\n                this.manifest.version = entry.version;\n              }\n            },\n\n            'allow-cache'() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n\n            byterange() {\n              const byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n\n            endlist() {\n              this.manifest.endList = true;\n            },\n\n            inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n\n            key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                  attributes: entry.attributes\n                };\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.microsoft.playready'] = {\n                  uri: entry.attributes.URI\n                };\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = this.manifest.contentProtection || {};\n                this.manifest.contentProtection['com.widevine.alpha'] = {\n                  attributes: {\n                    schemeIdUri: entry.attributes.KEYFORMAT,\n                    // remove '0x' from the key id string\n                    keyId: entry.attributes.KEYID.substring(2)\n                  },\n                  // decode the base64-encoded PSSH box\n                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                key.iv = entry.attributes.IV;\n              }\n            },\n\n            'media-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n\n            'discontinuity-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n\n            'playlist-type'() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n\n            map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n\n              if (key) {\n                currentMap.key = key;\n              }\n            },\n\n            'stream-inf'() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n\n            media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n\n            discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n\n            'program-date-time'() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n            },\n\n            targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n              setHoldBack.call(this, this.manifest);\n            },\n\n            start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n\n            'cue-out'() {\n              currentUri.cueOut = entry.data;\n            },\n\n            'cue-out-cont'() {\n              currentUri.cueOutCont = entry.data;\n            },\n\n            'cue-in'() {\n              currentUri.cueIn = entry.data;\n            },\n\n            'skip'() {\n              this.manifest.skip = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n            },\n\n            'part'() {\n              hasParts = true; // parts are always specifed before a segment\n\n              const segmentIndex = this.manifest.segments.length;\n              const part = camelCaseKeys(entry.attributes);\n              currentUri.parts = currentUri.parts || [];\n              currentUri.parts.push(part);\n\n              if (part.byterange) {\n                if (!part.byterange.hasOwnProperty('offset')) {\n                  part.byterange.offset = lastPartByterangeEnd;\n                }\n\n                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n              }\n\n              const partIndex = currentUri.parts.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n\n              if (this.manifest.renditionReports) {\n                this.manifest.renditionReports.forEach((r, i) => {\n                  if (!r.hasOwnProperty('lastPart')) {\n                    this.trigger('warn', {\n                      message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                    });\n                  }\n                });\n              }\n            },\n\n            'server-control'() {\n              const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n\n              if (!attrs.hasOwnProperty('canBlockReload')) {\n                attrs.canBlockReload = false;\n                this.trigger('info', {\n                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                });\n              }\n\n              setHoldBack.call(this, this.manifest);\n\n              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                this.trigger('warn', {\n                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                });\n              }\n            },\n\n            'preload-hint'() {\n              // parts are always specifed before a segment\n              const segmentIndex = this.manifest.segments.length;\n              const hint = camelCaseKeys(entry.attributes);\n              const isPart = hint.type && hint.type === 'PART';\n              currentUri.preloadHints = currentUri.preloadHints || [];\n              currentUri.preloadHints.push(hint);\n\n              if (hint.byterange) {\n                if (!hint.byterange.hasOwnProperty('offset')) {\n                  // use last part byterange end or zero if not a part.\n                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n\n                  if (isPart) {\n                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                  }\n                }\n              }\n\n              const index = currentUri.preloadHints.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n\n              if (!hint.type) {\n                return;\n              } // search through all preload hints except for the current one for\n              // a duplicate type.\n\n\n              for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                const otherHint = currentUri.preloadHints[i];\n\n                if (!otherHint.type) {\n                  continue;\n                }\n\n                if (otherHint.type === hint.type) {\n                  this.trigger('warn', {\n                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                  });\n                }\n              }\n            },\n\n            'rendition-report'() {\n              const report = camelCaseKeys(entry.attributes);\n              this.manifest.renditionReports = this.manifest.renditionReports || [];\n              this.manifest.renditionReports.push(report);\n              const index = this.manifest.renditionReports.length - 1;\n              const required = ['LAST-MSN', 'URI'];\n\n              if (hasParts) {\n                required.push('LAST-PART');\n              }\n\n              this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n            },\n\n            'part-inf'() {\n              this.manifest.partInf = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n\n              if (this.manifest.partInf.partTarget) {\n                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n              }\n\n              setHoldBack.call(this, this.manifest);\n            },\n\n            'daterange'() {\n              this.manifest.daterange = this.manifest.daterange || [];\n              this.manifest.daterange.push(camelCaseKeys(entry.attributes));\n              const index = this.manifest.daterange.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ['ID', 'START-DATE']);\n              const daterange = this.manifest.daterange[index];\n\n              if (daterange.endDate && daterange.startDate && new Date(daterange.endDate) < new Date(daterange.startDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE'\n                });\n              }\n\n              if (daterange.duration && daterange.duration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE DURATION must not be negative'\n                });\n              }\n\n              if (daterange.plannedDuration && daterange.plannedDuration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE PLANNED-DURATION must not be negative'\n                });\n              }\n\n              const endOnNextYes = !!daterange.endOnNext;\n\n              if (endOnNextYes && !daterange.class) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute'\n                });\n              }\n\n              if (endOnNextYes && (daterange.duration || daterange.endDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes'\n                });\n              }\n\n              if (daterange.duration && daterange.endDate) {\n                const startDate = daterange.startDate;\n                const newDateInSeconds = startDate.setSeconds(startDate.getSeconds() + daterange.duration);\n                this.manifest.daterange[index].endDate = new Date(newDateInSeconds);\n              }\n\n              if (daterange && !this.manifest.dateTimeString) {\n                this.trigger('warn', {\n                  message: 'A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag'\n                });\n              }\n\n              if (!daterangeTags[daterange.id]) {\n                daterangeTags[daterange.id] = daterange;\n              } else {\n                for (const attribute in daterangeTags[daterange.id]) {\n                  if (daterangeTags[daterange.id][attribute] !== daterange[attribute]) {\n                    this.trigger('warn', {\n                      message: 'EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes and same attribute values'\n                    });\n                    break;\n                  }\n                }\n              }\n            },\n\n            'independent-segments'() {\n              this.manifest.independentSegments = true;\n            }\n\n          })[entry.tagType] || noop).call(self);\n        },\n\n        uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (key) {\n            currentUri.key = key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // reset the last byterange end as it needs to be 0 between parts\n\n\n          lastPartByterangeEnd = 0; // prepare for the next URI\n\n          currentUri = {};\n        },\n\n        comment() {// comments are not important for playback\n        },\n\n        custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n\n      })[entry.type].call(self);\n    });\n  }\n\n  warnOnMissingAttributes_(identifier, attributes, required) {\n    const missing = [];\n    required.forEach(function (key) {\n      if (!attributes.hasOwnProperty(key)) {\n        missing.push(key);\n      }\n    });\n\n    if (missing.length) {\n      this.trigger('warn', {\n        message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n      });\n    }\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n\n  end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n    this.trigger('end');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.type         the type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  }\n\n}\n\nexport { LineStream, ParseStream, Parser };\n"]},"metadata":{},"sourceType":"module"}