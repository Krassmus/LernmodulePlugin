{"ast":null,"code":"import { toUint8, bytesMatch } from './byte-helpers.js';\nimport { findBox } from './mp4-helpers.js';\nimport { findEbml, EBML_TAGS } from './ebml-helpers.js';\nimport { getId3Offset } from './id3-helpers.js';\nimport { findH264Nal, findH265Nal } from './nal-helpers.js';\nvar CONSTANTS = {\n  // \"webm\" string literal in hex\n  'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\n  // \"matroska\" string literal in hex\n  'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n  // \"fLaC\" string literal in hex\n  'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\n  // \"OggS\" string literal in hex\n  'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\n  // ac-3 sync byte, also works for ec-3 as that is simply a codec\n  // of ac-3\n  'ac3': toUint8([0x0b, 0x77]),\n  // \"RIFF\" string literal in hex used for wav and avi\n  'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\n  // \"AVI\" string literal in hex\n  'avi': toUint8([0x41, 0x56, 0x49]),\n  // \"WAVE\" string literal in hex\n  'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\n  // \"ftyp3g\" string literal in hex\n  '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n  // \"ftyp\" string literal in hex\n  'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\n  // \"styp\" string literal in hex\n  'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\n  // \"ftypqt\" string literal in hex\n  'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\n  // moov string literal in hex\n  'moov': toUint8([0x6D, 0x6F, 0x6F, 0x76]),\n  // moof string literal in hex\n  'moof': toUint8([0x6D, 0x6F, 0x6F, 0x66])\n};\nvar _isLikely = {\n  aac: function aac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x10], {\n      offset: offset,\n      mask: [0xFF, 0x16]\n    });\n  },\n  mp3: function mp3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x02], {\n      offset: offset,\n      mask: [0xFF, 0x06]\n    });\n  },\n  webm: function webm(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n    return bytesMatch(docType, CONSTANTS.webm);\n  },\n  mkv: function mkv(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n    return bytesMatch(docType, CONSTANTS.matroska);\n  },\n  mp4: function mp4(bytes) {\n    // if this file is another base media file format, it is not mp4\n    if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\n      return false;\n    } // if this file starts with a ftyp or styp box its mp4\n\n\n    if (bytesMatch(bytes, CONSTANTS.mp4, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.fmp4, {\n      offset: 4\n    })) {\n      return true;\n    } // if this file starts with a moof/moov box its mp4\n\n\n    if (bytesMatch(bytes, CONSTANTS.moof, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.moov, {\n      offset: 4\n    })) {\n      return true;\n    }\n  },\n  mov: function mov(bytes) {\n    return bytesMatch(bytes, CONSTANTS.mov, {\n      offset: 4\n    });\n  },\n  '3gp': function gp(bytes) {\n    return bytesMatch(bytes, CONSTANTS['3gp'], {\n      offset: 4\n    });\n  },\n  ac3: function ac3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.ac3, {\n      offset: offset\n    });\n  },\n  ts: function ts(bytes) {\n    if (bytes.length < 189 && bytes.length >= 1) {\n      return bytes[0] === 0x47;\n    }\n\n    var i = 0; // check the first 376 bytes for two matching sync bytes\n\n    while (i + 188 < bytes.length && i < 188) {\n      if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n        return true;\n      }\n\n      i += 1;\n    }\n\n    return false;\n  },\n  flac: function flac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.flac, {\n      offset: offset\n    });\n  },\n  ogg: function ogg(bytes) {\n    return bytesMatch(bytes, CONSTANTS.ogg);\n  },\n  avi: function avi(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\n      offset: 8\n    });\n  },\n  wav: function wav(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\n      offset: 8\n    });\n  },\n  'h264': function h264(bytes) {\n    // find seq_parameter_set_rbsp\n    return findH264Nal(bytes, 7, 3).length;\n  },\n  'h265': function h265(bytes) {\n    // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n    return findH265Nal(bytes, [32, 33], 3).length;\n  }\n}; // get all the isLikely functions\n// but make sure 'ts' is above h264 and h265\n// but below everything else as it is the least specific\n\nvar isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n.filter(function (t) {\n  return t !== 'ts' && t !== 'h264' && t !== 'h265';\n}) // add it back to the bottom\n.concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\nisLikelyTypes.forEach(function (type) {\n  var isLikelyFn = _isLikely[type];\n\n  _isLikely[type] = function (bytes) {\n    return isLikelyFn(toUint8(bytes));\n  };\n}); // export after wrapping\n\nexport var isLikely = _isLikely; // A useful list of file signatures can be found here\n// https://en.wikipedia.org/wiki/List_of_file_signatures\n\nexport var detectContainerForBytes = function detectContainerForBytes(bytes) {\n  bytes = toUint8(bytes);\n\n  for (var i = 0; i < isLikelyTypes.length; i++) {\n    var type = isLikelyTypes[i];\n\n    if (isLikely[type](bytes)) {\n      return type;\n    }\n  }\n\n  return '';\n}; // fmp4 is not a container\n\nexport var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n  return findBox(bytes, ['moof']).length > 0;\n};","map":{"version":3,"sources":["/home/ann/dev/studip/54/public/plugins_packages/RasmusFuhse/LernmodulePlugin/vue/node_modules/@videojs/vhs-utils/es/containers.js"],"names":["toUint8","bytesMatch","findBox","findEbml","EBML_TAGS","getId3Offset","findH264Nal","findH265Nal","CONSTANTS","_isLikely","aac","bytes","offset","mask","mp3","webm","docType","EBML","DocType","mkv","matroska","mp4","mov","fmp4","moof","moov","gp","ac3","ts","length","i","flac","ogg","avi","riff","wav","h264","h265","isLikelyTypes","Object","keys","filter","t","concat","forEach","type","isLikelyFn","isLikely","detectContainerForBytes","isLikelyFmp4MediaSegment"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,UAAlB,QAAoC,mBAApC;AACA,SAASC,OAAT,QAAwB,kBAAxB;AACA,SAASC,QAAT,EAAmBC,SAAnB,QAAoC,mBAApC;AACA,SAASC,YAAT,QAA6B,kBAA7B;AACA,SAASC,WAAT,EAAsBC,WAAtB,QAAyC,kBAAzC;AACA,IAAIC,SAAS,GAAG;AACd;AACA,UAAQR,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAFD;AAGd;AACA,cAAYA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAD,CAJL;AAKd;AACA,UAAQA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAND;AAOd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CARA;AASd;AACA;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,CAAD,CAXA;AAYd;AACA,UAAQA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAbD;AAcd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAD,CAfA;AAgBd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAjBA;AAkBd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,CAAD,CAnBA;AAoBd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CArBA;AAsBd;AACA,UAAQA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAvBD;AAwBd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,CAAD,CAzBA;AA0Bd;AACA,UAAQA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CA3BD;AA4Bd;AACA,UAAQA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD;AA7BD,CAAhB;AA+BA,IAAIS,SAAS,GAAG;AACdC,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaC,KAAb,EAAoB;AACvB,QAAIC,MAAM,GAAGP,YAAY,CAACM,KAAD,CAAzB;AACA,WAAOV,UAAU,CAACU,KAAD,EAAQ,CAAC,IAAD,EAAO,IAAP,CAAR,EAAsB;AACrCC,MAAAA,MAAM,EAAEA,MAD6B;AAErCC,MAAAA,IAAI,EAAE,CAAC,IAAD,EAAO,IAAP;AAF+B,KAAtB,CAAjB;AAID,GAPa;AAQdC,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaH,KAAb,EAAoB;AACvB,QAAIC,MAAM,GAAGP,YAAY,CAACM,KAAD,CAAzB;AACA,WAAOV,UAAU,CAACU,KAAD,EAAQ,CAAC,IAAD,EAAO,IAAP,CAAR,EAAsB;AACrCC,MAAAA,MAAM,EAAEA,MAD6B;AAErCC,MAAAA,IAAI,EAAE,CAAC,IAAD,EAAO,IAAP;AAF+B,KAAtB,CAAjB;AAID,GAda;AAedE,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAcJ,KAAd,EAAqB;AACzB,QAAIK,OAAO,GAAGb,QAAQ,CAACQ,KAAD,EAAQ,CAACP,SAAS,CAACa,IAAX,EAAiBb,SAAS,CAACc,OAA3B,CAAR,CAAR,CAAqD,CAArD,CAAd,CADyB,CAC8C;;AAEvE,WAAOjB,UAAU,CAACe,OAAD,EAAUR,SAAS,CAACO,IAApB,CAAjB;AACD,GAnBa;AAoBdI,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaR,KAAb,EAAoB;AACvB,QAAIK,OAAO,GAAGb,QAAQ,CAACQ,KAAD,EAAQ,CAACP,SAAS,CAACa,IAAX,EAAiBb,SAAS,CAACc,OAA3B,CAAR,CAAR,CAAqD,CAArD,CAAd,CADuB,CACgD;;AAEvE,WAAOjB,UAAU,CAACe,OAAD,EAAUR,SAAS,CAACY,QAApB,CAAjB;AACD,GAxBa;AAyBdC,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaV,KAAb,EAAoB;AACvB;AACA,QAAIF,SAAS,CAAC,KAAD,CAAT,CAAiBE,KAAjB,KAA2BF,SAAS,CAACa,GAAV,CAAcX,KAAd,CAA/B,EAAqD;AACnD,aAAO,KAAP;AACD,KAJsB,CAIrB;;;AAGF,QAAIV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACa,GAAlB,EAAuB;AACnCT,MAAAA,MAAM,EAAE;AAD2B,KAAvB,CAAV,IAEEX,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACe,IAAlB,EAAwB;AACtCX,MAAAA,MAAM,EAAE;AAD8B,KAAxB,CAFhB,EAII;AACF,aAAO,IAAP;AACD,KAbsB,CAarB;;;AAGF,QAAIX,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACgB,IAAlB,EAAwB;AACpCZ,MAAAA,MAAM,EAAE;AAD4B,KAAxB,CAAV,IAEEX,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACiB,IAAlB,EAAwB;AACtCb,MAAAA,MAAM,EAAE;AAD8B,KAAxB,CAFhB,EAII;AACF,aAAO,IAAP;AACD;AACF,GAhDa;AAiDdU,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaX,KAAb,EAAoB;AACvB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACc,GAAlB,EAAuB;AACtCV,MAAAA,MAAM,EAAE;AAD8B,KAAvB,CAAjB;AAGD,GArDa;AAsDd,SAAO,SAASc,EAAT,CAAYf,KAAZ,EAAmB;AACxB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAAC,KAAD,CAAjB,EAA0B;AACzCI,MAAAA,MAAM,EAAE;AADiC,KAA1B,CAAjB;AAGD,GA1Da;AA2Dde,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAahB,KAAb,EAAoB;AACvB,QAAIC,MAAM,GAAGP,YAAY,CAACM,KAAD,CAAzB;AACA,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACmB,GAAlB,EAAuB;AACtCf,MAAAA,MAAM,EAAEA;AAD8B,KAAvB,CAAjB;AAGD,GAhEa;AAiEdgB,EAAAA,EAAE,EAAE,SAASA,EAAT,CAAYjB,KAAZ,EAAmB;AACrB,QAAIA,KAAK,CAACkB,MAAN,GAAe,GAAf,IAAsBlB,KAAK,CAACkB,MAAN,IAAgB,CAA1C,EAA6C;AAC3C,aAAOlB,KAAK,CAAC,CAAD,CAAL,KAAa,IAApB;AACD;;AAED,QAAImB,CAAC,GAAG,CAAR,CALqB,CAKV;;AAEX,WAAOA,CAAC,GAAG,GAAJ,GAAUnB,KAAK,CAACkB,MAAhB,IAA0BC,CAAC,GAAG,GAArC,EAA0C;AACxC,UAAInB,KAAK,CAACmB,CAAD,CAAL,KAAa,IAAb,IAAqBnB,KAAK,CAACmB,CAAC,GAAG,GAAL,CAAL,KAAmB,IAA5C,EAAkD;AAChD,eAAO,IAAP;AACD;;AAEDA,MAAAA,CAAC,IAAI,CAAL;AACD;;AAED,WAAO,KAAP;AACD,GAjFa;AAkFdC,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAcpB,KAAd,EAAqB;AACzB,QAAIC,MAAM,GAAGP,YAAY,CAACM,KAAD,CAAzB;AACA,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACuB,IAAlB,EAAwB;AACvCnB,MAAAA,MAAM,EAAEA;AAD+B,KAAxB,CAAjB;AAGD,GAvFa;AAwFdoB,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAarB,KAAb,EAAoB;AACvB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACwB,GAAlB,CAAjB;AACD,GA1Fa;AA2FdC,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAatB,KAAb,EAAoB;AACvB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAAC0B,IAAlB,CAAV,IAAqCjC,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACyB,GAAlB,EAAuB;AAC3ErB,MAAAA,MAAM,EAAE;AADmE,KAAvB,CAAtD;AAGD,GA/Fa;AAgGduB,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaxB,KAAb,EAAoB;AACvB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAAC0B,IAAlB,CAAV,IAAqCjC,UAAU,CAACU,KAAD,EAAQH,SAAS,CAAC2B,GAAlB,EAAuB;AAC3EvB,MAAAA,MAAM,EAAE;AADmE,KAAvB,CAAtD;AAGD,GApGa;AAqGd,UAAQ,SAASwB,IAAT,CAAczB,KAAd,EAAqB;AAC3B;AACA,WAAOL,WAAW,CAACK,KAAD,EAAQ,CAAR,EAAW,CAAX,CAAX,CAAyBkB,MAAhC;AACD,GAxGa;AAyGd,UAAQ,SAASQ,IAAT,CAAc1B,KAAd,EAAqB;AAC3B;AACA,WAAOJ,WAAW,CAACI,KAAD,EAAQ,CAAC,EAAD,EAAK,EAAL,CAAR,EAAkB,CAAlB,CAAX,CAAgCkB,MAAvC;AACD;AA5Ga,CAAhB,C,CA6GG;AACH;AACA;;AAEA,IAAIS,aAAa,GAAGC,MAAM,CAACC,IAAP,CAAY/B,SAAZ,EAAuB;AAAvB,CACnBgC,MADmB,CACZ,UAAUC,CAAV,EAAa;AACnB,SAAOA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAK,MAApB,IAA8BA,CAAC,KAAK,MAA3C;AACD,CAHmB,EAGjB;AAHiB,CAInBC,MAJmB,CAIZ,CAAC,IAAD,EAAO,MAAP,EAAe,MAAf,CAJY,CAApB,C,CAIiC;;AAEjCL,aAAa,CAACM,OAAd,CAAsB,UAAUC,IAAV,EAAgB;AACpC,MAAIC,UAAU,GAAGrC,SAAS,CAACoC,IAAD,CAA1B;;AAEApC,EAAAA,SAAS,CAACoC,IAAD,CAAT,GAAkB,UAAUlC,KAAV,EAAiB;AACjC,WAAOmC,UAAU,CAAC9C,OAAO,CAACW,KAAD,CAAR,CAAjB;AACD,GAFD;AAGD,CAND,E,CAMI;;AAEJ,OAAO,IAAIoC,QAAQ,GAAGtC,SAAf,C,CAA0B;AACjC;;AAEA,OAAO,IAAIuC,uBAAuB,GAAG,SAASA,uBAAT,CAAiCrC,KAAjC,EAAwC;AAC3EA,EAAAA,KAAK,GAAGX,OAAO,CAACW,KAAD,CAAf;;AAEA,OAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,aAAa,CAACT,MAAlC,EAA0CC,CAAC,EAA3C,EAA+C;AAC7C,QAAIe,IAAI,GAAGP,aAAa,CAACR,CAAD,CAAxB;;AAEA,QAAIiB,QAAQ,CAACF,IAAD,CAAR,CAAelC,KAAf,CAAJ,EAA2B;AACzB,aAAOkC,IAAP;AACD;AACF;;AAED,SAAO,EAAP;AACD,CAZM,C,CAYJ;;AAEH,OAAO,IAAII,wBAAwB,GAAG,SAASA,wBAAT,CAAkCtC,KAAlC,EAAyC;AAC7E,SAAOT,OAAO,CAACS,KAAD,EAAQ,CAAC,MAAD,CAAR,CAAP,CAAyBkB,MAAzB,GAAkC,CAAzC;AACD,CAFM","sourcesContent":["import { toUint8, bytesMatch } from './byte-helpers.js';\nimport { findBox } from './mp4-helpers.js';\nimport { findEbml, EBML_TAGS } from './ebml-helpers.js';\nimport { getId3Offset } from './id3-helpers.js';\nimport { findH264Nal, findH265Nal } from './nal-helpers.js';\nvar CONSTANTS = {\n  // \"webm\" string literal in hex\n  'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\n  // \"matroska\" string literal in hex\n  'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n  // \"fLaC\" string literal in hex\n  'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\n  // \"OggS\" string literal in hex\n  'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\n  // ac-3 sync byte, also works for ec-3 as that is simply a codec\n  // of ac-3\n  'ac3': toUint8([0x0b, 0x77]),\n  // \"RIFF\" string literal in hex used for wav and avi\n  'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\n  // \"AVI\" string literal in hex\n  'avi': toUint8([0x41, 0x56, 0x49]),\n  // \"WAVE\" string literal in hex\n  'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\n  // \"ftyp3g\" string literal in hex\n  '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n  // \"ftyp\" string literal in hex\n  'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\n  // \"styp\" string literal in hex\n  'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\n  // \"ftypqt\" string literal in hex\n  'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\n  // moov string literal in hex\n  'moov': toUint8([0x6D, 0x6F, 0x6F, 0x76]),\n  // moof string literal in hex\n  'moof': toUint8([0x6D, 0x6F, 0x6F, 0x66])\n};\nvar _isLikely = {\n  aac: function aac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x10], {\n      offset: offset,\n      mask: [0xFF, 0x16]\n    });\n  },\n  mp3: function mp3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x02], {\n      offset: offset,\n      mask: [0xFF, 0x06]\n    });\n  },\n  webm: function webm(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n    return bytesMatch(docType, CONSTANTS.webm);\n  },\n  mkv: function mkv(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n    return bytesMatch(docType, CONSTANTS.matroska);\n  },\n  mp4: function mp4(bytes) {\n    // if this file is another base media file format, it is not mp4\n    if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\n      return false;\n    } // if this file starts with a ftyp or styp box its mp4\n\n\n    if (bytesMatch(bytes, CONSTANTS.mp4, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.fmp4, {\n      offset: 4\n    })) {\n      return true;\n    } // if this file starts with a moof/moov box its mp4\n\n\n    if (bytesMatch(bytes, CONSTANTS.moof, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.moov, {\n      offset: 4\n    })) {\n      return true;\n    }\n  },\n  mov: function mov(bytes) {\n    return bytesMatch(bytes, CONSTANTS.mov, {\n      offset: 4\n    });\n  },\n  '3gp': function gp(bytes) {\n    return bytesMatch(bytes, CONSTANTS['3gp'], {\n      offset: 4\n    });\n  },\n  ac3: function ac3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.ac3, {\n      offset: offset\n    });\n  },\n  ts: function ts(bytes) {\n    if (bytes.length < 189 && bytes.length >= 1) {\n      return bytes[0] === 0x47;\n    }\n\n    var i = 0; // check the first 376 bytes for two matching sync bytes\n\n    while (i + 188 < bytes.length && i < 188) {\n      if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n        return true;\n      }\n\n      i += 1;\n    }\n\n    return false;\n  },\n  flac: function flac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.flac, {\n      offset: offset\n    });\n  },\n  ogg: function ogg(bytes) {\n    return bytesMatch(bytes, CONSTANTS.ogg);\n  },\n  avi: function avi(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\n      offset: 8\n    });\n  },\n  wav: function wav(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\n      offset: 8\n    });\n  },\n  'h264': function h264(bytes) {\n    // find seq_parameter_set_rbsp\n    return findH264Nal(bytes, 7, 3).length;\n  },\n  'h265': function h265(bytes) {\n    // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n    return findH265Nal(bytes, [32, 33], 3).length;\n  }\n}; // get all the isLikely functions\n// but make sure 'ts' is above h264 and h265\n// but below everything else as it is the least specific\n\nvar isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n.filter(function (t) {\n  return t !== 'ts' && t !== 'h264' && t !== 'h265';\n}) // add it back to the bottom\n.concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\nisLikelyTypes.forEach(function (type) {\n  var isLikelyFn = _isLikely[type];\n\n  _isLikely[type] = function (bytes) {\n    return isLikelyFn(toUint8(bytes));\n  };\n}); // export after wrapping\n\nexport var isLikely = _isLikely; // A useful list of file signatures can be found here\n// https://en.wikipedia.org/wiki/List_of_file_signatures\n\nexport var detectContainerForBytes = function detectContainerForBytes(bytes) {\n  bytes = toUint8(bytes);\n\n  for (var i = 0; i < isLikelyTypes.length; i++) {\n    var type = isLikelyTypes[i];\n\n    if (isLikely[type](bytes)) {\n      return type;\n    }\n  }\n\n  return '';\n}; // fmp4 is not a container\n\nexport var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n  return findBox(bytes, ['moof']).length > 0;\n};"]},"metadata":{},"sourceType":"module"}