{"ast":null,"code":"import { ResourceClient } from '@elan-ev/reststate-client';\nimport deepEquals from './deepEquals';\nconst STATUS_INITIAL = 'INITIAL';\nconst STATUS_LOADING = 'LOADING';\nconst STATUS_ERROR = 'ERROR';\nconst STATUS_SUCCESS = 'SUCCESS';\nconst storeRecord = records => newRecord => {\n  const existingRecord = records.find(r => r.id === newRecord.id);\n  if (existingRecord) {\n    Object.assign(existingRecord, newRecord);\n  } else {\n    records.push(newRecord);\n  }\n};\nconst getResourceIdentifier = resource => {\n  if (!resource) {\n    return resource;\n  }\n  return {\n    type: resource.type,\n    id: resource.id\n  };\n};\nconst getRelationshipType = relationship => {\n  const data = Array.isArray(relationship.data) ? relationship.data[0] : relationship.data;\n  return data && data.type;\n};\nconst storeIncluded = ({\n  commit,\n  dispatch\n}, result) => {\n  if (result.included) {\n    // store the included records\n    result.included.forEach(relatedRecord => {\n      const action = `${relatedRecord.type}/storeRecord`;\n      dispatch(action, relatedRecord, {\n        root: true\n      });\n    });\n\n    // store the relationship for primary and secondary records\n    let allRecords = [...result.included];\n    if (Array.isArray(result.data)) {\n      allRecords = [...allRecords, ...result.data];\n    } else {\n      allRecords = [...allRecords, result.data];\n    }\n    allRecords.forEach(primaryRecord => {\n      if (primaryRecord.relationships) {\n        Object.keys(primaryRecord.relationships).forEach(relationshipName => {\n          const relationship = primaryRecord.relationships[relationshipName];\n          if (!relationship.data || relationship.data.length === 0) {\n            return;\n          }\n          const type = getRelationshipType(relationship);\n          let relatedIds;\n          if (Array.isArray(relationship.data)) {\n            relatedIds = relationship.data.map(relatedRecord => relatedRecord.id);\n          } else {\n            ({\n              id: relatedIds\n            } = relationship.data);\n          }\n          const options = {\n            relatedIds,\n            params: {\n              parent: getResourceIdentifier(primaryRecord),\n              relationship: relationshipName\n            }\n          };\n          const action = `${type}/storeRelated`;\n          dispatch(action, options, {\n            root: true\n          });\n        });\n      }\n    });\n  }\n};\nconst matches = criteria => test => Object.keys(criteria).every(key => deepEquals(criteria[key], test[key]));\nconst handleError = commit => errorResponse => {\n  commit('SET_STATUS', STATUS_ERROR);\n  commit('STORE_ERROR', errorResponse);\n  throw errorResponse;\n};\nconst initialState = () => ({\n  records: [],\n  related: [],\n  filtered: [],\n  page: [],\n  error: null,\n  status: STATUS_INITIAL,\n  links: {},\n  lastCreated: null,\n  lastMeta: null\n});\nconst resourceModule = ({\n  name: resourceName,\n  httpClient\n}) => {\n  const client = new ResourceClient({\n    name: resourceName,\n    httpClient\n  });\n  const getRelationshipIndex = params => {\n    const {\n      parent,\n      relationship = resourceName\n    } = params;\n    const parentResourceIdentifier = getResourceIdentifier(parent);\n    return {\n      parent: parentResourceIdentifier,\n      relationship\n    };\n  };\n  return {\n    namespaced: true,\n    state: initialState,\n    mutations: {\n      REPLACE_ALL_RECORDS: (state, records) => {\n        state.records = records;\n      },\n      REPLACE_ALL_RELATED: (state, related) => {\n        state.related = related;\n      },\n      SET_STATUS: (state, status) => {\n        state.status = status;\n      },\n      STORE_RECORD: (state, newRecord) => {\n        const {\n          records\n        } = state;\n        storeRecord(records)(newRecord);\n      },\n      STORE_RECORDS: (state, newRecords) => {\n        const {\n          records\n        } = state;\n        newRecords.forEach(storeRecord(records));\n      },\n      STORE_PAGE: (state, records) => {\n        state.page = records.map(({\n          id\n        }) => id);\n      },\n      STORE_META: (state, meta) => {\n        state.lastMeta = meta;\n      },\n      STORE_ERROR: (state, error) => {\n        state.error = error;\n      },\n      STORE_RELATED: (state, {\n        relatedIds,\n        params,\n        resetRelated = true\n      }) => {\n        const {\n          related\n        } = state;\n        const relationshipIndex = getRelationshipIndex(params);\n        const existingRecord = related.find(matches(relationshipIndex));\n        if (existingRecord) {\n          if (resetRelated) {\n            existingRecord.relatedIds = relatedIds;\n          } else {\n            const ids = new Set([...existingRecord.relatedIds, ...relatedIds]);\n            existingRecord.relatedIds = [...ids];\n          }\n        } else {\n          related.push(Object.assign({\n            relatedIds\n          }, relationshipIndex));\n        }\n      },\n      STORE_FILTERED: (state, {\n        matchedIds,\n        params\n      }) => {\n        const {\n          filtered\n        } = state;\n        const existingRecord = filtered.find(matches(params));\n        if (existingRecord) {\n          existingRecord.matchedIds = matchedIds;\n        } else {\n          filtered.push(Object.assign({\n            matchedIds\n          }, params));\n        }\n      },\n      STORE_LAST_CREATED: (state, record) => {\n        state.lastCreated = record;\n      },\n      REMOVE_RECORD: (state, record) => {\n        state.records = state.records.filter(r => r.id !== record.id);\n      },\n      SET_LINKS: (state, links) => {\n        state.links = links || {};\n      },\n      RESET_STATE: state => {\n        Object.assign(state, initialState());\n      }\n    },\n    actions: {\n      loadAll({\n        commit,\n        dispatch\n      }, {\n        options\n      } = {}) {\n        commit('SET_STATUS', STATUS_LOADING);\n        return client.all({\n          options\n        }).then(result => {\n          commit('SET_STATUS', STATUS_SUCCESS);\n          commit('REPLACE_ALL_RECORDS', result.data);\n          commit('STORE_META', result.meta);\n          storeIncluded({\n            commit,\n            dispatch\n          }, result);\n        }).catch(handleError(commit));\n      },\n      loadById({\n        commit,\n        dispatch\n      }, {\n        id,\n        options\n      }) {\n        commit('SET_STATUS', STATUS_LOADING);\n        return client.find({\n          id,\n          options\n        }).then(results => {\n          commit('SET_STATUS', STATUS_SUCCESS);\n          commit('STORE_RECORD', results.data);\n          commit('STORE_META', results.meta);\n          storeIncluded({\n            commit,\n            dispatch\n          }, results);\n        }).catch(handleError(commit));\n      },\n      loadWhere({\n        commit,\n        dispatch\n      }, params) {\n        const {\n          filter,\n          options\n        } = params;\n        commit('SET_STATUS', STATUS_LOADING);\n        return client.where({\n          filter,\n          options\n        }).then(results => {\n          commit('SET_STATUS', STATUS_SUCCESS);\n          const matches = results.data;\n          const matchedIds = matches.map(record => record.id);\n          commit('STORE_RECORDS', matches);\n          commit('STORE_FILTERED', {\n            params,\n            matchedIds\n          });\n          commit('STORE_META', results.meta);\n          storeIncluded({\n            commit,\n            dispatch\n          }, results);\n        }).catch(handleError(commit));\n      },\n      loadPage({\n        commit,\n        dispatch\n      }, {\n        options\n      }) {\n        commit('SET_STATUS', STATUS_LOADING);\n        return client.all({\n          options\n        }).then(response => {\n          commit('SET_STATUS', STATUS_SUCCESS);\n          commit('STORE_RECORDS', response.data);\n          commit('STORE_PAGE', response.data);\n          commit('STORE_META', response.meta);\n          commit('SET_LINKS', response.links);\n          storeIncluded({\n            commit,\n            dispatch\n          }, response);\n        }).catch(handleError(commit));\n      },\n      loadNextPage({\n        commit,\n        state,\n        dispatch\n      }) {\n        const options = {\n          url: state.links.next\n        };\n        return client.all({\n          options\n        }).then(response => {\n          commit('STORE_RECORDS', response.data);\n          commit('STORE_PAGE', response.data);\n          commit('SET_LINKS', response.links);\n          commit('STORE_META', response.meta);\n          storeIncluded({\n            commit,\n            dispatch\n          }, response);\n        });\n      },\n      loadPreviousPage({\n        commit,\n        state,\n        dispatch\n      }) {\n        const options = {\n          url: state.links.prev\n        };\n        return client.all({\n          options\n        }).then(response => {\n          commit('STORE_RECORDS', response.data);\n          commit('STORE_PAGE', response.data);\n          commit('SET_LINKS', response.links);\n          commit('STORE_META', response.meta);\n          storeIncluded({\n            commit,\n            dispatch\n          }, response);\n        });\n      },\n      loadRelated({\n        commit,\n        dispatch\n      }, params) {\n        const {\n          parent,\n          relationship = resourceName,\n          options,\n          resetRelated = true\n        } = params;\n        commit('SET_STATUS', STATUS_LOADING);\n        const paramsToStore = {\n          ...params,\n          relationship\n        };\n        return client.related({\n          parent,\n          relationship,\n          options\n        }).then(results => {\n          commit('SET_STATUS', STATUS_SUCCESS);\n          const {\n            id,\n            type\n          } = parent;\n          if (Array.isArray(results.data)) {\n            const relatedRecords = results.data;\n            const relatedIds = relatedRecords.map(record => record.id);\n            commit('STORE_RECORDS', relatedRecords);\n            commit('STORE_RELATED', {\n              params: paramsToStore,\n              relatedIds,\n              resetRelated\n            });\n          } else {\n            const record = results.data;\n            const relatedIds = record.id;\n            commit('STORE_RECORDS', [record]);\n            commit('STORE_RELATED', {\n              params: paramsToStore,\n              relatedIds\n            });\n          }\n          commit('STORE_META', results.meta);\n          storeIncluded({\n            commit,\n            dispatch\n          }, results);\n        }).catch(handleError(commit));\n      },\n      create({\n        commit\n      }, recordData) {\n        return client.create(recordData).then(result => {\n          commit('STORE_RECORD', result.data);\n          commit('STORE_LAST_CREATED', result.data);\n        });\n      },\n      update({\n        commit,\n        dispatch,\n        getters\n      }, record) {\n        return client.update(record).then(() => {\n          const oldRecord = getters.byId({\n            id: record.id\n          });\n\n          // remove old relationships first\n          if (oldRecord && oldRecord.relationships) {\n            for (const entry of Object.entries(oldRecord.relationships)) {\n              const [relationship, entity] = entry;\n              const type = getRelationshipType(entity);\n              const paramsToStore = {\n                relationship,\n                parent: getResourceIdentifier(oldRecord)\n              };\n\n              // we cannot update the related resource without a type\n              // this could possibly be very bad as we cannot remove existing\n              // relationships\n              if (type === null || type === undefined) {\n                continue;\n              }\n              dispatch(`${type}/storeRelated`, {\n                params: paramsToStore,\n                relatedIds: null\n              }, {\n                root: true\n              });\n            }\n          }\n\n          // save entity\n          commit('STORE_RECORD', record);\n\n          // set new relationships\n          if (record.relationships) {\n            for (const relationship of Object.keys(record.relationships)) {\n              const relationshipObject = record.relationships[relationship];\n              const {\n                data\n              } = relationshipObject;\n              const isNonEmptyArray = Array.isArray(data) && Boolean(data.length);\n              const isObject = Boolean(data && data.type && data.id);\n              if (isNonEmptyArray || isObject) {\n                const paramsToStore = {\n                  parent: getResourceIdentifier(record),\n                  relationship\n                };\n                const type = getRelationshipType(relationshipObject);\n                let relatedIds;\n                if (Array.isArray(data)) {\n                  relatedIds = data.map(record => record.id);\n                } else {\n                  relatedIds = data.id;\n                }\n                dispatch(`${type}/storeRelated`, {\n                  params: paramsToStore,\n                  relatedIds\n                }, {\n                  root: true\n                });\n              }\n            }\n          }\n        });\n      },\n      delete({\n        commit\n      }, record) {\n        return client.delete(record).then(() => {\n          commit('REMOVE_RECORD', record);\n        });\n      },\n      storeRecord({\n        commit\n      }, record) {\n        commit('STORE_RECORD', record);\n      },\n      storeRelated({\n        commit\n      }, {\n        relatedIds,\n        params\n      }) {\n        commit('STORE_RELATED', {\n          relatedIds,\n          params\n        });\n      },\n      removeRecord({\n        commit\n      }, record) {\n        commit('REMOVE_RECORD', record);\n      },\n      resetState({\n        commit\n      }) {\n        commit('RESET_STATE');\n      },\n      addRelated({\n        commit,\n        getters\n      }, params) {\n        const {\n          parent,\n          relationship = resourceName,\n          data\n        } = params;\n        const relatedItems = getters.related(params).map(o => o.id);\n        const difference = data.filter(x => !relatedItems.includes(x));\n        const records = difference.map(id => {\n          return {\n            type: relationship,\n            id\n          };\n        });\n        return client.createRelationships(parent, relationship, records);\n      },\n      setRelated({\n        commit,\n        dispatch\n      }, params) {\n        const {\n          parent,\n          relationship = resourceName,\n          data\n        } = params;\n        return client.updateRelationships(parent, relationship, data).then(response => {\n          let relatedIds;\n          if (Array.isArray(data)) {\n            relatedIds = data.map(record => record.id);\n          } else if (data === null) {\n            relatedIds = null;\n          } else {\n            relatedIds = data.id;\n          }\n          commit('STORE_RELATED', {\n            params: {\n              parent,\n              relationship\n            },\n            relatedIds\n          });\n        });\n      },\n      removeRelated({\n        commit,\n        dispatch\n      }, params) {\n        const {\n          parent,\n          relationship = resourceName,\n          data\n        } = params;\n        client.removeRelationships(parent, relationship, data);\n        if (Array.isArray(data)) {\n          relatedIds = data.map(record => record.id);\n        } else {\n          relatedIds = data.id;\n        }\n        commit('REMOVE_RELATED', {\n          params: {\n            parent,\n            relationship\n          },\n          relatedIds\n        });\n      },\n      removeAllRelated({\n        commit,\n        dispatch\n      }, params) {\n        const {\n          parent,\n          relationship = resourceName\n        } = params;\n        client.updateRelationships(parent, relationship, []);\n        commit('REMOVE_RELATED', {\n          params: {\n            parent,\n            relationship\n          },\n          relatedIds: []\n        });\n      }\n    },\n    getters: {\n      isLoading: state => state.status === STATUS_LOADING,\n      isError: state => state.status === STATUS_ERROR,\n      error: state => state.error,\n      hasPrevious: state => !!state.links.prev,\n      hasNext: state => !!state.links.next,\n      all: state => state.records,\n      lastCreated: state => state.lastCreated,\n      byId: state => ({\n        id\n      }) => state.records.find(r => r.id == id),\n      lastMeta: state => state.lastMeta,\n      page: state => state.page.map(id => state.records.find(record => record.id === id)),\n      where: state => params => {\n        const entry = state.filtered.find(matches(params));\n        if (!entry) {\n          return [];\n        }\n        const ids = entry.matchedIds;\n        return ids.map(id => state.records.find(record => record.id === id));\n      },\n      related: state => params => {\n        const relationshipIndex = getRelationshipIndex(params);\n        const related = state.related.find(matches(relationshipIndex));\n        if (!related) {\n          return null;\n        } else if (Array.isArray(related.relatedIds)) {\n          const ids = related.relatedIds;\n          return ids.map(id => state.records.find(record => record.id === id)).filter(record => record !== undefined);\n        } else {\n          const id = related.relatedIds;\n          return state.records.find(record => id === record.id);\n        }\n      }\n    }\n  };\n};\nconst mapResourceModules = ({\n  names,\n  httpClient\n}) => names.reduce((acc, name) => Object.assign({\n  [name]: resourceModule({\n    name,\n    httpClient\n  })\n}, acc), {});\nexport { resourceModule, mapResourceModules };","map":{"version":3,"names":["ResourceClient","deepEquals","STATUS_INITIAL","STATUS_LOADING","STATUS_ERROR","STATUS_SUCCESS","storeRecord","records","newRecord","existingRecord","find","r","id","Object","assign","push","getResourceIdentifier","resource","type","getRelationshipType","relationship","data","Array","isArray","storeIncluded","commit","dispatch","result","included","forEach","relatedRecord","action","root","allRecords","primaryRecord","relationships","keys","relationshipName","length","relatedIds","map","options","params","parent","matches","criteria","test","every","key","handleError","errorResponse","initialState","related","filtered","page","error","status","links","lastCreated","lastMeta","resourceModule","name","resourceName","httpClient","client","getRelationshipIndex","parentResourceIdentifier","namespaced","state","mutations","REPLACE_ALL_RECORDS","REPLACE_ALL_RELATED","SET_STATUS","STORE_RECORD","STORE_RECORDS","newRecords","STORE_PAGE","STORE_META","meta","STORE_ERROR","STORE_RELATED","resetRelated","relationshipIndex","ids","Set","STORE_FILTERED","matchedIds","STORE_LAST_CREATED","record","REMOVE_RECORD","filter","SET_LINKS","RESET_STATE","actions","loadAll","all","then","catch","loadById","results","loadWhere","where","loadPage","response","loadNextPage","url","next","loadPreviousPage","prev","loadRelated","paramsToStore","relatedRecords","create","recordData","update","getters","oldRecord","byId","entry","entries","entity","undefined","relationshipObject","isNonEmptyArray","Boolean","isObject","delete","storeRelated","removeRecord","resetState","addRelated","relatedItems","o","difference","x","includes","createRelationships","setRelated","updateRelationships","removeRelated","removeRelationships","removeAllRelated","isLoading","isError","hasPrevious","hasNext","mapResourceModules","names","reduce","acc"],"sources":["/home/greg/dev/54/node_modules/@elan-ev/reststate-vuex/src/reststate-vuex.js"],"sourcesContent":["import { ResourceClient } from '@elan-ev/reststate-client';\nimport deepEquals from './deepEquals';\n\nconst STATUS_INITIAL = 'INITIAL';\nconst STATUS_LOADING = 'LOADING';\nconst STATUS_ERROR = 'ERROR';\nconst STATUS_SUCCESS = 'SUCCESS';\n\nconst storeRecord = records => newRecord => {\n  const existingRecord = records.find(r => r.id === newRecord.id);\n  if (existingRecord) {\n    Object.assign(existingRecord, newRecord);\n  } else {\n    records.push(newRecord);\n  }\n};\n\nconst getResourceIdentifier = resource => {\n  if (!resource) {\n    return resource;\n  }\n\n  return {\n    type: resource.type,\n    id: resource.id,\n  };\n};\n\nconst getRelationshipType = relationship => {\n  const data = Array.isArray(relationship.data)\n    ? relationship.data[0]\n    : relationship.data;\n\n  return data && data.type;\n};\n\nconst storeIncluded = ({ commit, dispatch }, result) => {\n  if (result.included) {\n    // store the included records\n    result.included.forEach(relatedRecord => {\n      const action = `${relatedRecord.type}/storeRecord`;\n      dispatch(action, relatedRecord, { root: true });\n    });\n\n    // store the relationship for primary and secondary records\n    let allRecords = [...result.included];\n    if (Array.isArray(result.data)) {\n      allRecords = [...allRecords, ...result.data];\n    } else {\n      allRecords = [...allRecords, result.data];\n    }\n\n    allRecords.forEach(primaryRecord => {\n      if (primaryRecord.relationships) {\n        Object.keys(primaryRecord.relationships).forEach(relationshipName => {\n          const relationship = primaryRecord.relationships[relationshipName];\n          if (!relationship.data || relationship.data.length === 0) {\n            return;\n          }\n\n          const type = getRelationshipType(relationship);\n          let relatedIds;\n          if (Array.isArray(relationship.data)) {\n            relatedIds = relationship.data.map(\n              relatedRecord => relatedRecord.id,\n            );\n          } else {\n            ({ id: relatedIds } = relationship.data);\n          }\n          const options = {\n            relatedIds,\n            params: {\n              parent: getResourceIdentifier(primaryRecord),\n              relationship: relationshipName,\n            },\n          };\n          const action = `${type}/storeRelated`;\n          dispatch(action, options, { root: true });\n        });\n      }\n    });\n  }\n};\n\nconst matches = criteria => test =>\n  Object.keys(criteria).every(key => deepEquals(criteria[key], test[key]));\n\nconst handleError = commit => errorResponse => {\n  commit('SET_STATUS', STATUS_ERROR);\n  commit('STORE_ERROR', errorResponse);\n  throw errorResponse;\n};\n\nconst initialState = () => ({\n  records: [],\n  related: [],\n  filtered: [],\n  page: [],\n  error: null,\n  status: STATUS_INITIAL,\n  links: {},\n  lastCreated: null,\n  lastMeta: null,\n});\n\nconst resourceModule = ({ name: resourceName, httpClient }) => {\n  const client = new ResourceClient({ name: resourceName, httpClient });\n\n  const getRelationshipIndex = params => {\n    const { parent, relationship = resourceName } = params;\n    const parentResourceIdentifier = getResourceIdentifier(parent);\n\n    return {\n      parent: parentResourceIdentifier,\n      relationship,\n    };\n  };\n\n  return {\n    namespaced: true,\n\n    state: initialState,\n\n    mutations: {\n      REPLACE_ALL_RECORDS: (state, records) => {\n        state.records = records;\n      },\n\n      REPLACE_ALL_RELATED: (state, related) => {\n        state.related = related;\n      },\n\n      SET_STATUS: (state, status) => {\n        state.status = status;\n      },\n\n      STORE_RECORD: (state, newRecord) => {\n        const { records } = state;\n\n        storeRecord(records)(newRecord);\n      },\n\n      STORE_RECORDS: (state, newRecords) => {\n        const { records } = state;\n\n        newRecords.forEach(storeRecord(records));\n      },\n\n      STORE_PAGE: (state, records) => {\n        state.page = records.map(({ id }) => id);\n      },\n\n      STORE_META: (state, meta) => {\n        state.lastMeta = meta;\n      },\n\n      STORE_ERROR: (state, error) => {\n        state.error = error;\n      },\n\n      STORE_RELATED: (state, { relatedIds, params, resetRelated = true }) => {\n        const { related } = state;\n        const relationshipIndex = getRelationshipIndex(params);\n        const existingRecord = related.find(matches(relationshipIndex));\n        if (existingRecord) {\n          if (resetRelated) {\n            existingRecord.relatedIds = relatedIds;\n          } else {\n            const ids = new Set([...existingRecord.relatedIds, ...relatedIds])\n            existingRecord.relatedIds = [...ids];\n          }\n        } else {\n          related.push(Object.assign({ relatedIds }, relationshipIndex));\n        }\n      },\n\n      STORE_FILTERED: (state, { matchedIds, params }) => {\n        const { filtered } = state;\n\n        const existingRecord = filtered.find(matches(params));\n        if (existingRecord) {\n          existingRecord.matchedIds = matchedIds;\n        } else {\n          filtered.push(Object.assign({ matchedIds }, params));\n        }\n      },\n\n      STORE_LAST_CREATED: (state, record) => {\n        state.lastCreated = record;\n      },\n\n      REMOVE_RECORD: (state, record) => {\n        state.records = state.records.filter(r => r.id !== record.id);\n      },\n\n      SET_LINKS: (state, links) => {\n        state.links = links || {};\n      },\n\n      RESET_STATE: state => {\n        Object.assign(state, initialState());\n      },\n    },\n\n    actions: {\n      loadAll({ commit, dispatch }, { options } = {}) {\n        commit('SET_STATUS', STATUS_LOADING);\n        return client\n          .all({ options })\n          .then(result => {\n            commit('SET_STATUS', STATUS_SUCCESS);\n            commit('REPLACE_ALL_RECORDS', result.data);\n            commit('STORE_META', result.meta);\n            storeIncluded({ commit, dispatch }, result);\n          })\n          .catch(handleError(commit));\n      },\n\n      loadById({ commit, dispatch }, { id, options }) {\n        commit('SET_STATUS', STATUS_LOADING);\n        return client\n          .find({ id, options })\n          .then(results => {\n            commit('SET_STATUS', STATUS_SUCCESS);\n            commit('STORE_RECORD', results.data);\n            commit('STORE_META', results.meta);\n            storeIncluded({ commit, dispatch }, results);\n          })\n          .catch(handleError(commit));\n      },\n\n      loadWhere({ commit, dispatch }, params) {\n        const { filter, options } = params;\n        commit('SET_STATUS', STATUS_LOADING);\n        return client\n          .where({ filter, options })\n          .then(results => {\n            commit('SET_STATUS', STATUS_SUCCESS);\n            const matches = results.data;\n            const matchedIds = matches.map(record => record.id);\n            commit('STORE_RECORDS', matches);\n            commit('STORE_FILTERED', { params, matchedIds });\n            commit('STORE_META', results.meta);\n            storeIncluded({ commit, dispatch }, results);\n          })\n          .catch(handleError(commit));\n      },\n\n      loadPage({ commit, dispatch }, { options }) {\n        commit('SET_STATUS', STATUS_LOADING);\n        return client\n          .all({ options })\n          .then(response => {\n            commit('SET_STATUS', STATUS_SUCCESS);\n            commit('STORE_RECORDS', response.data);\n            commit('STORE_PAGE', response.data);\n            commit('STORE_META', response.meta);\n            commit('SET_LINKS', response.links);\n            storeIncluded({ commit, dispatch }, response);\n          })\n          .catch(handleError(commit));\n      },\n\n      loadNextPage({ commit, state, dispatch }) {\n        const options = {\n          url: state.links.next,\n        };\n        return client.all({ options }).then(response => {\n          commit('STORE_RECORDS', response.data);\n          commit('STORE_PAGE', response.data);\n          commit('SET_LINKS', response.links);\n          commit('STORE_META', response.meta);\n          storeIncluded({ commit, dispatch }, response);\n        });\n      },\n\n      loadPreviousPage({ commit, state, dispatch }) {\n        const options = {\n          url: state.links.prev,\n        };\n        return client.all({ options }).then(response => {\n          commit('STORE_RECORDS', response.data);\n          commit('STORE_PAGE', response.data);\n          commit('SET_LINKS', response.links);\n          commit('STORE_META', response.meta);\n          storeIncluded({ commit, dispatch }, response);\n        });\n      },\n\n      loadRelated({ commit, dispatch }, params) {\n        const { parent, relationship = resourceName, options, resetRelated = true } = params;\n        commit('SET_STATUS', STATUS_LOADING);\n        const paramsToStore = {\n          ...params,\n          relationship,\n        };\n        return client\n          .related({ parent, relationship, options })\n          .then(results => {\n            commit('SET_STATUS', STATUS_SUCCESS);\n            const { id, type } = parent;\n            if (Array.isArray(results.data)) {\n              const relatedRecords = results.data;\n              const relatedIds = relatedRecords.map(record => record.id);\n              commit('STORE_RECORDS', relatedRecords);\n              commit('STORE_RELATED', { params: paramsToStore, relatedIds, resetRelated });\n            } else {\n              const record = results.data;\n              const relatedIds = record.id;\n              commit('STORE_RECORDS', [record]);\n              commit('STORE_RELATED', { params: paramsToStore, relatedIds });\n            }\n            commit('STORE_META', results.meta);\n            storeIncluded({ commit, dispatch }, results);\n          })\n          .catch(handleError(commit));\n      },\n\n      create({ commit }, recordData) {\n        return client.create(recordData).then(result => {\n          commit('STORE_RECORD', result.data);\n          commit('STORE_LAST_CREATED', result.data);\n        });\n      },\n\n      update({ commit, dispatch, getters }, record) {\n        return client.update(record).then(() => {\n          const oldRecord = getters.byId({ id: record.id });\n\n          // remove old relationships first\n          if (oldRecord && oldRecord.relationships) {\n            for (const entry of Object.entries(oldRecord.relationships)) {\n              const [relationship, entity] = entry;\n              const type = getRelationshipType(entity);\n              const paramsToStore = {\n                relationship,\n                parent: getResourceIdentifier(oldRecord),\n              };\n\n              // we cannot update the related resource without a type\n              // this could possibly be very bad as we cannot remove existing\n              // relationships\n              if (type === null || type === undefined) {\n                  continue;\n              }\n\n              dispatch(\n                `${type}/storeRelated`,\n                {\n                  params: paramsToStore,\n                  relatedIds: null,\n                },\n                { root: true },\n              );\n            }\n          }\n\n          // save entity\n          commit('STORE_RECORD', record);\n\n          // set new relationships\n          if (record.relationships) {\n            for (const relationship of Object.keys(record.relationships)) {\n              const relationshipObject = record.relationships[relationship];\n              const { data } = relationshipObject;\n              const isNonEmptyArray =\n                Array.isArray(data) && Boolean(data.length);\n              const isObject = Boolean(data && data.type && data.id);\n\n              if (isNonEmptyArray || isObject) {\n                const paramsToStore = {\n                  parent: getResourceIdentifier(record),\n                  relationship,\n                };\n                const type = getRelationshipType(relationshipObject);\n                let relatedIds;\n                if (Array.isArray(data)) {\n                  relatedIds = data.map(record => record.id);\n                } else {\n                  relatedIds = data.id;\n                }\n                dispatch(\n                  `${type}/storeRelated`,\n                  {\n                    params: paramsToStore,\n                    relatedIds,\n                  },\n                  { root: true },\n                );\n              }\n            }\n          }\n        });\n      },\n\n      delete({ commit }, record) {\n        return client.delete(record).then(() => {\n          commit('REMOVE_RECORD', record);\n        });\n      },\n\n      storeRecord({ commit }, record) {\n        commit('STORE_RECORD', record);\n      },\n\n      storeRelated({ commit }, { relatedIds, params }) {\n        commit('STORE_RELATED', {\n          relatedIds,\n          params,\n        });\n      },\n\n      removeRecord({ commit }, record) {\n        commit('REMOVE_RECORD', record);\n      },\n\n      resetState({ commit }) {\n        commit('RESET_STATE');\n      },\n\n      addRelated({ commit, getters }, params) {\n        const { parent, relationship = resourceName, data } = params;\n        const relatedItems = getters.related(params).map(o => o.id);\n        const difference = data.filter(x => !relatedItems.includes(x));\n        const records = difference.map(id => {\n          return { type: relationship, id };\n        });\n        return client.createRelationships(parent, relationship, records);\n      },\n\n      setRelated({ commit, dispatch }, params) {\n        const { parent, relationship = resourceName, data } = params;\n        return client.updateRelationships(parent, relationship, data).then(response => {\n          let relatedIds;\n          if (Array.isArray(data)) {\n            relatedIds = data.map(record => record.id);\n          } else if (data === null) {\n            relatedIds = null;\n          } else {\n            relatedIds = data.id;\n          }\n          commit('STORE_RELATED', {\n            params: { parent, relationship },\n            relatedIds,\n          });\n        });\n      },\n\n      removeRelated({ commit, dispatch }, params) {\n        const { parent, relationship = resourceName, data } = params;\n        client.removeRelationships(parent, relationship, data);\n        if (Array.isArray(data)) {\n          relatedIds = data.map(record => record.id);\n        } else {\n          relatedIds = data.id;\n        }\n        commit('REMOVE_RELATED', {\n          params: { parent, relationship },\n          relatedIds,\n        });\n      },\n\n      removeAllRelated({ commit, dispatch }, params) {\n        const { parent, relationship = resourceName } = params;\n        client.updateRelationships(parent, relationship, []);\n        commit('REMOVE_RELATED', {\n          params: { parent, relationship },\n          relatedIds: [],\n        });\n      },\n    },\n\n    getters: {\n      isLoading: state => state.status === STATUS_LOADING,\n      isError: state => state.status === STATUS_ERROR,\n      error: state => state.error,\n      hasPrevious: state => !!state.links.prev,\n      hasNext: state => !!state.links.next,\n      all: state => state.records,\n      lastCreated: state => state.lastCreated,\n      byId: state => ({ id }) => state.records.find(r => r.id == id),\n      lastMeta: state => state.lastMeta,\n      page: state =>\n        state.page.map(id => state.records.find(record => record.id === id)),\n      where: state => params => {\n        const entry = state.filtered.find(matches(params));\n\n        if (!entry) {\n          return [];\n        }\n\n        const ids = entry.matchedIds;\n        return ids.map(id => state.records.find(record => record.id === id));\n      },\n      related: state => params => {\n        const relationshipIndex = getRelationshipIndex(params);\n        const related = state.related.find(matches(relationshipIndex));\n\n        if (!related) {\n          return null;\n        } else if (Array.isArray(related.relatedIds)) {\n          const ids = related.relatedIds;\n          return ids\n            .map(id => state.records.find(record => record.id === id))\n            .filter(record => record !== undefined);\n        } else {\n          const id = related.relatedIds;\n          return state.records.find(record => id === record.id);\n        }\n      },\n    },\n  };\n};\n\nconst mapResourceModules = ({ names, httpClient }) =>\n  names.reduce(\n    (acc, name) =>\n      Object.assign({ [name]: resourceModule({ name, httpClient }) }, acc),\n    {},\n  );\n\nexport { resourceModule, mapResourceModules };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}